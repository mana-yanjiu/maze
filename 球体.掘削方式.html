<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8 />
    <style>
      html {
        font-size: 10px;
      }
      :root {
        --main-width: 35.1rem;
      }
      body {
        margin: 0;
        padding: 0;
      }
      body.operating * {
        user-select: none;
      }
      #contents_frame {
        display: grid;
        grid-template-columns: auto auto 1fr;
        grid-template-rows: auto auto auto;
        margin: 1rem;
        padding: 0;
      }
      #radar_frame {
        position: relative;
        grid-column: 1;
        grid-row: 1;
        margin: 0 1rem 1rem 0;
        width: var(--main-width);
        height: var(--main-width);
        border: solid 0.1rem #aaa;
        /* opacity: 0.2; */
      }
      #radar {
        position: absolute;
      }
      #test {
        /* opacity: 0.5; */
        grid-column: 1;
        grid-row: 2;
        border: solid 0.1rem #aaa;
      }
      #gauze {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        cursor: default;
        z-index: 1;
      }
      #form_frame {
        /* display: none; */
        grid-column: 2;
        grid-row: 1 / 3;
        margin: 0 0 auto;
        padding: 0.5rem;
        border: solid 0.1rem #aaa;
        font-size: 1.2rem;
        width: 30rem;
      }
      #form_frame form {
        padding: 0;
      }
      .項目 {
        margin: 0 0 0.5rem 0;
        padding: 0.5rem;
        background-color: #eeeeff;
        display: grid;
        grid-template-columns: 25% 1fr;
      }
      .項目:last-child {
        margin: 0;
      }
      #setting_box {
        display: grid;
        grid-template-columns: 25% 1fr;
      }
      #switch_box {
        display: flex;
        align-items: center;
        padding-right: 1rem;
      }
      #meter_box {
        position: relative;
        height: 2.6rem;
        flex-grow: 1;
      }
      #meter_box::after {
        content: "";
        position: absolute;
        top: 1.2rem;
        left: 0;
        width: 100%;
        border-bottom: solid 0.2rem #88a;
        z-index: 1;
      }
      #handle {
        position: absolute;
        width: 1rem;
        height: 2.6rem;
        border: solid 1px #aaaaff;
        background-color: #ffffff;
        box-sizing: border-box;
        z-index: 2;
      }
      #meter_box.disable #handle {
        border: solid 1px #8888aa;
        background-color: #aaaaaa;
      }
    </style>
  </head>
  <body>
    <div id="contents_frame">
      <div id="radar_frame">
        <canvas id="radar"></canvas>
        <div id="gauze"></div>
      </div>
      <div id="form_frame">
        <form name="再生" action="" method="get">
          <div id="setting_box" class="項目">
            <div id="switch_box">
              <input type="checkbox" name="distance" id="distance_switch" checked />
              <label for="distance_switch">ズーム</label>
            </div>
            <div id="meter_box">
              <div id="handle"></div>
            </div>
          </div>
          <div class="項目">
            <span>面数</span>
            <select name="面指定">
              <option value="4">4</option>
              <option value="6">6</option>
              <option value="8">8</option>
              <option value="12">12</option>
              <option value="20">20</option>
            </select>
          </div>
        </form>
      </div>
      <canvas id="test"></canvas>
    </div>
    <script>
      const 隔壁高 = 10;
      const 光源 = { X: 30 / 180 * Math.PI, Y:  45 / 180 * Math.PI };
      const 画面幅 = 351;
      const 中心 = 画面幅 / 2 + 0.5;
      const 径 = 160;
      const 中心空間確保 = true;
      const 軸走査限界半径 = 170;
      const 最小画角度 = (5 / 180) * Math.PI;
      const 最大画角度 = (20 / 180) * Math.PI;
      const frameElem = document.getElementById('radar_frame');
      const 描画実体 = document.getElementById('radar');
      const 描画制御 = 描画実体.getContext('2d');
      const gauzeElem = document.getElementById('gauze');
      const checkElem = document.再生.distance;
      const selectElem = document.再生.parameter_type;
      const meterBoxElem = document.getElementById('meter_box');
      const meterHandleElem = document.getElementById('handle');
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
      const rect = frameElem.getBoundingClientRect();
      const meterBoxStyle = window.getComputedStyle(meterBoxElem, '');
      const meterBoxWidth = parseInt(meterBoxStyle.width.replace('px', ''));
      const meterHandleStyle = window.getComputedStyle(meterHandleElem, '');
      const meterHandlePadding = parseInt(meterHandleStyle.width.replace('px', '')) / 2;
      const surfaceGroup = {};
      const 面接続情報群群 = {
        4: [
          [[1, 0], [2, 0], [3, 0]],
          [[0, 0], [3, 2], [2, 1]],
          [[0, 1], [1, 2], [3, 1]],
          [[0, 2], [2, 2], [1, 1]],
        ],
        6: [
          [[1, 0], [2, 0], [3, 0], [4, 0]],
          [[0, 0], [4, 3], [5, 2], [2, 1]],
          [[0, 1], [1, 3], [5, 1], [3, 1]],
          [[0, 2], [2, 3], [5, 0], [4, 1]],
          [[0, 3], [3, 3], [5, 3], [1, 1]],
          [[3, 2], [2, 2], [1, 2], [4, 2]],
        ],
        8: [
          [[1, 0], [2, 0], [3, 0]],
          [[0, 0], [5, 1], [6, 2]],
          [[0, 1], [6, 1], [4, 2]],
          [[0, 2], [4, 1], [5, 2]],
          [[7, 0], [3, 1], [2, 2]],
          [[7, 2], [1, 1], [3, 2]],
          [[7, 1], [2, 1], [1, 2]],
          [[4, 0], [6, 0], [5, 0]],
        ],
        12: [
          [[1, 0], [2, 0], [3, 0], [4, 0], [5, 0]],
          [[0, 0], [5, 4], [8, 2], [9, 3], [2, 1]],
          [[0, 1], [1, 4], [9, 2], [10, 3], [3, 1]],
          [[0, 2], [2, 4], [10, 2], [6, 3], [4, 1]],
          [[0, 3], [3, 4], [6, 2], [7, 3], [5, 1]],
          [[0, 4], [4, 4], [7, 2], [8, 3], [1, 1]],
          [[11, 0], [7, 4], [4, 2], [3, 3], [10, 1]],
          [[11, 4], [8, 4], [5, 2], [4, 3], [6, 1]],
          [[11, 3], [9, 4], [1, 2], [5, 3], [7, 1]],
          [[11, 2], [10, 4], [2, 2], [1, 3], [8, 1]],
          [[11, 1], [6, 4], [3, 2], [2, 3], [9, 1]],
          [[6, 0], [10, 0], [9, 0], [8, 0], [7, 0]],
        ],
        20: [
          [[1, 0], [2, 0], [3, 0]],
          [[0, 0], [8, 0], [6, 0]],
          [[0, 1], [9, 0], [4, 0]],
          [[0, 2], [7, 0], [5, 0]],
          [[2, 2], [14, 1], [7, 1]],
          [[3, 2], [15, 1], [8, 1]],
          [[1, 2], [13, 1], [9, 1]],
          [[3, 1], [4, 2], [12, 2]],
          [[1, 1], [5, 2], [10, 2]],
          [[2, 1], [6, 2], [11, 2]],
          [[17, 1], [13, 2], [8, 2]],
          [[18, 1], [14, 2], [9, 2]],
          [[16, 1], [15, 2], [7, 2]],
          [[18, 2], [6, 1], [10, 1]],
          [[16, 2], [4, 1], [11, 1]],
          [[17, 2], [5, 1], [12, 1]],
          [[19, 0], [12, 0], [14, 0]],
          [[19, 2], [10, 0], [15, 0]],
          [[19, 1], [11, 0], [13, 0]],
          [[16, 0], [18, 0], [17, 0]],
        ],
      };
      const 通路列数群 = { 4: 5, 6: 4, 8: 4, 12: 4, 20: 3 };
      const 解像度群 = { 4: 8, 6: 6, 8: 6, 12: 4, 20: 4 };
      const 方向数群 = { 4: 3, 6: 4, 8: 3, 12: 5, 20: 3 };
      const 隔壁厚群 = { 4: 6, 6: 5, 8: 4, 12: 3, 20: 3 };
      const 定数群 = {
        4: (() => {
          const 線分1 = Math.sin(Math.PI / 3);
          const 角度1 = Math.acos(1 / 3);
          const 線分3 = 1 / Math.sin(角度1);
          const 角度2 = Math.acos(線分1 / 3 * 2);

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
        6: (() => {
          const 角度2 = Math.PI / 4;
          const 線分3 = Math.pow(3 / 2, 1 / 2);
          const 線分1 = 1 / Math.pow(2, 1 / 2);
          const 角度1 = Math.asin(1 / 線分3);

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
        8: (() => {
          const 線分1 = Math.sin(Math.PI / 3);
          const 角度1 = Math.acos(線分1 / 3 * 2);
          const 角度2 = Math.PI / 2 - 角度1;
          const 線分3 = Math.sin(角度1) * 3 / 2;

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
        12: (() => {
          const 五芒星比率 = (1 + Math.pow(5, 1 / 2)) / 2;
          const 線分1 = Math.sin(Math.PI / 5);
          const 線分2 = 線分1 * (1 + 五芒星比率);
          const 線分3 = Math.pow(線分1 * 線分1 + 線分2 * 線分2, 1 / 2);
          const 線分4 = Math.pow(線分3 * 線分3 - 1, 1 / 2);
          const 角度1 = Math.asin(1 / 線分3);
          const 角度2 = Math.acos(線分4 / 線分2);

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
        20: (() => {
          const 五芒星比率 = (1 + Math.pow(5, 1 / 2)) / 2;
          const 線分1 = Math.sin(Math.PI / 3);
          const 線分2 = 線分1 * 五芒星比率;
          const 線分3 = Math.pow(線分1 * 線分1 + 線分2 * 線分2, 1 / 2);
          const 角度1 = Math.asin(1 / 線分3);
          const 角度2 = Math.asin(1 / 2 / 線分2);

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
      }
      const 探索制御設定 = {
        ArrowUp: [0, -1],
        ArrowRight: [1, 0],
        ArrowDown: [0, 1],
        ArrowLeft: [-1, 0],
      };

      let 面数 = 12;
      let 通路列数 = 通路列数群[面数];
      let 解像度 = 解像度群[面数];
      let 方向数 = 方向数群[面数];
      let 面接続情報群 = 面接続情報群群[面数];
      let { 角度1, 角度2, 線分1, 線分3 } = 定数群[面数];
      let 隔壁厚 = 1;
      let 隔壁厚角度 = 隔壁厚 / 径;
      let 座標群 = {};
      let 隔壁臨界位置群 = [];
      let 通路臨界位置群 = [];
      let 隔壁厚距離1 = 0;
      let 隔壁厚距離2 = 0;
      let 通路厚距離1 = 0;
      let 通路厚距離2 = 0;
      let 通路厚角度 = 0;
      let 基準Z = 0;
      let moveType = 'vector';
      let 転回信号 = false;
      let animation = null;
      let animationSwitch = false;
      let animationStartSwitch = false;
      let animationTimeout = null;
      let 探索指示 = [0, 0];
      let latestBaseX = 0;
      let latestBaseY = 0;
      let latestMoveX = 0;
      let latestMoveY = 0;
      let 移動角度R = 0;
      let 移動角度V = 0;
      let 移動角度L = 0;
      let 相対角度R = 0;
      let 相対角度L = 0;
      let 基本角度R = 0;
      let 基本角度V = 0;
      let 基本角度L = 0;
      let 合成角度R = 0;
      let 合成角度V = 0;
      let 合成角度L = 0;
      let 軸角度 = 合成角度V - Math.PI / 2;
      let 画角度 = 最小画角度;
      let 視角拡大率 = Math.tan(画角度);
      let 一時座標群 = {};
      let 一時平面群 = [];
      let 移動履歴 = [[0, 0, 0, 0.5, 0.5]];
      let 現在座標 = [];
      let 目的面 = 0;
      let radarCoordinates = {};
      let distanceSwitch = true;
      let meterChangeSwitch = false;
      let 焦点距離 = distanceSwitch && 1 / Math.sin(画角度);
      let meterPosition = 0;
      let mousePosition = 0;
      const 迷路座標群 = [];
      const 隔壁平面群 = [];
      const 通路平面群 = [];
      const 壁頂平面群 = [];
      const 通路群 = [];
      const 連絡口群 = [];
      const 管轄群 = [];
      const 拡張可能通路群 = [];
      const 進捗平面対照群 = [];

      const 座標取得 = (角度, 距離) => ({
        X: Math.sin(角度) * 距離,
        Y: Math.cos(角度) * 距離,
      });

      const 角度取得 = (座標X, 座標Y) => ((距離) => ({
        L: 距離,
        T: 距離 > 0 ? Math.acos(座標Y / 距離) * (座標X >= 0 ? 1 : -1) : 0,
      }))(Math.pow(座標X * 座標X + 座標Y * 座標Y, 1 / 2));

      const 楕円交線座標取得 = (楕円A, 楕円B, 楕円C, 交線A, 交線B) => {
        const 係数A = 1 / 楕円A / 楕円A + 交線A * 交線A / 楕円B / 楕円B;
        const 係数B = 交線A * (交線B - 楕円C) / 楕円B / 楕円B;
        const 係数C = (交線B - 楕円C) * (交線B - 楕円C) / 楕円B / 楕円B - 1;
        const 交点X = (Math.pow(係数B * 係数B - 係数A * 係数C, 1 / 2) * (交線A >= 0 ? 1 : -1) - 係数B) / 係数A;
        const 交点Y = 交線A * 交点X + 交線B - 楕円C;
        const 交点L = Math.pow(交点X * 交点X + 交点Y * 交点Y, 1 / 2);

        return { X: 交点X, Y: 交点Y + 楕円C, L: 交点L };
      };

      const 隔壁臨界位置取得 = (列, 表裏) => {
        const 角度X = 角度2 / 通路列数 * (列 + 1) + (隔壁厚角度 * [-1, 1][表裏] || 0);
        const { X: 距離X1, Y: 楕円A } = 座標取得(角度2 - 角度X, 線分3);
        const 座標Y1 = Math.sin(角度X) * 線分3;
        const 交線A = Math.cos(Math.PI / 方向数) / 線分1;
        const 交線B0 = Math.sin(Math.PI / 2 - 角度2) * 距離X1 * -1;
        const 交線B1 = 隔壁厚距離1 / Math.sin(Math.PI / 方向数);
        const 楕円B = 座標Y1 - 交線B0;
        const { X: 交点X0 } = 楕円交線座標取得(楕円A, 楕円B, 交線B0, 交線A, 0);
        const { X: 交点X1 } = 楕円交線座標取得(楕円A, 楕円B, 交線B0, 交線A, 交線B1);
        const 角度Y0 = Math.asin(交点X0 / 楕円A);
        const 角度Y1 = Math.asin(交点X1 / 楕円A);

        return { 角度X, 角度Y: 角度Y0, 楕円A, 楕円B, 交線B: 交線B0 };
      };

      const 隣接方向座標取得 = (内外臨界位置, 方向, 交線A0, 交線B0, 前後係数) => {
        const 軸T = Math.PI / 方向数 * 前後係数 * 2;
        const 軸A = Math.tan(Math.PI / 2 - 軸T);
        const 交線X = 交線B0 / (軸A - 交線A0);
        const 交線Y = 軸A * 交線X;
        const 交線B = Math.pow(交線X * 交線X + 交線Y * 交線Y, 1 / 2) * (交線B0 >= 0 ? -1 : 1);
        const 交線A = Math.tan(Math.atan(交線A0) + 軸T);
        const { X: 座標X, Y: 座標Y } = 楕円交線座標取得(内外臨界位置.楕円A, 内外臨界位置.楕円B, 内外臨界位置.交線B, 交線A, 交線B);
        const { L: 距離Z, T: 角度Z } = 角度取得(座標X, 座標Y);
        const 角度X = Math.asin(距離Z / 線分3);
        const 角度Y = Math.asin(座標X / 内外臨界位置.楕円A);
        const 進捗 = (内外臨界位置.角度Y + 角度Y) / 内外臨界位置.角度Y / 2;

        return { 座標X, 座標Y, 距離Z, 角度X, 角度Z, 交線A, 方向: 方向 + 前後係数, 進捗 };
      };

      const 隣接通路情報取得 = (列, 方向, 進捗, 前後, 内外) => {
        const ddd = 列 === 1 && 方向 === 4;
        const ccc = (...B) => ddd && console.log(...B);
        if (!列 && 中心空間確保) {
          const [_, [終端]] = 隣接隔壁情報取得('連絡口', 0, 方向, 進捗, 前後, 0);

          return [
            [{ 方向, 進捗: 0 }, { 方向, 進捗 }],
            [{ 方向: 終端.方向, 進捗: 0 }, 終端],
          ];
        }

        const 内外臨界位置群 = [隔壁臨界位置群[列 - 1][1], 隔壁臨界位置群[列][0]];
        const 角度Z0 = Math.PI * 2 / 方向数 * 方向;
        const 角度Y1 = 内外臨界位置群[内外].角度Y * (進捗 * 2 - 1);
        const { X: 座標X1, Y: 距離X1 } = 座標取得(角度Y1, 内外臨界位置群[内外].楕円A);
        const 座標Y1 = Math.sin(角度2) * 距離X1 + 内外臨界位置群[内外].交線B;
        const { L: 距離Z1, T: 角度Z1 } = 角度取得(座標X1, 座標Y1);
        const 距離Z2 = Math.pow(距離Z1 * 距離Z1 - 隔壁厚距離1 * 隔壁厚距離1, 1 / 2);
        const 角度Z2 = Math.acos(距離Z2 / 距離Z1) * [1, -1][前後];
        const 交線B0 = 隔壁厚距離1 / Math.sin(角度Z1 + 角度Z2) * [1, -1][前後];
        const 交線A1 = (座標Y1 - 交線B0) / 座標X1;
        const { X: 交点X1, Y: 交点Y1 } = (({ 楕円A, 楕円B, 交線B }) => 楕円交線座標取得(楕円A, 楕円B, 交線B, 交線A1, 交線B0))(内外臨界位置群[1 - 内外]);
        const 角度YK = Math.asin(交点X1 / 内外臨界位置群[1 - 内外].楕円A);
        const { 座標X: 座標X2, 座標Y: 座標Y2, 距離Z: 距離Z3, 角度Z: 角度Z3, 方向: 方向2, 進捗: 進捗2 } = Math.abs(角度YK) <= 内外臨界位置群[1 - 内外].角度Y
          ? (({ 楕円A, 角度Y }) => {
            const { L: 距離Z, T: 角度Z } = 内外 ? 角度取得(交点X1, 交点Y1) : { L: 距離Z1, T: 角度Z1 };
            const 進捗 = (角度Y + 角度YK) / 角度Y / 2;

            return { 座標X: 交点X1, 座標Y: 交点Y1, 距離Z, 角度Z, 方向, 進捗 };
          })(内外臨界位置群[1 - 内外])
          : 隣接方向座標取得(内外臨界位置群[1 - 内外], 方向, 交線A1, 交線B0, 角度YK > 0 ? 1 : -1);
        const 基準座標 = ((群) => 内外 ? 群.reverse() : 群)([[座標X1, 座標Y1], [座標X2, 座標Y2]]);
        const 基準情報 = ((群) => 内外 ? 群.reverse() : 群)([{ 方向, 進捗 }, { 方向: 方向2, 進捗: 進捗2 }]);
        const [距離ZS, 角度ZS] = [[距離Z1, 角度Z1], [距離Z3, 角度Z3]][内外];
        const 距離Z4 = Math.pow(距離ZS * 距離ZS - 通路厚距離1 * 通路厚距離1, 1 / 2);
        const 角度Z4 = Math.acos(距離Z4 / 距離ZS) * [-1, 1][前後];
        const 交線B4 = 通路厚距離1 / Math.sin(角度ZS + 角度Z4) * [-1, 1][前後];
        const 交線A4 = (基準座標[0][1] - 交線B4) / 基準座標[0][0];
        const { X: 交点X5, Y: 交点Y5 } = (({ 楕円A, 楕円B, 交線B }) => 楕円交線座標取得(楕円A, 楕円B, 交線B, 交線A4, 交線B4 * -1))(内外臨界位置群[0]);
        const 角度YC = Math.asin(交点X5 / 内外臨界位置群[0].楕円A);
        const { 座標X: 座標X5, 座標Y: 座標Y5, 距離Z: 距離Z5, 角度Z: 角度Z5, 方向: 方向5, 進捗: 進捗5 } = Math.abs(角度YC) <= 内外臨界位置群[0].角度Y
          ? (({ 楕円A, 角度Y }) => {
            const { L: 距離Z, T: 角度Z } = 角度取得(交点X5, 交点Y5);
            const 進捗 = (角度Y + 角度YC) / 角度Y / 2;

            return { 座標X: 交点X5, 座標Y: 交点Y5, 距離Z, 角度Z, 方向: 基準情報[0].方向, 進捗 };
          })(内外臨界位置群[0])
          : 隣接方向座標取得(内外臨界位置群[0], 基準情報[0].方向, 交線A4, 交線B4 * -1, 角度YC > 0 ? 1 : -1);
        const 距離Z6 = Math.pow(距離Z5 * 距離Z5 - 隔壁厚距離1 * 隔壁厚距離1, 1 / 2);
        const 角度Z6 = Math.acos(距離Z6 / 距離Z5) * [-1, 1][前後];
        const 交線B6 = 隔壁厚距離1 / Math.sin(角度Z5 + 角度Z6) * [-1, 1][前後];
        const 交線A6 = (座標Y5 - 交線B6) / 座標X5;
        const { X: 交点X6, Y: 交点Y6 } = (({ 楕円A, 楕円B, 交線B }) => 楕円交線座標取得(楕円A, 楕円B, 交線B, 交線A6, 交線B6))(内外臨界位置群[1]);
        const 角度YS = Math.asin(交点X6 / 内外臨界位置群[1].楕円A);
        const { 方向: 方向6, 進捗: 進捗6 } = Math.abs(角度YS) <= 内外臨界位置群[1].角度Y
          ? { 方向: 方向5, 進捗: (内外臨界位置群[1].角度Y + 角度YS) / 内外臨界位置群[1].角度Y / 2 }
          : 隣接方向座標取得(内外臨界位置群[1], 方向, 交線A6, 交線B6, 角度YS > 0 ? 1 : -1);

        return [基準情報, [{ 方向: 方向5, 進捗: 進捗5 }, { 方向: 方向6, 進捗: 進捗6 }]];
      };

      const 隣接隔壁情報取得 = (種別, 列, 方向, 進捗, 前後, 内外) => {
        const 線幅 = { 隔壁: 隔壁厚距離1, 連絡口: 通路厚距離1 }[種別];
        const 線角度 = { 隔壁: 隔壁厚角度, 連絡口: 通路厚角度 }[種別];
        const 種別係数 = { 隔壁: 1, 連絡口: 0 }[種別];
        const { 角度Y, 楕円A, 楕円B, 交線B } = 隔壁臨界位置群[列 + (内外 - 種別係数) * 種別係数][(内外 + 種別係数) % 2];
        const 角度Z0 = Math.PI * 2 / 方向数 * 方向;
        const 角度Y1 = 角度Y * (進捗 * 2 - 1);
        const { X: 座標X1, Y: 距離X1 } = 座標取得(角度Y1, 楕円A);
        const 座標Y1 = Math.sin(角度2) * 距離X1 + 交線B;
        const { L: 距離Z1, T: 角度Z1 } = 角度取得(座標X1, 座標Y1);
        const 距離Z2 = Math.pow(距離Z1 * 距離Z1 - 線幅 * 線幅, 1 / 2);
        const 角度Z2 = Math.acos(距離Z2 / 距離Z1) * [-1, 1][前後];
        const 交線B0 = 線幅 / Math.sin(角度Z1 + 角度Z2) * [-1, 1][前後];
        const 交線A1 = (座標Y1 - 交線B0) / 座標X1;

        return [0, 1].map((前後係数) => {
          const 隔壁情報群 = [0, 1].map((内外係数) => {
            if (列 - 種別係数 * (1 - 内外係数) < 0) {
              return { X: 0, Y: 0, 進捗: 0, 極角度: 0 };
            }
            const { 角度Y: 角度Y0, 楕円A, 楕円B, 交線B: 交線B1 } = 隔壁臨界位置群[列 - 種別係数 * (1 - 内外係数)][Math.abs(内外係数 - 種別係数)];
            const 交線B2 = 交線B0 * [1, -1][前後係数];
            const { X: 交点X3, Y: 交点Y3 } = 楕円交線座標取得(楕円A, 楕円B, 交線B1, 交線A1, 交線B2);
            const { L: 距離Z3, T: 角度Y3 } = 角度取得(交点X3, 交点Y3);
            const 角度X3 = Math.asin(距離Z3 / 線分3);
            const 角度Y4 = Math.asin(交点X3 / 楕円A);
            const 座標X5 = 交点X3 - Math.sin(角度Z2) * 線幅;
            const 座標Y5 = 交点Y3 - Math.cos(角度Z2) * 線幅;
            const 距離Z5 = Math.pow(座標X5 * 座標X5 + 座標Y5 * 座標Y5, 1 / 2);
            const 角度X5 = Math.asin(距離Z5 / 線分3);
            const 進捗1 = (!前後係数 && 内外係数 === 内外) ? 進捗 : ((角度Y0 + 角度Y4) / 角度Y0 / 2);

            return Math.abs(角度Y4) <= 角度Y0
              ? { X: 角度X3, Y: 角度Y3 + 角度Z0, A: 交線A1, 方向, 進捗: 進捗1, 極角度: 角度X5 }
              : (() => {
                const 前後係数 = 角度Y4 > 0 ? 1 : -1;
                const { 角度X, 角度Z: 角度Y0, 交線A, 方向: 方向5, 進捗 } = 隣接方向座標取得(隔壁臨界位置群[列 - 種別係数 * (1 - 内外係数)][Math.abs(内外係数 - 種別係数)], 方向, 交線A1, 交線B2, 前後係数);
                const 角度Y1 = 角度Y0 + 角度Z0 + Math.PI / 方向数 * 前後係数 * 2;

                return { X: 角度X, Y: 角度Y1, A: 交線A, 方向: 方向5, 進捗, 極角度: 角度X5 };
              })();
          }, [[], 0]);

          const 中心角度 = 隔壁情報群.reduce((角度, { 極角度 }) => 角度 + 極角度, 0) / 2;
          const 角度Z3 = 角度Z1 + 角度Z2 + Math.PI / [[-2, 2], [2, -2]][前後][前後係数] * [-1, 1][種別係数];
          const { X: 座標X0, Y: 座標Y0 } = 座標取得(角度Z3, 線分3);
          const { X: 距離Z6, Y: 座標Z6 } = 座標取得(中心角度, 線幅);
          const { X: 座標X6, Y: 座標Y6 } = 座標取得(角度Z1 + 角度Z2, 距離Z6);
          const { L: 距離Z7, T: 角度Z7 } = 角度取得(座標X0 - 座標X6, 座標Y0 - 座標Y6);
          const 距離X7 = Math.pow(座標Z6 * 座標Z6 + 距離Z7 * 距離Z7, 1 / 2);
          const 角度X7 = Math.asin(座標Z6 / 距離X7) + Math.PI / 2;

          return 隔壁情報群.map((情報) => ({ ...情報, HX: 角度X7, HY: 角度Z7 + 角度Z0 }));
        });
      };

      const 隣接外端連絡口情報取得 = (面, 方向, 進捗, 前後) => {
        const { 角度Y, 交線B, 楕円A, 楕円B } = 隔壁臨界位置群[通路列数 - 1][0];
        const 連絡口比率 = 通路厚角度 / 角度Y;
        const [接続面, 接続方向] = 面接続情報群[面][方向];
        const 角度Z01 = Math.PI * 2 / 方向数 * 方向;
        const 角度Z02 = Math.PI * 2 / 方向数 * 接続方向;
        const 終始進捗群 = [進捗, 進捗 + 連絡口比率 * [-1, 1][前後]];
        const 座標情報群 = 終始進捗群.map((終始進捗, 終始) => {
          const [{ X: 角度X1, Y: 角度Z1 }] = 列壁座標取得(通路列数 - 1, 0, 0, 終始進捗);
          const 角度Y1 = 角度Y * (終始進捗 * 2 - 1);
          const 角度Y2 = 角度Y1 + Math.PI / (前後 === 終始 ? 2 : -2);
          const { X: 座標X1, Y: 距離X1 } = 座標取得(角度Y2, 1);
          const 座標Y1 = Math.sin(角度2) * 距離X1;
          const { L: 距離Z1, T: 角度Z2 } = 角度取得(座標X1, 座標Y1);
          const 角度X2 = ((角度) => 座標Y1 >= 0 ? 角度 : Math.PI - 角度)(Math.asin(距離Z1));

          return { X: 角度X1, Y: 角度Z1, HX: 角度X2, HY: 角度Z2, 進捗: 終始進捗 };
        });

        return [
          座標情報群.map((情報) => ({ ...情報, Y: 角度Z01 + 情報.Y, HY: 角度Z01 + 情報.HY, 方向 })),
          座標情報群.map((情報) => ({ ...情報, Y: 角度Z02 - 情報.Y, HY: 角度Z02 - 情報.HY, 方向: 接続方向, 進捗: 1 - 情報.進捗 })).reverse(),
        ];
      };

      const 面座標変換 = (面, 座標) => {
        if (面 === 0) {
          return { ...座標 };
        }
        if (面 === 面数 - 1 && 面数 !== 4) {
          return { ...座標, X: 座標.X + Math.PI, Y: 座標.Y * -1 };
        }
        if (面数 === 20) {
          const { R, X, Y } = 座標;
          const { X: 距離Z0, Y: 座標Z0 } = 座標取得(X, 1);
          const { X: 座標X0, Y: 座標Y0 } = (({ X, Y }) => ({ X: X * (面 < 面数 / 2 ? 1 : -1), Y }))(座標取得(Y, 距離Z0));
          if ([1, 2, 3, 16, 17, 18].includes(面)) {
            const { L: 距離X0, T: 角度X0 } = 角度取得(座標Y0, 座標Z0);
            const 角度X1 = 角度X0 - 角度2 * 2;
            const { X: 座標Y1, Y: 座標Z1 } = 座標取得(角度X1, 距離X0);
            const { L: 距離Z1, T: 角度Z1 } = 角度取得(座標X0, 座標Y1);
            const 角度Z2 = 角度Z1 + Math.PI * (1 + 2 / 方向数 * ((面 - 1) % 方向数));
            const { L: 距離X2, T: 角度X2 } = 角度取得(距離Z1, 座標Z1);

            return { R, X: 角度X2 + (面 > 面数 / 2 ? Math.PI : 0), Y: 角度Z2 };
          }
          const { T: 角度Z0 } = 角度取得(座標X0, 座標Y0);
          const 角度Z1 = 角度Z0 + Math.PI / ([4, 5, 6, 10, 11, 12].includes(面) ? 6 : -6);
          const { X: 座標X1, Y: 座標Y1 } = 座標取得(角度Z1, 距離Z0);
          const { L: 距離Y1, T: 角度Y1 } = 角度取得(座標X1, 座標Z0);
          const 角度Y2 = 角度Y1 + 角度2 * ([4, 5, 6, 10, 11, 12].includes(面) ? 1 : -1);
          const { X: 座標X2, Y: 座標Z2 } = 座標取得(角度Y2, 距離Y1);
          const { L: 距離X2, T: 角度X2 } = 角度取得(座標Y1, 座標Z2);
          const 角度Y0 = Math.asin(線分1 / 線分3)
          const 角度X3 = 角度X2 - 角度1 - 角度Y0;
          const { X: 座標Y3, Y: 座標Z3 } = 座標取得(角度X3, 距離X2);
          const { L: 距離Z3, T: 角度Z3 } = 角度取得(座標X2, 座標Y3);
          const { T: 角度X4 } = 角度取得(距離Z3, 座標Z3);
          const 角度Z4 = 角度Z3 + Math.PI * 2 / 3 * ([4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16].includes(面) ? (面 - 4) : (4 - 面));

          return { R, X: 角度X4 + (面 < 面数 / 2 ? 0 : Math.PI), Y: 角度Z4 };
        }
        const { R, X, Y } = 座標;
        const { X: 距離R0, Y: 座標Z0 } = 座標取得(X, 1);
        const { X: 座標X0, Y: 座標Y0 } = (({ X, Y }) => ({ X: X * (面 > 方向数 ? -1 : 1), Y }))(座標取得(Y, 距離R0));
        const { L: 距離X0, T: 角度X0 } = 角度取得(座標Y0, 座標Z0);
        const 角度X1 = 角度X0 - 角度2 * 2;
        const { X: 座標Y1, Y: 座標Z1 } = 座標取得(角度X1, 距離X0);
        const { L: 距離R1, T: 角度Z1 } = 角度取得(座標X0, 座標Y1);
        const 角度Z2 = 角度Z1 + Math.PI * (1 + 2 / 方向数 * ((面 - 1) % 方向数));
        const { L: 距離X2, T: 角度X2 } = 角度取得(距離R1, 座標Z1);

        return { R, X: 角度X2 + (面 > 方向数 ? Math.PI : 0), Y: 角度Z2 };
      };

      const 列壁座標取得 = (列, 方向, 表裏, 進捗, 法線取得 = 0) => {
        const { 角度X, 角度Y, 楕円A, 交線B } = 隔壁臨界位置群[列][表裏];
        const 角度Z1 = Math.PI * 2 / 方向数 * 方向;
        const 角度Y1 = 角度Y * (進捗 * 2 - 1);
        const { X: 座標X1, Y: 距離X1 } = 座標取得(角度Y1, 楕円A);
        const 座標Y1 = Math.sin(角度2) * 距離X1 + 交線B;
        const { L: 距離Z1, T: 角度Z2 } = 角度取得(座標X1, 座標Y1);
        const 角度X2 = Math.asin(距離Z1 / 線分3);
        const 座標 = { X: 角度X2, Y: 角度Z2 + 角度Z1, R: 径 };
        const 法線座標 = 法線取得 && (() => {
          const 角度Z3 = 角度Y1 + Math.PI * [1, -1][表裏];
          const 距離Z3 = Math.sin(角度2 - 角度X) * 線分3;
          const { X: 座標X3, Y: 座標Y3 } = 座標取得(角度Z3, 距離Z3);
          const { X: 座標Z3, Y: 距離X3 } = 座標取得(角度2 - 角度X, 線分3);
          const { X: 座標Y4, Y: 座標Z4 } = 座標取得(角度2 - Math.PI / 2, 距離X3);
          const 座標Y5 = 座標Y3 * Math.sin(角度2);
          const { L: 距離Z5, T: 角度Z5 } = 角度取得(座標X3, 座標Y4 + 座標Y5);
          const 角度X5 = Math.asin(距離Z5 / 線分3);

          return { X: 角度X5, Y: 角度Z5 + 角度Z1, R: 径 };
        })();

        return [座標, 法線座標];
      };

      const 通路生成 = (面, 列, 通路要素) => ({ 面, 列, 種別: '通路', 末端情報: [true, true], ...通路要素 });

      const 隔壁生成 = (面, 列, 隔壁要素) => ({ 面, 列, 種別: '隔壁', 管轄: null, 末端情報: [false, false], ...隔壁要素 });

      const 末端調整 = (情報) => {
        const 位置 = 情報.位置 || 情報;
        const [[{ 方向: 始端方向, 進捗: 始端進捗 }], [{ 方向: 終端方向, 進捗: 終端進捗 }]] = 位置;
        const 余剰方向数 = Math.floor(始端方向 / 方向数) * 方向数;
        const 加算方向数 = 始端方向 + 始端進捗 > 終端方向 + 終端進捗 ? 方向数 : 0;
        位置.forEach((前後位置, 前後) => {
          前後位置[0].方向 += [0, 加算方向数][前後] - 余剰方向数;
          前後位置[1].方向 += [0, 加算方向数][前後] - 余剰方向数;
        });

        return 情報;
      };

      const 位置一致判定 = (位置1, 位置2) => {
        const 値1 = ((値) => (値 % 方向数 + 方向数) % 方向数)(isNaN(位置1) ? (位置1.方向 + (位置1.進捗 ?? 位置1.位置)) : 位置1);
        const 値2 = ((値) => (値 % 方向数 + 方向数) % 方向数)(isNaN(位置2) ? (位置2.方向 + (位置2.進捗 ?? 位置2.位置)) : 位置2);

        return Math.abs(値1 - 値2) < 0.0001;
      };

      const 通路合成 = (通路1, 通路2, 方向指示 = null) => {
        const ddd = re.length === 1 && false;
        const ccc = (...B) => ddd && console.log(...B);
        const 始端 = 通路1.位置[0][0].方向 + 通路1.位置[0][0].進捗;
        const 終端 = 通路1.位置[1][0].方向 + 通路1.位置[1][0].進捗;
        const 始端隔壁 = 隣接隔壁情報取得('隔壁', 通路2.列, 通路2.位置[0][0].方向, 通路2.位置[0][0].進捗, 0, 0);
        const 終端隔壁 = 隣接隔壁情報取得('隔壁', 通路2.列, 通路2.位置[1][0].方向, 通路2.位置[1][0].進捗, 1, 0);
        const 隔壁始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(始端隔壁[1][0]);
        const 隔壁終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(終端隔壁[1][0]);

        if (通路1 === 通路2) {
          const 拡張通路位置 = [...通路1.位置];
          if (方向指示 === '始端' && 隔壁終端 >= 始端) {
            拡張通路位置[0] = ((終端) => 終端.map(({ 方向, 進捗 }) => ({ 方向: 方向 - 方向数, 進捗 })))(終端隔壁[1]);
            const 拡張通路 = 末端調整({ ...通路1, 位置: 拡張通路位置, 末端情報: [false, false] });

            return [拡張通路, 拡張通路, 末端調整(隔壁生成(通路1.面, 通路1.列, { 位置: 終端隔壁 }))];
          }
          if (方向指示 === '終端' && 隔壁始端 <= 終端) {
            拡張通路位置[1] = ((始端) => 始端.map(({ 方向, 進捗 }) => ({ 方向: 方向 + 方向数, 進捗 })))(始端隔壁[1]);
            const 拡張通路 = 末端調整({ ...通路1, 位置: 拡張通路位置, 末端情報: [false, false] });

            return [拡張通路, 拡張通路, 末端調整(隔壁生成(通路1.面, 通路1.列, { 位置: 始端隔壁.reverse() }))];
          }
        } else {
          try {
            ([-1, 0, 1]).forEach((加算係数) => {
              if (方向指示 === '始端' && 加算係数 * 方向数 + 始端 < 隔壁終端 && 加算係数 * 方向数 + 終端 > 隔壁終端) {
                const 終端位置 = 終端隔壁.map((前後位置) => 前後位置.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })));
                const 合成通路01 = 末端調整({ ...通路2, 位置: [通路2.位置[0], 終端位置[0]] });
                const 合成通路02 = 末端調整({ ...通路1, 位置: [終端位置[1], 通路1.位置[1].map(({ 方向, 進捗 }) => ({ 方向: 方向 + 加算係数 * 方向数, 進捗 }))] });
                throw [合成通路01, 合成通路02, 末端調整(隔壁生成(通路1.面, 通路1.列, { 位置: 終端隔壁 }))];
              }
              if (方向指示 === '終端' && 加算係数 * 方向数 + 終端 > 隔壁始端 && 加算係数 * 方向数 + 始端 < 隔壁始端) {
                const 始端位置 = 始端隔壁.map((前後位置) => 前後位置.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })));
                const 合成通路11 = 末端調整({ ...通路1, 位置: [通路1.位置[0].map(({ 方向, 進捗 }) => ({ 方向: 方向 + 加算係数 * 方向数, 進捗 })), 始端位置[1]] });
                const 合成通路12 = 末端調整({ ...通路2, 位置: [始端位置[0], 通路2.位置[1]] });
                throw [合成通路11, 合成通路12, 末端調整(隔壁生成(通路1.面, 通路1.列, { 位置: 始端隔壁.reverse() }))];
              }
              if (!方向指示 && 加算係数 * 方向数 + 始端 < 隔壁終端 && 加算係数 * 方向数 + 終端 > 隔壁始端) {
                const { 位置: [合成始端, _11], 末端情報: [末端始端, _12] } = 通路2.位置[0][0].方向 + 通路2.位置[0][0].進捗 > 始端 + 加算係数 * 方向数 ? 通路1 : 通路2;
                const { 位置: [_21, 合成終端], 末端情報: [_22, 末端終端] } = 通路2.位置[1][0].方向 + 通路2.位置[1][0].進捗 < 終端 + 加算係数 * 方向数 ? 通路1 : 通路2;
                throw 末端調整({ ...通路1, 位置: [合成始端, 合成終端], 末端情報: [末端始端, 末端終端] });
              }
            });
          } catch (合成結果) {
            if (!合成結果[0] && !合成結果.位置) console.log(合成結果);
            return 合成結果;
          }
        }

        return null;
      };

      const 管轄合成 = (管轄1, 管轄2) => {
        const 上位管轄 = Math.min(管轄群[管轄1], 管轄群[管轄2]);
        const 下位管轄 = Math.max(管轄群[管轄1], 管轄群[管轄2]);
        管轄群.forEach((管轄, 番号) => {
          if (管轄 === 下位管轄) {
            管轄群[番号] = 上位管轄;
          }
        });
      };

      const 拡張可能壁群取得 = (拡張通路) => {
        const 位置変換 = (位置, 前後係数) => 位置.map((群) => 群.map((情報) => ({ ...情報, 方向: 情報.方向 + 方向数 * 前後係数 })));

        if (拡張通路.列 === 0) {
          const { 方向, 進捗 } = 連絡口群[拡張通路.面][0][0][1][0];
          拡張通路 = 末端調整({ ...拡張通路, 位置: [
            [{ 方向, 進捗: 0 }, { 方向, 進捗 }],
            [{ 方向: 方向 + 方向数, 進捗: 0 }, { 方向: 方向 + 方向数, 進捗 }],
          ]});
        }

        return ['内端', '外端'].reduce((拡張可能壁群, 内外, 内外係数) => {
          const ddd = !内外係数 && false;
          const ccc = (...B) => ddd && console.log(...B);
          拡張可能壁群[内外] = [];
          if (!内外係数 && !拡張通路.列) {
            return 拡張可能壁群;
          }
          if (内外係数 && 拡張通路.列 === 通路列数 - 1) {
            return { ...拡張可能壁群, 外端: 拡張可能隣接外端壁群取得(拡張通路) };
          }

          const 連絡口列 = 拡張通路.列 - 1 + 内外係数;
          const 拡張末端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張通路.位置[1][内外係数]);
          const 比較通路群 = ((情報群) => [
            ((情報) => ({ ...情報, 位置: 位置変換(情報.位置, -1) }))(情報群[情報群.length - 1]),
            ...情報群,
            ...情報群.map((情報) => ({ ...情報, 位置: 位置変換(情報.位置, 1) })),
          ])(通路群[拡張通路.面][拡張通路.列 + [-1, 1][内外係数]]);
          const 比較連絡口群 = ((情報群) => [
            位置変換(情報群[情報群.length - 1], -1),
            ...情報群,
            ...情報群.map((情報) => 位置変換(情報, 1)),
          ])(連絡口群[拡張通路.面][拡張通路.列 - 1 + 内外係数]);

          const 拡張末端連絡口取得 = (位置, 前後係数, 末端内外係数) => {
            const 拡張連絡口 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('連絡口', 連絡口列, 方向, 進捗, 1 - 前後係数, 末端内外係数))(位置);
            const 末端隔壁 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('隔壁', 連絡口列, 方向, 進捗, 前後係数, 1))(拡張連絡口[0][0]);
            const 末端隔壁位置 = (({ 方向, 進捗 }) => 方向 + 進捗)(末端隔壁[1][1]);
            const 隣接連絡口 = 比較連絡口群.find(([[値1], [値2]]) => 値1.方向 + 値1.進捗 < 末端隔壁位置 && 値2.方向 + 値2.進捗 > 末端隔壁位置);
            if (隣接連絡口) {
              const 隣接隔壁 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('隔壁', 連絡口列, 方向, 進捗, 1 - 前後係数, 1))(隣接連絡口[1 - 前後係数][0]);

              return (({ 方向, 進捗 }) => 隣接隔壁情報取得('連絡口', 連絡口列, 方向, 進捗, 1 - 前後係数, 0))(隣接隔壁[1][1]);
            }

            return 拡張連絡口;
          };

          try {
            const 初期拡張連絡口 = 拡張末端連絡口取得(拡張通路.位置[0][内外係数], 0, 1 - 内外係数);
            const 末期拡張連絡口 = 拡張末端連絡口取得(拡張通路.位置[1][内外係数], 1, 1 - 内外係数);
            const 初期拡張先通路 = (({ 方向, 進捗 }) => 隣接通路情報取得(拡張通路.列 - 1 + 内外係数, 方向, 進捗, 1, 1 - 内外係数))(初期拡張連絡口[0][内外係数], 'XXXX');
            const 末期終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(末期拡張連絡口[0][内外係数]);
            比較通路群.reduce(([拡張連絡口, 拡張先通路, 仮定拡張連絡口, 拡張先管轄], 比較通路) => {
              const 拡張連絡口終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張連絡口[1][内外係数]);
              if (拡張連絡口終端 > 拡張末端) {
                throw '処理終了';
              }
              const 拡張先始端隔壁 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('隔壁', 比較通路.列, 方向, 進捗, 0, 1 - 内外係数))(比較通路.位置[0][1 - 内外係数]);
              const 拡張先終端隔壁 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('隔壁', 比較通路.列, 方向, 進捗, 1, 1 - 内外係数))(比較通路.位置[1][1 - 内外係数]);
              const 管轄一致 = 管轄群[拡張通路.管轄] === 管轄群[比較通路.管轄];
              const 拡張連絡口始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張連絡口[0][内外係数]);
              const 比較始端 = (({ 方向, 進捗 }) => 方向 + 進捗)((管轄一致 ? 拡張先始端隔壁[1] : 比較通路.位置[0])[1 - 内外係数]);
              const 拡張先終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張先通路[1][1 - 内外係数]);
              if (末期終端 <= 比較始端) {
                if (拡張先終端 <= 末期終端) {
                  拡張可能壁群[内外].push([拡張連絡口[0][1 - 内外係数], 末期拡張連絡口[1][1 - 内外係数]]);
                }
                throw '処理終了';
              }
              const 比較終端 = (({ 方向, 進捗 }) => 方向 + 進捗)((管轄一致 ? 拡張先終端隔壁[1] : 比較通路.位置[1])[1 - 内外係数]);
              if (管轄一致 || 比較通路.種別 === '隔壁') {
                if (拡張連絡口始端 >= 比較終端) {
                  拡張先通路 = (({ 方向, 進捗 }) => 隣接通路情報取得(比較通路.列, 方向, 進捗, 1, 0))(拡張先終端隔壁[1][0]);
                } else {
                  if (拡張先終端 <= 比較始端) {
                    const 比較終端連絡口 = 拡張末端連絡口取得(拡張先始端隔壁[1][1 - 内外係数], 1, 内外係数);
                    const 比較終端連絡口始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(比較終端連絡口[1][内外係数]);
                    if (拡張連絡口始端 <= 比較終端連絡口始端) {
                      拡張可能壁群[内外].push([拡張連絡口[0][1 - 内外係数], 比較終端連絡口[1][1 - 内外係数]]);
                    }
                  }
                  拡張連絡口 = 拡張末端連絡口取得(拡張先終端隔壁[1][1 - 内外係数], 0, 内外係数);
                  拡張先通路 = (({ 方向, 進捗 }) => 隣接通路情報取得(比較通路.列, 方向, 進捗, 1, 1 - 内外係数))(拡張連絡口[0][内外係数]);
                }
              } else {
                if (管轄群[比較通路.管轄] === 拡張先管轄 && (拡張通路.列 || 内外係数)) {
                  const 仮定始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(仮定拡張連絡口[0][内外係数]);
                  const 仮定終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(仮定拡張連絡口[1][内外係数]);
                  const 拡張先始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張先始端隔壁[1][1 - 内外係数]);
                  if (仮定終端 > 拡張先始端) {
                    if (拡張先終端 <= 拡張先始端) {
                      const 仮定始端連絡口 = 拡張末端連絡口取得(拡張先始端隔壁[1][1 - 内外係数], 1, 内外係数);
                      const 仮定始端連絡口始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(仮定始端連絡口[1][内外係数]);
                      if (拡張連絡口始端 <= 仮定始端連絡口始端) {
                        拡張可能壁群[内外].push([拡張連絡口[0][1 - 内外係数], 仮定始端連絡口[1][1 - 内外係数]]);
                      }
                    }
                    if (拡張連絡口始端 < 仮定始端) {
                      拡張連絡口 = 仮定拡張連絡口;
                    }
                  }
                }
                拡張先通路 = (({ 方向, 進捗 }) => 隣接通路情報取得(比較通路.列, 方向, 進捗, 1, 0))(比較通路.位置[0][0]);
                仮定拡張連絡口 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('連絡口', 連絡口列, 方向, 進捗, 1, 内外係数))(拡張先終端隔壁[1][1 - 内外係数]);
              }

              return [拡張連絡口, 拡張先通路, 仮定拡張連絡口, 管轄群[比較通路.管轄]];
            }, [初期拡張連絡口, 初期拡張先通路, null, null]);
          } catch (_) {
            if (typeof _ !== 'string') console.log(_);
            ccc(_);
          }

          return 拡張可能壁群;
        }, {});
      };

      const 拡張可能隣接外端壁群取得 = (拡張通路) => {
        const DDD = 0;
        const ccc = (...B) => DDD && console.log(...B);
        const 位置変換 = (位置, 前後係数) => 位置.map((群) => 群.map((情報) => ({ ...情報, 方向: 情報.方向 + 方向数 * 前後係数 })));

        const 拡張可能壁群 = [];
        const [[_1, { 方向: 始端方向, 進捗: 始端進捗 }], [_2, { 方向: 終端方向, 進捗: 終端進捗 }]] = 拡張通路.位置;
        const 外端通路比率 = 通路厚角度 / 隔壁臨界位置群[通路列数 - 1][0].角度Y;
        const 通路始端臨界 = ((情報) => 情報[1][1].進捗)(隣接通路情報取得(通路列数 - 1, 0, 1, 0, 1));

        Array(終端方向 - 始端方向 + 1).fill(null).forEach((_, 方向係数) => {
          const 方向 = (始端方向 + 方向係数 + 方向数) % 方向数;
          const [接続面, 接続方向] = 面接続情報群[拡張通路.面][(方向 + 方向数) % 方向数];
          const 拡張始端進捗 = 方向係数 > 0 ? 0 : 始端進捗;
          const 拡張終端進捗 = 方向係数 < 終端方向 - 始端方向 ? 1 : 終端進捗;
          const 比較通路群 = [];
          通路群[接続面][通路列数 - 1].forEach((通路) => {
            const 管轄一致 = 通路.種別 === '隔壁' || 管轄群[拡張通路.管轄] !== 管轄群[通路.管轄];
            const 比較位置 = 通路.位置.map(
              ([_, 値1], 前後) => 管轄一致 ? 値1 : (([_1, [_2, 値2]]) => 値2)(隣接隔壁情報取得('隔壁', 通路列数 - 1, 値1.方向, 値1.進捗, 前後, 1))
            );
            const [{ 方向: 方向1, 進捗: 進捗1 }, { 方向: 方向2, 進捗: 進捗2 }] = 比較位置;
            Array(方向2 - 方向1 + 1).fill(null).forEach((_, 比較方向係数) => {
              const 比較方向 = 方向1 + 比較方向係数;
              if (比較方向 % 方向数 === 接続方向) {
                const 比較始端 = 比較方向 === 方向2 ? 1 - 進捗2 : 0;
                const 比較終端 = 比較方向 === 方向1 ? 1 - 進捗1 : 1;
                比較通路群.push({ ...通路, 位置: [比較始端, 比較終端] });
              }
            });
          });

          try {
            const 初期拡張先通路 = 隣接通路情報取得(通路列数 - 1, 方向, 拡張始端進捗, 1, 1);
            比較通路群.sort((A, B) => A.位置[0] - B.位置[0]);
            const [拡張連絡口位置, 拡張先通路] = 比較通路群.reduce(([拡張連絡口位置, 拡張先通路, 仮定拡張連絡口位置, 拡張先管轄], 比較通路) => {
              if (拡張連絡口位置 + 外端通路比率 > 拡張終端進捗) {
                throw '処理終了';
              }
              const 拡張先始端隔壁 = 隣接隔壁情報取得('隔壁', 通路列数 - 1, 方向, 比較通路.位置[0], 0, 1);
              const 拡張先終端隔壁 = 隣接隔壁情報取得('隔壁', 通路列数 - 1, 方向, 比較通路.位置[1], 1, 1);
              const 管轄一致 = 管轄群[拡張通路.管轄] === 管轄群[比較通路.管轄];
              const 拡張先終端 = ((値) => 値.方向 - 方向 + 値.進捗)(拡張先通路[1][1]);
              if (拡張終端進捗 <= 比較通路.位置[0]) {
                if (拡張先通路[1][1].進捗 <= 拡張終端進捗) {
                  拡張可能壁群.push([{ 方向: 方向 % 方向数, 進捗: 拡張連絡口位置 }, { 方向: 方向 % 方向数, 進捗: 拡張終端進捗 - 外端通路比率 }]);
                }
                throw '処理終了';
              }
              if (管轄一致 || 比較通路.種別 === '隔壁') {
                if (拡張連絡口位置 < 比較通路.位置[1]) {
                  if (拡張先終端 <= 比較通路.位置[0]) {
                    if (拡張連絡口位置 <= 比較通路.位置[0] - 外端通路比率) {
                      拡張可能壁群.push([{ 方向: 方向 % 方向数, 進捗: 拡張連絡口位置 }, { 方向: 方向 % 方向数, 進捗: 比較通路.位置[0] - 外端通路比率 }]);
                    }
                  }
                  拡張連絡口位置 = 比較通路.位置[1];
                }
                拡張先通路 = 隣接通路情報取得(通路列数 - 1, 方向, 比較通路.位置[1], 1, 1);
              } else {
                const 拡張先始端隔壁位置 = ((値) => 値.方向 - 方向 + 値.進捗)(拡張先始端隔壁[1][1]);
                const 拡張先終端隔壁位置 = ((値) => 値.方向 - 方向 + 値.進捗)(拡張先終端隔壁[1][1]);
                if (管轄群[比較通路.管轄] === 拡張先管轄) {
                  if (仮定拡張連絡口位置 + 外端通路比率 > 拡張先始端隔壁位置) {
                    if (拡張先終端 <= 拡張先始端隔壁位置) {
                      拡張可能壁群.push([{ 方向: 方向 % 方向数, 進捗: 拡張連絡口位置 }, { 方向: 方向 % 方向数, 進捗: 拡張先始端隔壁位置 - 外端通路比率 }]);
                    }
                    if (拡張連絡口位置 < 仮定拡張連絡口位置) {
                      拡張連絡口位置 = 仮定拡張連絡口位置;
                    }
                  }
                }
                拡張先通路位置 = 比較通路.位置[1];
                仮定拡張連絡口位置 = 拡張先終端隔壁位置;
              }

              return [拡張連絡口位置, 拡張先通路, 仮定拡張連絡口位置, 管轄群[比較通路.管轄]];
            }, [拡張始端進捗, 初期拡張先通路, null, null]);
            const 拡張先終端 = ((値) => 値.方向 - 方向 + 値.進捗)(拡張先通路[1][1]);
            const 拡張連絡口終端位置 = 拡張連絡口位置 + 外端通路比率;
            if (拡張終端進捗 >= 拡張連絡口終端位置) {
              拡張可能壁群.push([{ 方向: 方向 % 方向数, 進捗: 拡張連絡口位置 }, { 方向: 方向 % 方向数, 進捗: 拡張終端進捗 - 外端通路比率 }]);
            }
          } catch (_) {
            if (typeof _ !== 'string') console.log(_);
          }
        });

        return 拡張可能壁群;
      };

      const 列連結 = (面 = 0, 列 = 0) => {
        const 通路 = (() => {
          if (列 === 0 && 中心空間確保) {
            const 通路始端 = [{ 方向: 0, 進捗: 0 }, { 方向: 0, 進捗: 0 }];
            const 通路末端 = [{ 方向: 方向数 - 1, 進捗: 1 }, { 方向: 方向数 - 1, 進捗: 1 }];
            const 通路 = 通路生成(面, 列, { 管轄: 管轄群.length, 位置: [通路始端, 通路末端], 末端情報: [false, false] });
            通路群[面][列].push(通路);
            拡張可能通路群.push(通路);
            管轄群.push(管轄群.length);

            return 通路;
          }
          const 通路情報 = 隣接通路情報取得(列, Math.floor(Math.random() * 方向数), Math.random(), 1, 0);
          const 通路 = 通路生成(面, 列, { 管轄: 管轄群.length, 位置: 通路情報 });
          const 合成通路 = 通路群[面][列][0] && 通路合成(通路群[面][列][0], 通路);
          if (合成通路) {
            通路群[面][列][0].位置 = 合成通路.位置;

            return 通路群[面][列][0];
          }
          通路群[面][列].push(通路);
          拡張可能通路群.push(通路);
          管轄群.push(管轄群.length);

          return 通路;
        })();
        const 連絡口臨界 = 隣接隔壁情報取得('連絡口', 列, 通路.位置[1][1].方向, 通路.位置[1][1].進捗, 0, 0);
        const 連絡口始端1 = 連絡口臨界[1][0].方向 + 連絡口臨界[1][0].進捗;
        const 連絡口始端2 = 通路.位置[0][0].方向 + 通路.位置[0][0].進捗;
        const 連絡口始端 = 連絡口始端1 + (連絡口始端2 - 連絡口始端1) * Math.random();
        const 連絡口 = 隣接隔壁情報取得('連絡口', 列, Math.floor(連絡口始端), 連絡口始端 % 1, 1, 0);
        連絡口群[面][列].push(末端調整(連絡口));
        if (列 === 0 && 中心空間確保) {
          通路.位置[0] = (({ 方向, 進捗 }) => [{ 方向, 進捗 }, { 方向, 進捗 }])(連絡口[0][0]);
          通路.位置[1] = (({ 方向, 進捗 }) => [{ 方向: 方向 + 方向数, 進捗 }, { 方向: 方向 + 方向数, 進捗 }])(連絡口[0][0]);
        }

        const [次列通路始端] = 隣接通路情報取得(列 + 1, 連絡口[0][1].方向, 連絡口[0][1].進捗, 1, 0);
        const [次列通路終端] = 隣接通路情報取得(列 + 1, 連絡口[1][1].方向, 連絡口[1][1].進捗, 0, 0);
        const 次列通路 = 末端調整(通路生成(面, 列 + 1, { 管轄: 管轄群.length - 1, 位置: [次列通路始端, 次列通路終端] }));
        通路群[面][列 + 1].push(次列通路);
        拡張可能通路群.push(次列通路);
        連絡口群[面][列].sort(([[A]], [[B]]) => A.方向 + A.進捗 - B.方向 - B.進捗);
        通路群[面][列].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
        通路群[面][列 + 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);

        if (列 < 通路列数 - 2) {
          列連結(面, 列 + 1);
        } else if (面 < 面数 - 1) {
          列連結(面 + 1, 0);
        }
      };

      const 面連結 = (内部参照情報 = null) => {
        const ddd = 1;
        const ccc = (...B) => ddd && console.log(...B);
        if (!内部参照情報) {
          内部参照情報 = {
            面管轄群: Array(面数).fill(null).map((_, 面) => 面),
            外端通路比率: 通路厚角度 / 隔壁臨界位置群[通路列数 - 1][0].角度Y,
            通路始端臨界: ((情報) => 情報[1][1].進捗)(隣接通路情報取得(通路列数 - 1, 0, 1, 0, 1)),
          };
        }

        const { 面管轄群, 外端通路比率, 通路始端臨界 } = 内部参照情報;
        const [拡張候補面群] = Array(面数).fill(null).reduce(([候補群, 最大接続数], _, 面) => {
          const 接続対象群 = 面接続情報群[面].reduce(
            (情報群, [接続面, 接続方向], 方向) => [...情報群, ...(面管轄群[面] !== 面管轄群[接続面] ? [{ 方向, 接続面, 接続方向 }] : [])],
            []
          );

          return 接続対象群.length > 最大接続数 ? [[{ 面, 接続対象群 }], 接続対象群.length] : 接続対象群.length < 最大接続数 ? [候補群, 最大接続数] : [[...候補群, { 面, 接続対象群 }], 最大接続数];
        }, [[], 1]);
        if (!拡張候補面群.length) {
          return;
        }

        const { 面, 接続対象群 } = 拡張候補面群[Math.floor(Math.random() * 拡張候補面群.length)];
        const { 方向, 接続面, 接続方向 } = 接続対象群[Math.floor(Math.random() * 接続対象群.length)];
        const 新規位置 = 隣接通路情報取得(通路列数 - 1, 方向, Math.random() * 通路始端臨界, 1, 1);
        const 新規通路 = 通路生成(面, 通路列数 - 1, { 管轄: 管轄群.length, 位置: 新規位置 });
        const [当列通路, 新規判定] = 通路群[面][通路列数 - 1].reduce(([新規通路, 新規判定], 既成通路) => {
          if (新規判定) {
            const 合成範囲 = 新規判定 && 通路合成(既成通路, 新規通路);
            if (合成範囲) {
              既成通路.位置 = 合成範囲.位置;

              return [既成通路, false];
            }
          }

          return [新規通路, 新規判定];
        }, [新規通路, true]);
        if (新規判定) {
          通路群[面][通路列数 - 1].push(当列通路);
          拡張可能通路群.push(当列通路);
          管轄群.push(管轄群.length);
        }

        try {
          const 連絡口始端位置 = (([始端, 終端]) => 始端[1].進捗 + (終端[1].進捗 - 始端[1].進捗 - 外端通路比率) * Math.random())(新規位置);
          const [連絡口情報, 接続連絡口情報] = 隣接外端連絡口情報取得(面, 方向, 連絡口始端位置, 1);
          const 接続面通路始端臨界1 = (([_1, [_2, 値]]) => 値.方向 + 値.進捗)(隣接通路情報取得(通路列数 - 1, 接続方向, 接続連絡口情報[1].進捗, 0, 1));
          const 接続面通路始端臨界2 = ((値) => 値.方向 + 値.進捗)(接続連絡口情報[0]);
          const 接続面通路始端 = ((静1, 静2) => 静1 + (静2 - 静1) * Math.random())(接続面通路始端臨界1, 接続面通路始端臨界2);
          const 接続通路方向 = Math.floor(接続面通路始端);
          const 接続通路進捗 = 接続面通路始端 - 接続通路方向;
          const 接続面通路情報 = 隣接通路情報取得(通路列数 - 1, 接続通路方向, 接続通路進捗, 1, 1);
          const 接続面通路 = 末端調整(通路生成(接続面, 通路列数 - 1, { 管轄: 当列通路.管轄, 位置: 接続面通路情報 }));
          const 既成通路 = 通路群[接続面][通路列数 - 1].reduce((既成通路, 通路, 通路番号) => {
            const 接続面合成範囲 = !既成通路 && 通路合成(接続面通路, 通路);
            if (接続面合成範囲) {
              if (管轄群[接続面通路.管轄] === 管轄群[通路.管轄]) {
                throw '接続不要';
              }
              通路.位置 = 接続面合成範囲.位置;
              管轄合成(接続面通路.管轄, 通路.管轄);
              既成通路 = 通路;
            }

            return 既成通路;
          }, null);
          if (!既成通路) {
            通路群[接続面][通路列数 - 1].push(接続面通路);
            拡張可能通路群.push(接続面通路);
          }
          連絡口群[面][通路列数 - 1].push(連絡口情報);
          連絡口群[接続面][通路列数 - 1].push(接続連絡口情報);
        } catch (_) {
          if (_ !== '接続不要') console.log('SS??', _);
        }

        連絡口群[面][通路列数 - 1].sort(([A], [B]) => A.方向 + A.進捗 - B.方向 - B.進捗);
        連絡口群[接続面][通路列数 - 1].sort(([A], [B]) => A.方向 + A.進捗 - B.方向 - B.進捗);
        通路群[面][通路列数 - 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
        通路群[接続面][通路列数 - 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);

        const 上位管轄 = Math.min(面管轄群[面], 面管轄群[接続面]);
        const 下位管轄 = Math.max(面管轄群[面], 面管轄群[接続面]);
        面管轄群.forEach((管轄, 番号) => {
          if (管轄 === 下位管轄) {
            面管轄群[番号] = 上位管轄;
          }
        });

        面連結(内部参照情報);
      };

let re = [];
let iz = [];
let 検査 = false;
const rea = () => {
  const TS = 通路群.map((MTS) => MTS.map((LTS) => LTS.map((T) => [
    { 通路: 0, 隔壁: 1 }[T.種別],
    T.管轄 || 0,
    (T.末端情報[0] ? 1 : 0) + (T.末端情報[1] ? 2 : 0),
    T.位置[0][0].方向 + T.位置[0][0].進捗,
    T.位置[1][0].方向 + T.位置[1][0].進捗,
  ])));
  const LS = 連絡口群.map((MLS) => MLS.map((LLS, LT) => LLS.map(
    (L) => ((A) => A.方向 + A.進捗)(LT < 通路列数 - 1 ? L[0][0] : L[0])
  )));
  拡張可能通路群.forEach((T) => {
    TS[T.面][T.列].find((ATK) => T.位置[0][0].方向 + T.位置[0][0].進捗 === ATK[3]).push(1);
  });

  re[re.length - 1].push(JSON.stringify([TS, LS, 管轄群]));
};
const kt = (AZH) => {
  const [TS, LS, KS] = AZH;
  面数 = TS.length;
  設定();
  TS.forEach((MTS, 面) => {
    通路群[面] = [];
    連絡口群[面] = [];
    MTS.forEach((LTS, 列) => {
      通路群[面][列] = LTS.map((T) => {
        const 種別 = ['通路', '隔壁'][T[0]];
        const 方向1 = Math.floor(T[3]);
        const 進捗1 = T[3] - 方向1;
        const 方向2 = T[0] || Math.floor(T[4]);
        const 進捗2 = T[0] || T[4] - 方向2;
        const 位置 = T[0]
          ? 隣接隔壁情報取得('隔壁', 列, 方向1, 進捗1, 1, 0)
          : 列
            ? [
              (([ZH]) => ZH.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(隣接通路情報取得(列, 方向1, 進捗1, 1, 0)),
              (([ZH]) => ZH.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(隣接通路情報取得(列, 方向2, 進捗2, 0, 0)),
            ]
            : [
              [{ 方向: 方向1, 進捗: 進捗1 }, { 方向: 方向1, 進捗: 進捗1 }],
              [{ 方向: 方向2, 進捗: 進捗2 }, { 方向: 方向2, 進捗: 進捗2 }],
            ];
        const TT = { 面, 列, 種別, 管轄: T[1], 末端情報: [T[2] & 1, T[2] & 2], 位置 };
        if (!T[0] && T[5]) {
          拡張可能通路群.push(TT);          
        }

        return TT;
      });
    });
  });
  LS.forEach((MLS, 面) => {
    MLS.forEach((LLS, 列) => {
      連絡口群[面][列] = LLS.map((L) => {
        const 方向 = Math.floor(L);
        const 進捗 = L - 方向;

        return 列 < 通路列数 - 1
          ? 隣接隔壁情報取得('連絡口', 列, 方向, 進捗, 1, 0)
          : ((ZH) => ZH[0])(隣接外端連絡口情報取得(面, 方向, 進捗, 1))
      });
    });
  });
  KS.forEach((K) => {
    管轄群.push(K);
  });
};

      const 拡張 = (拡張情報) => {
        const [面, 列, 拡張通路, 拡張通路番号, 通路番号, 拡張可能壁群, 拡張方面] = 拡張情報
          ? (() => {
            const 拡張通路 = 拡張情報[0];
            const 拡張方面 = 拡張情報[1];
            const 拡張通路番号 = 拡張可能通路群.findIndex((通路) => 通路 === 拡張通路);
            const 通路番号 = 通路群[拡張通路.面][拡張通路.列].findIndex((通路) => 通路 === 拡張通路);
            const 拡張可能壁群 = ['内端', '外端'].includes(拡張方面) ? 拡張可能壁群取得(拡張通路) : [];

            return [拡張通路.面, 拡張通路.列, 拡張通路, 拡張通路番号, 通路番号, 拡張可能壁群, 拡張方面];
          })()
          : (() => {
            const 拡張通路番号 = Math.floor(拡張可能通路群.length * Math.random());
            const 拡張通路 = 拡張可能通路群[拡張通路番号];
            const { 面, 列, 末端情報: [始端, 終端] } = 拡張通路;
            const 通路番号 = 通路群[面][列].findIndex((通路) => 通路 === 拡張通路);
            const 拡張可能壁群 = 拡張可能壁群取得(拡張通路);
            const 拡張方面候補群 = [
              ...(始端 ? ['始端'] : []),
              ...(終端 ? ['終端'] : []),
              ...(拡張可能壁群.外端.length ? ['外端'] : []),
              ...(拡張可能壁群.内端.length ? ['内端'] : []),
            ];
            const 拡張方面 = 拡張方面候補群.length && 拡張方面候補群[Math.floor(Math.random() * 拡張方面候補群.length)];

            return [面, 列, 拡張通路, 拡張通路番号, 通路番号, 拡張可能壁群, 拡張方面];
          })();

        re.push([`${面}_${列}_${通路番号}_${拡張方面}`]);
        if (['始端', '終端'].includes(拡張方面)) {
          const 比較通路番号 = ((動, 静) => (通路番号 + 動 + 静) % 静)({ 始端: -1, 終端: 1 }[拡張方面], 通路群[面][列].length);
          const 比較通路 = 通路群[面][列][比較通路番号];
          const 拡張前後 = { 始端: 0, 終端: 1 }[拡張方面];
          const { 楕円A, 角度Y } = 隔壁臨界位置群[列][0];
          const 通路幅 = 角度2 / Math.PI / 2 / 通路列数;
          const 通路長 = 楕円A / 線分3 * 角度Y / Math.PI;
          const 拡張幅 = 通路幅 / 通路長 * (2 + 4 * Math.random()) * [-1, 1][拡張前後];
          const 拡張方向 = (({ 方向, 進捗 }) => 方向 + Math.floor(進捗 + 拡張幅))(拡張通路.位置[拡張前後][0]);
          const 拡張進捗 = (({ 方向, 進捗 }) => ((進捗 + 拡張幅) % 1 + 1) % 1)(拡張通路.位置[拡張前後][0]);
          const 拡張結果 = 隣接通路情報取得(拡張通路.列, 拡張方向, 拡張進捗, 1 - 拡張前後, 0);
          拡張通路.位置[拡張前後] = ((位置) => 位置.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(拡張結果[0]);
          const 合成範囲 = 通路合成(末端調整(拡張通路), 比較通路, 拡張方面);
          if (合成範囲) {
            if (管轄群[拡張通路.管轄] === 管轄群[比較通路.管轄]) {
              拡張通路.位置 = 合成範囲[1 - 拡張前後].位置;
              比較通路.位置 = 合成範囲[拡張前後].位置;
              拡張通路.末端情報[拡張前後] = false;
              比較通路.末端情報[1 - 拡張前後] = false;
              通路群[面][列].push(合成範囲[2]);
            } else {
              拡張通路.位置 = [合成範囲[0].位置[0], 合成範囲[1].位置[1]];
              拡張通路.末端情報[0] = 合成範囲[0].末端情報[0];
              拡張通路.末端情報[1] = 合成範囲[1].末端情報[1];
              末端調整(拡張通路);
              拡張可能通路群.splice(拡張可能通路群.findIndex((通路) => 通路 === 比較通路), 1);
              通路群[面][列].splice(比較通路番号, 1);
              管轄合成(拡張通路.管轄, 比較通路.管轄);
            }
          }
          通路群[面][列].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
        } else if (['外端', '内端'].includes(拡張方面)) {
          const 内外係数 = { 内端: 0, 外端: 1 }[拡張方面];
          const 拡張連絡口列 = 列 -1 + 内外係数;
          const 拡張範囲 = 拡張可能壁群[拡張方面][Math.floor(Math.random() * 拡張可能壁群[拡張方面].length)];
          const 拡張先情報 = 列 === 通路列数 - 1 && 内外係数 && 面接続情報群[面][拡張範囲[0].方向];
          const 拡張地点 = (方向数 + (([始端, 終端]) => 始端.方向 + 始端.進捗 + (終端.方向 + 終端.進捗 - 始端.方向 - 始端.進捗) * Math.random())(拡張範囲)) % 方向数;
          const [拡張方向, 拡張進捗] = [Math.floor(拡張地点), 拡張地点 % 1];
          const [隣接通路始端, 隣接通路終端, 拡張通路面, 拡張通路列, 拡張内外係数] = 拡張先情報
            ? (() => {
              const [連絡口情報, 接続連絡口情報] = 隣接外端連絡口情報取得(面, 拡張方向, 拡張進捗, 1);
              連絡口群[面][通路列数 - 1].push(連絡口情報);
              連絡口群[面][通路列数 - 1].sort((A, B) => A[0].方向 + A[0].進捗 - B[0].方向 - B[0].進捗);
              連絡口群[拡張先情報[0]][通路列数 - 1].push(接続連絡口情報);
              連絡口群[拡張先情報[0]][通路列数 - 1].sort((A, B) => A[0].方向 + A[0].進捗 - B[0].方向 - B[0].進捗);
              通路群[面][通路列数 - 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
              通路群[拡張先情報[0]][通路列数 - 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
              const 隣接通路始端 = 隣接通路情報取得(通路列数 - 1, 拡張先情報[1], 接続連絡口情報[0].進捗, 1, 1);
              const 隣接通路終端 = 隣接通路情報取得(通路列数 - 1, 拡張先情報[1], 接続連絡口情報[1].進捗, 0, 1);

              return [隣接通路始端, 隣接通路終端, 拡張先情報[0], 通路列数 - 1, 0];
            })()
            : (() => {
              const 拡張面連絡口 = 隣接隔壁情報取得('連絡口', 拡張連絡口列, 拡張方向, 拡張進捗, 1, 1 - 内外係数);
              連絡口群[面][拡張連絡口列].push(末端調整(拡張面連絡口));
              連絡口群[面][拡張連絡口列].sort(([[A]], [[B]]) => A.方向 + A.進捗 - B.方向 - B.進捗);
              const 隣接通路始端 = 隣接通路情報取得(列 + [-1, 1][内外係数], 拡張面連絡口[0][内外係数].方向, 拡張面連絡口[0][内外係数].進捗, 1, 1 - 内外係数);
              const 隣接通路終端 = 隣接通路情報取得(列 + [-1, 1][内外係数], 拡張面連絡口[1][内外係数].方向, 拡張面連絡口[1][内外係数].進捗, 0, 1 - 内外係数);


              return [隣接通路始端, 隣接通路終端, 面, 列 + [-1, 1][内外係数], 内外係数];
            })();

          const 隣接通路情報 = [隣接通路始端[0], 隣接通路終端[0]];
          const [隣接地点1, 隣接地点2] = ((値1, 値2) => [値1.方向 + 値1.進捗, 値2.方向 + 値2.進捗])(隣接通路始端[0][0], 隣接通路終端[1][0]);
          const 新規通路 = 末端調整(通路生成(拡張通路面, 拡張通路列, { 管轄: 拡張通路.管轄, 位置: 隣接通路情報, 末端情報: [true, true] }));
          try {
            if (!拡張通路列 && 中心空間確保) {
              管轄合成(拡張通路.管轄, 通路群[拡張通路.面][0][0].管轄);
              throw '処理不要';
            }
            通路群[拡張通路面][拡張通路列].filter(({ 種別 }) => 種別 === '通路').forEach((比較通路) => {
              const 合成結果 = 通路合成(新規通路, 比較通路);
              if (合成結果) {
                比較通路.位置 = 合成結果.位置;
                管轄合成(新規通路.管轄, 比較通路.管轄);
                throw '処理終了';
              }
            });
            if (!拡張内外係数) {
              const 通路地点 = 隣接地点1 + (隣接地点2 - 隣接地点1) * Math.random();
              const [通路方向, 通路進捗] = [Math.floor(通路地点), (通路地点 % 1 + 1) % 1];
              const 新規位置 = 隣接通路情報取得(拡張通路列, 通路方向, 通路進捗, 1, 0);
              const 前後係数 = Math.floor(Math.random() * 2);
              Array(通路群[拡張通路面][拡張通路列].length).fill(null).forEach((_, 通路係数) => {
                const 比較通路 = 通路群[拡張通路面][拡張通路列][前後係数 ? 通路係数 : (通路群[拡張通路面][拡張通路列].length - 1 - 通路係数)];
                [0, 1].forEach((前後) => {
                  新規通路.位置[前後] = 新規位置[前後];
                  新規通路.位置[1 - 前後] = 隣接通路情報[1 - 前後];
                  const 合成結果 = 通路合成(新規通路, 比較通路, ['始端', '終端'][前後]);
                  if (合成結果) {
                    if (管轄群[新規通路.管轄] === 管轄群[比較通路.管轄]) {
                      const { 方向, 進捗 } = 合成結果[2].位置[1 - 前後][0];
                      const 新規更新位置 = 隣接通路情報取得(拡張通路列, 方向, 進捗, 1 - 前後, 0);
                      新規通路.位置 = [新規更新位置[前後], 新規更新位置[1 - 前後]];
                      新規通路.末端情報[前後] = false;
                      比較通路.末端情報[1 - 前後] = false;
                      通路群[拡張通路面][拡張通路列].push(末端調整(新規通路));
                      通路群[拡張通路面][拡張通路列].push(合成結果[2]);
                      拡張可能通路群.push(新規通路);
                    } else {
                      比較通路.位置[1 - 前後] = 隣接通路情報[1 - 前後];
                      末端調整(比較通路);
                      管轄合成(新規通路.管轄, 比較通路.管轄);
                    }
                    throw '処理終了';
                  }
                });
              });
              新規通路.位置 = 新規位置;
            }

            通路群[拡張通路面][拡張通路列].push(新規通路);
            拡張可能通路群.push(新規通路);
          } catch (_) {
          }

          通路群[拡張通路面][拡張通路列].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
        } else {
          拡張可能通路群.splice(拡張通路番号, 1);
        }

        rea();
        const reiz = [];
        通路群.forEach((MTS, M) => {
          MTS.forEach((LTS, L) => {
            let ST = 0;
            LTS.forEach(({ 位置 }, B) => {
              const { 方向: H1, 進捗: S1 } = 位置[0];
              const { 方向: H2, 進捗: S2 } = 位置[1];
              if (H1 < 0 || H1 >= 方向数) reiz.push(['T', M, L, B, '方向異常']);
              if (H1 + S1 < ST) reiz.push(['T', M, L, B, '重複']);
              ST = H2 + S2;
            });
          });
        });
        連絡口群.forEach((MLS, M) => {
          MLS.forEach((LLS, L) => {
            let ST = 0;
            LLS.forEach(([Z, G], B) => {
              const { 方向: H1, 進捗: S1 } = L < 通路列数 - 1 ? Z[0] : Z;
              const { 方向: H2, 進捗: S2 } = L < 通路列数 - 1 ? G[0] : G;
              if (H1 < 0 || H1 >= 方向数) reiz.push(['L', M, L, B, '方向異常']);
              if (H1 + S1 < ST) reiz.push(['L', M, L, B, '重複']);
              ST = H2 + S2;
            });
          });
        });
        if (reiz.length) {
          iz.push([re.length - 1, reiz]);
          console.log('中断!!!!!!!!!!!!!!!!!', reiz, 拡張情報, 拡張可能壁群);
        }
        if (拡張可能通路群.length && re.length < 1000 && !検査 && !reiz.length) {
          const 継続拡張方面候補群 = ['始端', '終端'].filter((_, 係数) => !!拡張通路.末端情報[係数]);
          const 継続拡張通路 = 継続拡張方面候補群.length && ['外端', '内端'].includes(拡張方面) && 拡張通路;
          const 継続拡張方面 = 継続拡張通路 && 継続拡張方面候補群[Math.floor(Math.random() * 継続拡張方面候補群.length * 2)] || null;
          拡張(継続拡張方面 && [継続拡張通路, 継続拡張方面]);
        } else {
          console.log(`終了(${re.length - 1})`);
        }
      };

      const 構成 = () => {
        const 隔壁構成 = (面, 列, 内外, 座標1, 座標2) => {
          const [法線始点座標, 法線終点座標] = 列壁座標取得(列, 座標1.方向, 内外, (座標1.位置 + (座標2.位置 || 1)) / 2, 1);
          座標群[`${面}_${列}_${座標1.種別}${座標1.番号}_${内外}O`] = 面座標変換(面, 法線終点座標);
          隔壁平面群[面][`${面}_${列}_${座標1.種別}${座標1.番号}_${内外}X`] = {
            [['H', 'O'][内外]]: 'O',
            [['O', 'H'][内外]]: `${面}_${列}_${座標1.種別}${座標1.番号}_${内外}O`,
            S: [
              `${面}_${列}_${座標1.種別}${座標1.番号}_${内外}U`,
              `${面}_${列}_${座標1.種別}${座標1.番号}_${内外}D`,
              `${面}_${列}_${座標2.種別}${座標2.番号}_${内外}D`,
              `${面}_${列}_${座標2.種別}${座標2.番号}_${内外}U`,
            ],
          };
        };

        const 座標記号取得 = (面, 列, 内外, 座標) => {
          const [座標面, 座標基本方向] = (列 < 通路列数 - 1 || !内外) ? [面, 座標.方向] : 面接続情報群[面][座標.方向];
          const 座標方向 = (列 < 通路列数 - 1 || !内外 || 座標.位置) ? 座標基本方向 : ((座標基本方向 + 1) % 方向数);
          const 座標内外 = (列 < 通路列数 - 1 || !内外) ? 内外 : 0;
          const 座標種別 = (列 < 通路列数 - 1 || !内外) ? 座標.種別 : { LS: 'LE', LE: 'LS', KS: 'KE', KE: 'KS' }[座標.種別] || 座標.種別;

          return `${座標面}_${列}_${座標種別}${座標.番号}_${座標内外}`;
        };

        Array(面数).fill(null).forEach((_, 面) => {
          座標群[`${面}_C`] = { ...面座標変換(面, { X: 0, Y: 0 }), R: 径 - 隔壁高 };
          迷路座標群[面] = Array(通路列数).fill(null).map(() => []);
          Array(通路列数).fill(null).forEach((_列, 列) => {
            Array(列 < 通路列数 - 1 ? 2 : 1).fill(null).forEach((_内外, 内外) => {
              迷路座標群[面][列][内外] = [];
              Array(方向数).fill(null).forEach((_方向, 方向) => {
                Array(解像度).fill(null).forEach((_, 進捗) => {
                  const [基本座標, 法線基準座標] = 列壁座標取得(列, 方向, 内外, 進捗 / 解像度);
                  const 変換座標 = 面座標変換(面, 基本座標);
                  座標群[`${面}_${列}_${方向}.${進捗}_${内外}D`] = { ...変換座標, R: 径 - 隔壁高 };
                  座標群[`${面}_${列}_${方向}.${進捗}_${内外}U`] = { ...変換座標, R: 径 };
                  迷路座標群[面][列][内外].push({ 方向, 位置: 進捗 / 解像度, 種別: '', 番号: `${方向}.${進捗}` });
                });
              });
            });
          });
        });
        Array(面数 + 1).fill(null).forEach((_, 面) => {
          隔壁平面群[面] = {};
          通路平面群[面] = {};
          壁頂平面群[面] = {};
        });
        const 基本座標群 = [];
        Array(通路列数).fill(null).forEach((_1, 列) => {
          基本座標群[列] = Array(列 < 通路列数 - 1 ? 2 : 1).fill(null).map((_2, 内外) => {
            const 角度X1 = 角度2 / 通路列数 * (列 + 1) + 隔壁厚角度 * [-1, 1][内外];
            const 座標Y0 = Math.cos(Math.PI / 方向数);
            const 座標Y1 = Math.sin(角度X1) * 線分3;
            const 座標X1 = Math.pow(1 / (1 / 線分3 / 線分3 + 座標Y0 * 座標Y0 / 線分1 / 線分1 / 座標Y1 / 座標Y1), 1 / 2);
            const 角度Y0 = Math.asin(座標X1 / 線分3);

            return { X: 角度X1, Y: 角度Y0 };
          });
        });
        通路群.forEach((面内通路群, 面) => {
          面内通路群.forEach((列内通路群, 列) => {
            列内通路群.filter(({ 種別 }) => 種別 === '隔壁').forEach(({ 位置 }, 番号) => {
              位置.forEach((前後位置, 前後) => {
                前後位置.forEach(({ X, Y, HX, HY, 方向, 進捗: 隔壁進捗 }, 内外) => {
                  const 種別記号 = ['KS', 'KE'][前後];
                  const 座標 = 面座標変換(面, { X, Y });
                  迷路座標群[面][列 - 1 + 内外][1 - 内外].push({ 方向, 位置: 隔壁進捗, 種別: 種別記号, 番号 });
                  座標群[`${面}_${列 - 1 + 内外}_${種別記号}${番号}_${1 - 内外}U`] = { ...座標, R: 径 };
                  座標群[`${面}_${列 - 1 + 内外}_${種別記号}${番号}_${1 - 内外}D`] = { ...座標, R: 径 - 隔壁高 };
                  if (内外) {
                    座標群[`${面}_${列}_${種別記号}${番号}_LH`] = 面座標変換(面, { X: HX, Y: HY, R: 径 });
                    隔壁平面群[面][`${面}_${列}_${種別記号}${番号}K`] = {
                      H: `${面}_${列}_${種別記号}${番号}_LH`,
                      O: 'O',
                      S: [
                        `${面}_${列 - 1}_${種別記号}${番号}_1U`,
                        `${面}_${列 - 1}_${種別記号}${番号}_1D`,
                        `${面}_${列}_${種別記号}${番号}_0D`,
                        `${面}_${列}_${種別記号}${番号}_0U`,
                      ],
                    };
                  }
                  const 数値1 = 方向 + 隔壁進捗;
                  const 数値2 = ((値) => 値.方向 + 値.進捗)(前後位置[1 - 内外]);
                  if ((数値1 < 数値2 && !前後) || (数値1 > 数値2 && 前後)) {
                    const 対称座標情報 = 隣接隔壁情報取得('隔壁', 列, 方向, 隔壁進捗, 1, 1 - 内外);
                    const 対称座標 = 面座標変換(面, 対称座標情報[0][1 - 内外]);
                    const 対象番号 = `${番号}T${種別記号}`;
                    迷路座標群[面][列 - 内外][内外].push({ 方向, 位置: 隔壁進捗, 種別: `${種別記号}T`, 番号: 対象番号 });
                    座標群[`${面}_${列 - 内外}_${種別記号}T${対象番号}_${内外}U`] = { ...対称座標, R: 径 };
                    座標群[`${面}_${列 - 内外}_${種別記号}T${対象番号}_${内外}D`] = { ...対称座標, R: 径 - 隔壁高 };
                  }
                });
              });
            });
            列内通路群.forEach(({ 種別 }, 番号) => {
              if (種別 === '通路') {
                進捗平面対照群[面][列][0].push({ 平面群 : [], 番号 });
              }
            });
          });
        });
        連絡口群.forEach((面内連絡口群, 面) => {
          面内連絡口群.forEach((列内連絡口群, 列) => {
            const ddd = 面 === 1 && 列 === 4 && false;
            const ccc = (...B) => ddd && console.log(...B);
            列内連絡口群.forEach((連絡口, 番号) => {
              const [接続面, 接続方向] = 列 < 通路列数 - 1 ? [0] : 面接続情報群[面][連絡口[0].方向];
              const 優先接続 = 接続面 > 面;
              連絡口.forEach((末端, 前後) => {
                if (列 < 通路列数 - 1) {
                  末端.forEach(({ X, Y, HX, HY, 方向, 進捗 }, 内外) => {
                    const 座標 = 面座標変換(面, { X, Y });
                    const 種別記号 = ['LS', 'LE'][前後];
                    迷路座標群[面][列][内外].push({ 方向, 位置: 進捗, 種別: 種別記号, 番号 });
                    座標群[`${面}_${列}_${種別記号}${番号}_${内外}U`] = { ...座標, R: 径 };
                    座標群[`${面}_${列}_${種別記号}${番号}_${内外}D`] = { ...座標, R: 径 - 隔壁高 };
                    if (内外) {
                      座標群[`${面}_${列}_${種別記号}${番号}_LH`] = 面座標変換(面, { X: HX, Y: HY, R: 径 });
                      隔壁平面群[面][`${面}_${列}_${種別記号}${番号}K`] = {
                        H: `${面}_${列}_${種別記号}${番号}_LH`,
                        O: 'O',
                        S: [
                          `${面}_${列}_${種別記号}${番号}_0U`,
                          `${面}_${列}_${種別記号}${番号}_0D`,
                          `${面}_${列}_${種別記号}${番号}_1D`,
                          `${面}_${列}_${種別記号}${番号}_1U`,
                        ],
                      };
                    }
                    if (列 || 内外) {
                      const 対称座標情報 = 隣接隔壁情報取得('隔壁', 列 + 内外, 方向, 進捗, 1, 内外);
                      const 対称座標 = 面座標変換(面, 対称座標情報[0][内外]);
                      const 対象番号 = `${番号}T${種別記号}`;
                      迷路座標群[面][列 + [-1, 1][内外]][1 - 内外].push({ 方向, 位置: 進捗, 種別: `${種別記号}T`, 番号: 対象番号 });
                      座標群[`${面}_${列 + [-1, 1][内外]}_${種別記号}T${対象番号}_${1 - 内外}U`] = { ...対称座標, R: 径 };
                      座標群[`${面}_${列 + [-1, 1][内外]}_${種別記号}T${対象番号}_${1 - 内外}D`] = { ...対称座標, R: 径 - 隔壁高 };
                    }
                  });
                } else {
                  const { X, Y, HX, HY, 方向, 進捗 } = 末端;
                  const 座標 = 面座標変換(面, { X, Y });
                  const [種別記号, 接続種別記号] = [['LS', 'LE'], ['LE', 'LS']][前後];
                  迷路座標群[面][列][0].push({ 方向, 位置: 進捗, 種別: 種別記号, 番号 });
                  座標群[`${面}_${列}_${種別記号}${番号}_0U`] = { ...座標, R: 径 };
                  座標群[`${面}_${列}_${種別記号}${番号}_0D`] = { ...座標, R: 径 - 隔壁高 };
                  if (優先接続) {
                    const 接続判別位置 = 1 - (進捗 + 連絡口[1 - 前後].進捗) / 2;
                    const 接続番号 = 連絡口群[接続面][通路列数 - 1].findIndex(([情報1, 情報2]) => 情報1.方向 === 接続方向 && 情報1.進捗 < 接続判別位置 && 情報2.進捗 > 接続判別位置);
                    座標群[`${面}_${列}_${種別記号}${番号}_LH`] = 面座標変換(面, { X: HX, Y: HY, R: 径 });
                    隔壁平面群[面数][`${面}_${列}_${種別記号}${番号}K`] = {
                      H: `${面}_${列}_${種別記号}${番号}_LH`,
                      O: 'O',
                      S: [
                        `${面}_${列}_${種別記号}${番号}_0U`,
                        `${面}_${列}_${種別記号}${番号}_0D`,
                        `${接続面}_${列}_${接続種別記号}${接続番号}_0D`,
                        `${接続面}_${列}_${接続種別記号}${接続番号}_0U`,
                      ],
                    };
                  }
                  const 対称座標情報 = 隣接隔壁情報取得('隔壁', 列, 方向, 進捗, 1, 0);
                  const 対称座標 = 面座標変換(面, 対称座標情報[0][0]);
                  const 対象番号 = `${番号}T${種別記号}`;
                  迷路座標群[面][列 - 1][1].push({ 方向, 位置: 進捗, 種別: `${種別記号}T`, 番号: 対象番号 });
                  座標群[`${面}_${列 - 1}_${種別記号}T${対象番号}_1U`] = { ...対称座標, R: 径 };
                  座標群[`${面}_${列 - 1}_${種別記号}T${対象番号}_1D`] = { ...対称座標, R: 径 - 隔壁高 };
                }
              });
              if (列 < 通路列数 - 1 || 優先接続) {
                const 進捗平面対照 = { 平面群 : [], 範囲: [], 末端情報: [{}, {}], 番号, 方向: 連絡口[0].方向 };
                const 平面情報 = 優先接続 && (([情報1, 情報2]) => {
                  const { 楕円A, 交線B, 角度Y } = 隔壁臨界位置群[列][0];
                  const 中心進捗 = (情報1.進捗 + 情報2.進捗) / 2;
                  const 角度Y0 = 角度Y * (中心進捗 * 2 - 1);
                  const { X: 座標X0, Y: 距離X0 } = 座標取得(角度Y0, 楕円A);
                  const 座標Y0 = Math.sin(角度2) * 距離X0 + 交線B;
                  const 交線A0 = 座標Y0 / 座標X0;
                  const 角度X0 = Math.asin(隔壁厚距離1 / 距離X0);

                  return { A: 交線A0, 角度X: 角度X0, 角度Y: 角度Y0, 距離X: 距離X0, 距離倍率: 距離X0 / 線分3, 方向: 情報1.方向 };
                })(連絡口);
                if (優先接続) {
                  進捗平面対照.平面情報 = 平面情報;
                  進捗平面対照.接続面 = 面接続情報群[面][平面情報.方向][0];
                }
                const { A, 方向 } = 優先接続 ? 平面情報 : 連絡口[0][0];
                進捗平面対照.角度 = Math.atan(1 / A) + Math.PI * 2 / 方向数 * 方向;
                進捗平面対照.末端情報.forEach((内外末端情報, 内外係数) => {
                  const 通路面 = (優先接続 && 内外係数) ? 接続面 : 面;
                  const 通路内外 = (!優先接続 && 内外係数) ? 1 : 0;
                  const 通路列 = 列 + 通路内外;
                  const 通路方向 = (優先接続 && 内外係数) ? 接続方向 : 方向;
                  const 交線A = (優先接続 && 内外係数) ? A * -1 : A;
                  const 末端情報群 = [0, 1].map((位置係数) => {
                    const 臨界位置情報 = 位置係数 ? 隔壁臨界位置群[列][通路内外] : 通路臨界位置群[通路列];
                    const { X: 座標X, Y: 座標Y } = 楕円交線座標取得(臨界位置情報.楕円A, 臨界位置情報.楕円B, 臨界位置情報.交線B, 交線A, 0);
                    const 角度Y = Math.asin(座標X / 臨界位置情報.楕円A);

                    return Math.abs(角度Y) <= 臨界位置情報.角度Y
                      ? (() => {
                        const 距離Z = Math.pow(座標X * 座標X + 座標Y * 座標Y, 1 / 2);
                        const 角度X = Math.asin(距離Z / 線分3);
                        const 進捗 = (角度Y + 臨界位置情報.角度Y) / 臨界位置情報.角度Y / 2;

                        return { 角度X, 角度Y, 方向: 通路方向, 進捗 };
                      })()
                      : 隣接方向座標取得(臨界位置情報, 通路方向, 交線A, 0, 角度Y > 0 ? 1 : -1);
                  });
                  内外末端情報.位置 = (末端情報群[0].方向 % 方向数) + 末端情報群[0].進捗;
                  内外末端情報.平面群 = [];
                  内外係数 ? 進捗平面対照.範囲.push(末端情報群[1].角度X) : 進捗平面対照.範囲.unshift(末端情報群[1].角度X);
                  内外係数 ? 進捗平面対照.範囲.push(末端情報群[0].角度X) : 進捗平面対照.範囲.unshift(末端情報群[0].角度X);
                });
                進捗平面対照群[面][列][1].push(進捗平面対照);
              }
            });
          });
        });

        迷路座標群.forEach((面内迷路座標群, 面) => {
          面内迷路座標群.forEach((列内迷路座標群, 列) => {
            if (列 === 通路列数 - 1) {
              列内迷路座標群[1] = [];
              Array(方向数).fill(null).forEach((_, 方向) => {
                const [接続面, 接続方向] = 面接続情報群[面][方向];
                迷路座標群[接続面][列][0].forEach((座標) => {
                  if (座標.方向 === 接続方向) {
                    列内迷路座標群[1].push({ ...座標, 方向, 位置: 1 - 座標.位置, 種別: { LS: 'LE', LE: 'LS', KS: 'KE', KE: 'KS' }[座標.種別] || 座標.種別 });
                  } else if ((座標.方向 - 1 + 方向数) % 方向数 === 接続方向 && 座標.位置 === 0) {
                    列内迷路座標群[1].push({ ...座標, 方向, 位置: 0, 種別: { LS: 'LE', LE: 'LS', KS: 'KE', KE: 'KS' }[座標.種別] || 座標.種別 });
                  }
                });
              });
              列内迷路座標群[1].sort((A, B) => A.方向 + A.位置 - B.方向 - B.位置);
            }
            列内迷路座標群.forEach((内外座標群, 内外) => {
              const ddd = 面 === 10 && 列 === 通路列数 - 1 && !内外 && false;
              const ccc = (...B) => ddd && console.log(...B);
              const 接続考慮 = 列 === 通路列数 - 1 && 内外;
              const 前列 = 列 - 1 + 内外;
              const 前列座標群 = 面内迷路座標群[前列]?.[1 - 内外] || [];
              const 当列座標群 = 内外座標群.sort((A, B) => A.方向 % 方向数 + A.位置 - B.方向 % 方向数 - B.位置);
              const 前列冒頭番号 = Math.max(0, 前列座標群.findIndex(({ 種別, 番号 }) => 種別 === ['KE', 'LE'][内外] && (接続考慮 || 番号 === 0)));
              const 当列冒頭番号 = Math.max(0, 当列座標群.findIndex(({ 種別, 番号, 方向 }) => 種別 === ['KE', 'LE'][内外] && (接続考慮 ? 方向 === 前列座標群[前列冒頭番号].方向 : 番号 === 0)));
              const 当列情報 = { 段階: ['D', 'U'][内外], 進捗: 0 };
              const 前列情報 = { 段階: ['D', 'U'][内外], 進捗: 0 };
              const 通路情報 = { 段階: ['D', 'U'][内外], 通路番号: 0, 連絡口番号: 0, 内外連絡口番号: [null, null] };
              const 情報更新 = (座標, 旧座標, 情報, 隔壁内外, 進捗係数) => {
                if (内外 && 情報.段階 === 'U') {
                  隔壁構成(面, 列, 隔壁内外, 旧座標, 座標);
                }
                if (進捗係数 !== false) {
                  const 接続判定 = 列 === 通路列数 - 1 && 隔壁内外 && ['LS', 'LE'].includes(旧座標.種別);
                  const [接続面, 接続方向] = 列 < 通路列数 - 1 ? [面] : 面接続情報群[面][(座標.方向 + 方向数) % 方向数];
                  if (内外 && 旧座標.種別 === 'LS' && 面 <= 接続面) {
                    通路情報.連絡口番号 = 連絡口群[面][列].findIndex(([内外情報]) => 位置一致判定(内外情報[隔壁内外] ?? 内外情報, 旧座標));
                  }
                  if (内外) {
                    if (面 <= 接続面) {
                      const 進捗平面対照 = 進捗平面対照群[面][列][1].find(({ 番号 }) => 番号 === 通路情報.連絡口番号);
                      進捗平面対照.平面群.push(`${面}_${列}_1_${進捗係数}`);
                    }
                  } else {
                    if (旧座標.種別 === 'KE') {
                      const 通路番号 = 通路群[面][列].findIndex((通路) => 位置一致判定(通路.位置[0][隔壁内外], 旧座標));
                      通路情報.通路番号 = 進捗平面対照群[面][列][0].findIndex(({ 番号 }) => 番号 === 通路番号);
                    } else if (旧座標.種別 === 'LS') {
                      const 連絡口面 = 隔壁内外 ? Math.min(面, 接続面) : 面;
                      const 連絡口位置 = 隔壁内外 && 面 > 接続面 ? 接続方向 + 1 - 旧座標.位置 : 旧座標;
                      const 連絡口前後 = 隔壁内外 && 面 > 接続面 ? 1 : 0;
                      const 連絡口番号 = 連絡口群[連絡口面][列 - 1 + 隔壁内外].findIndex((位置) => 位置一致判定(位置[連絡口前後][1 - 隔壁内外] || 位置[連絡口前後], 連絡口位置));
                      通路情報.内外連絡口番号[隔壁内外] = 進捗平面対照群[連絡口面][列 - 1 + 隔壁内外][1].findIndex(({ 番号 }) => 番号 === 連絡口番号);
                    } else if (旧座標.種別 === 'LST' && 列 > 0) {
                      const 連絡口面 = 隔壁内外 ? 面 : Math.min(面, 接続面);
                      const 連絡口位置 = 隔壁内外 || 面 <= 接続面 ? 旧座標 : (接続方向 + 1 - 旧座標.位置);
                      const 連絡口前後 = 隔壁内外 || 面 <= 接続面 ? 0 : 1;
                      const 連絡口番号 = 連絡口群[連絡口面][列 - 隔壁内外].findIndex((位置) => 位置一致判定(位置[連絡口前後][隔壁内外] || 位置[連絡口前後], 連絡口位置));
                      通路情報.内外連絡口番号[1 - 隔壁内外] = 進捗平面対照群[連絡口面][列 - 隔壁内外][1].findIndex(({ 番号 }) => 番号 === 連絡口番号);
                    } else if (旧座標.種別 === 'LE') {
                      通路情報.内外連絡口番号[隔壁内外] = null;
                    } else if (旧座標.種別 === 'LET') {
                      通路情報.内外連絡口番号[1 - 隔壁内外] = null;
                    }
                    const 対照平面群 = 進捗平面対照群[面][列][0][通路情報.通路番号].平面群;
                    if (!対照平面群.length) {
                      対照平面群.push(旧座標.方向 + 旧座標.位置);
                    }
                    const 座標位置 = ((位置) => 位置 + (位置 < 対照平面群[対照平面群.length - 1] ? 方向数 : 0))(座標.方向 + 座標.位置);
                    対照平面群.push(`${面}_${列}_0_${進捗係数}`, 座標位置);
                    if (通路情報.内外連絡口番号[隔壁内外] !== null) {
                      const 連絡口面 = 隔壁内外 ? Math.min(面, 接続面) : 面;
                      const 末端内外係数 = 隔壁内外 && 面 > 接続面 ? 1 : (1 - 隔壁内外);
                      進捗平面対照群[連絡口面][列 - 1 + 隔壁内外][1][通路情報.内外連絡口番号[隔壁内外]].末端情報[末端内外係数].平面群.push(`${面}_${列}_0_${進捗係数}`);
                    }
                    if (通路情報.内外連絡口番号[1 - 隔壁内外] !== null) {
                      const 連絡口面 = 隔壁内外 ? 面 : Math.min(面, 接続面);
                      const 末端内外係数 = 隔壁内外 || 面 <= 接続面 ? 隔壁内外 : 0;
                      進捗平面対照群[連絡口面][列 - 隔壁内外][1][通路情報.内外連絡口番号[1 - 隔壁内外]].末端情報[末端内外係数].平面群.push(`${面}_${列}_0_${進捗係数}`);
                    }
                    if (隔壁内外 && 座標.種別 === 'KS') {
                      通路情報.内外連絡口番号[隔壁内外] = null;
                    }
                  }
                }
                情報.進捗 ++;
                情報.段階 = [{ KS: 'U', KE: 'D' }, { LS: 'D', LE: 'U' }][内外][座標.種別] || 情報.段階;
              };
              const 座標一致判定 = (座標1, 座標2) =>
                (Math.floor(座標1.方向 % 方向数) + 座標1.位置 === Math.floor(座標2.方向 % 方向数) + 座標2.位置) ||
                (!座標1.種別 && !座標2.種別 && 座標1.番号 === 座標2.番号);
              try {
                Array(当列座標群.length + 前列座標群.length).fill(null).forEach((_, 進捗係数) => {
                  if (当列情報.進捗 >= 当列座標群.length && 前列情報.進捗 >= 前列座標群.length) {
                    throw '中断';
                  }
                  const 当列座標 = 当列座標群[(当列冒頭番号 + 当列情報.進捗 + 1) % 当列座標群.length];
                  const 当列旧座標 = 当列座標群[(当列冒頭番号 + 当列情報.進捗) % 当列座標群.length];
                  const 当列記号 = 座標記号取得(面, 列, 内外, 当列座標);
                  const [接続面, 接続方向] = 接続考慮 ? 面接続情報群[面][当列座標.方向] : [面, 当列座標.方向];
                  if (!列 && !内外) {
                    通路平面群[面][`${面}_0_0_${進捗係数}`] = [`${面}_C`, `${面}_${列}_${当列旧座標.種別}${当列旧座標.番号}_0D`, `${当列記号}D`];
                    情報更新(当列座標, 当列旧座標, 当列情報, 1, 進捗係数);
                    if (面 === 0) {
                      通路平面群[面][`${面}_0_0_${進捗係数}`].通過 = 8;
                    } else if (面 === 目的面) {
                      通路平面群[面][`${面}_0_0_${進捗係数}`].通過 = 16;
                    }

                    return;
                  }
                  const 前列座標 = 前列座標群[(前列冒頭番号 + 前列情報.進捗 + 1) % 前列座標群.length];
                  const 当列位置 = 当列座標.方向 % 方向数 + (当列冒頭番号 + 当列情報.進捗 + 1 >= 当列座標群.length && (当列座標群[当列冒頭番号].方向 >= 前列座標群[前列冒頭番号].方向 || 前列座標群[前列冒頭番号].方向 < 方向数) ? 方向数 : 0) + 当列座標.位置;
                  const 前列位置 = 前列座標.方向 % 方向数 + (前列冒頭番号 + 前列情報.進捗 + 1 >= 前列座標群.length && (前列座標群[前列冒頭番号].方向 >= 当列座標群[当列冒頭番号].方向 || 当列座標群[当列冒頭番号].方向 < 方向数) ? 方向数 : 0) + 前列座標.位置;
                  const 前列旧座標 = 前列座標群[(前列冒頭番号 + 前列情報.進捗) % 前列座標群.length];
                  const 前列記号 = 座標記号取得(面, 前列, 1 - 内外, 前列座標);
                  if (当列旧座標.位置 === 1) {
                    const [面1, 方向1] = 面接続情報群[面][当列旧座標.方向];
                    const [面2, 方向2] = 面接続情報群[面1][(方向1 + 1) % 方向数];
                    const [面3, 方向3] = 面接続情報群[面][当列座標.方向];
                    const 方向4 = (方向3 + 1) % 方向数;
                    const 集中面情報群 = [[面3, 方向4], [面, 当列座標.方向], [面1, 方向1]];
                    if ([8, 20].includes(面数)) {
                      const [面5, 方向5] = 面接続情報群[面3][方向4];
                      const 方向6 = (方向5 + 1) % 方向数;
                      集中面情報群.unshift([面5, 方向6]);
                      if (面数 === 20) {
                        const [面7, 方向7] = 面接続情報群[面5][方向6];
                        const 方向8 = (方向7 + 1) % 方向数;
                        集中面情報群.unshift([面7, 方向8]);
                      }
                    }
                    const 最優先面 = 集中面情報群.reduce((面1, [面2]) => Math.min(面1, 面2), 面数);
                    if (面 === 最優先面) {
                      壁頂平面群[面][`${当列記号}TT`] = 集中面情報群.map(([面1, 方向1]) => `${面1}_${列}_${方向1}.0_0U`);
                    }
                    当列情報.進捗 ++;

                    return;
                  }
                  const 平面群 = 接続面 >= 面 && (({ D: 通路平面群, U: 壁頂平面群 })[通路情報.段階][面][`${面}_${列}_${内外}_${進捗係数}`] = [
                    `${座標記号取得(面, 列, 内外, 当列旧座標)}${通路情報.段階}`,
                    `${座標記号取得(面, 前列, 1 - 内外, 前列旧座標)}${通路情報.段階}`,
                  ]);
                  if (当列情報.段階 === 前列情報.段階 && 座標一致判定(当列旧座標, 前列旧座標) && 座標一致判定(当列座標, 前列座標)) {
                    平面群 && 平面群.push(`${前列記号}${通路情報.段階}`);
                    平面群 && 平面群.push(`${当列記号}${通路情報.段階}`);
                    情報更新(前列座標, 前列旧座標, 前列情報, 0, false);
                    情報更新(当列座標, 当列旧座標, 当列情報, 1, 通路情報.段階 === 'D' && 進捗係数);
                  } else if (前列情報.段階 !== 通路情報.段階) {
                    平面群 && 平面群.push(`${当列記号}${通路情報.段階}`);
                    情報更新(当列座標, 当列旧座標, 当列情報, 1, 通路情報.段階 === 'D' && 進捗係数);
                  } else if (当列情報.段階 !== 通路情報.段階) {
                    平面群 && 平面群.push(`${前列記号}${前列情報.段階}`);
                    情報更新(前列座標, 前列旧座標, 前列情報, 0, 通路情報.段階 === 'D' && 進捗係数);
                  } else {
                    const [座標, 旧座標, 記号, 情報, 隔壁内外] = 当列位置 < 前列位置
                      ? [当列座標, 当列旧座標, 当列記号, 当列情報, 1]
                      : [前列座標, 前列旧座標, 前列記号, 前列情報, 0];
                    平面群 && 平面群.push(`${記号}${通路情報.段階}`);
                    情報更新(座標, 旧座標, 情報, 隔壁内外, 通路情報.段階 === 'D' && 進捗係数);
                  }
                  if (当列情報.段階 === 前列情報.段階) {
                    通路情報.番号 += (当列情報.段階 === 'D' && 通路情報.段階 !== 当列情報.段階) ? 1 : 0;
                    通路情報.段階 = 当列情報.段階;
                  }
                });
              } catch (E) {
                if (E !== '中断') console.log(E);
              }
              進捗平面対照群[面][列][0].sort((A, B) => A.平面群[1] - B.平面群[1]);
              進捗平面対照群[面][列][1].sort((A, B) => A.平面群[1] - B.平面群[1]);
            });
          });
        });
        進捗平面対照群.forEach((面内対照群, 面) => {
          面内対照群.forEach((列内対照群, 列) => {
            列内対照群[1].forEach((対照情報) => {
              [0, 1].forEach((内外係数) => {
                const 通路面 = 列 < 通路列数 - 1 || !内外係数 ? 面 : 対照情報.接続面;
                const 通路列 = 列 < 通路列数 - 1 ? (列 + 内外係数) : 列;
                try {
                  進捗平面対照群[通路面][通路列][0].forEach(({ 平面群 }, 番号) => {
                    const 位置1 = 平面群[0];
                    const 位置2 = 平面群[平面群.length - 1];
                    [-1, 0, 1].forEach((方向係数) => {
                      const 調整進捗 = 対照情報.末端情報[内外係数].位置 + 方向数 * 方向係数;
                      if (調整進捗 > 位置1 && 調整進捗 < 位置2) {
                        throw ([番号, 調整進捗]);
                      }
                    });
                  });
                } catch (対照通路情報) {
                  if (!Array.isArray(対照通路情報)) console.log(対照通路情報);
                  対照情報.末端情報[内外係数].番号 = 対照通路情報[0];
                  対照情報.末端情報[内外係数].位置 = 対照通路情報[1];
                }
              });
            });
          });
        });
      };

      const calculateRelativeVector = (basePos, meshPos) => {
        const { X: LRZ, Y: LLZ } = 座標取得(光源.X, 1);
        const { X: LLX, Y: LLY } = 座標取得(光源.Y, LRZ);
        const { L: LRX, T: LTX } = 角度取得(LLY, LLZ);
        const { L: LRY, T: LTY } = 角度取得(LLX, LLZ);
        const { L: MRX, T: MTX } = 角度取得(meshPos.Y - basePos.Y, meshPos.Z - basePos.Z);
        const { X: MLY, Y: MLZ } = 座標取得(MTX + LTX, MRX);
        const { L: MRY, T: MTY } = 角度取得(meshPos.X - basePos.X, MLZ);
        const { X: NLX, Y: NLZ } = 座標取得(MTY + LTY, MRY);
        const MRZ = Math.pow(NLX * NLX + MLY * MLY, 1 / 2);
        const { L: MRO2, T: MTO2 } = 角度取得(MRZ, NLZ);

        return Math.abs(MTO2) % (Math.PI * 2);
      };

      const calculateColor = (C, V) => {
        const CD = C.map((C0, i) => {
          const C1 = V < 1 / 2
            ? Math.round(C0 + (255 - C0) * (1 - V * 2))
            : Math.round(C0 * (1 / 2 + 1 - V));

          return (C1 < 16 ? '0' : '') + C1.toString(16);
        });

        return `#${CD.join('')}`;
      };

      const move = () => {
        基本角度R = 合成角度R;
        基本角度V = 合成角度V;
        基本角度L = 合成角度L;
        移動角度R = 0;
        移動角度L = 0;

        if (moveType === 'vector') {
          const directionX = (latestMoveX > latestBaseX) ? -1 : 1;
          const directionY = (latestMoveY > latestBaseY) ? 1 : -1;
          const absX = Math.min(Math.abs(latestMoveX - latestBaseX), 30);
          const absY = Math.min(Math.abs(latestMoveY - latestBaseY), 30);
          const thetaDiffX = (absX / 200) * directionX;
          const thetaDiffY = (absY / 200) * directionY;
          移動角度V = (({ T }) => T)(角度取得(thetaDiffX * -1, thetaDiffY));
          相対角度L = Math.pow(thetaDiffX * thetaDiffX + thetaDiffY * thetaDiffY, 1 / 2);
          相対角度R = 0;
        } else {
          const { T: TD0 } = 角度取得(中心 - latestBaseX, 中心 - latestBaseY);
          const { T: TD1 } = 角度取得(中心 - latestMoveX, 中心 - latestMoveY);
          const directionT = (TD1 > TD0) ? 1 : -1;
          const absT = Math.min(Math.abs(TD1 - TD0), 0.2);
          相対角度L = 0;
          相対角度R = absT * directionT;
        }

        latestBaseX = latestMoveX;
        latestBaseY = latestMoveY;
      };

      const slide = () => {
        if (相対角度L > 0) {
          移動角度L += 相対角度L;
          const TA0 = 移動角度V - Math.PI / 2;
          const { X: RY0, Y: LZ0 } = 座標取得(基本角度L, 1);
          const { X: LX1, Y: LY1 } = 座標取得(基本角度V - TA0, RY0);
          const { L: RX1, T: TX1 } = 角度取得(LX1 * -1, LZ0);
          const { X: LX2, Y: LZ2 } = 座標取得((移動角度L + TX1) * -1, RX1);
          const { L: RY2, T: TV2 } = 角度取得(LX2 * -1, LY1 * -1);
          const { T: TL2 } = 角度取得(RY2 * -1, LZ2);

          合成角度R = 基本角度R;
          合成角度V = TV2 + TA0;
          合成角度L = TL2;

          if (LY1 !== 0) {
            const { X: LX3, Y: LZ3 } = 座標取得(TX1 * -1, RX1);
            const { L: RY3, T: TV3 } = 角度取得(LX3 * -1, LY1 * -1);
            const { T: TL3 } = 角度取得(RY3 * -1, LZ3);
            const { X: L0, Y: L1 } = 座標取得(TV3, 1);
            const L2 = Math.cos(TL3) * L1;
            const { T: T0 } = 角度取得(L2 * -1, L0 * -1);
            const { X: L3, Y: L4 } = 座標取得(TV2, 1);
            const L5 = Math.cos(TL2) * L4;
            const { T: T2 } = 角度取得(L5 * -1, L3 * -1);

            合成角度R += T2 - T0 + TV2 - TV3;
          }
        } else if (相対角度R !== 0) {
          移動角度R += 相対角度R;
          合成角度R = 基本角度R + 移動角度R;
          合成角度V = 基本角度V + 移動角度R;
        }
      };

      const resetAxis = (x, y) => {
        latestMoveX = x;
        latestMoveY = y;
        latestBaseX = x;
        latestBaseY = y;

        const 相対座標X = 中心 - latestBaseX;
        const 相対座標Y = 中心 - latestBaseY;
        const 相対座標R = Math.pow(相対座標X * 相対座標X + 相対座標Y * 相対座標Y, 1 / 2);

        moveType = 相対座標R <= 軸走査限界半径 ? 'vector' : 'rotate';
      };

      const setAxis = (x, y) => {
        latestMoveX = x;
        latestMoveY = y;
      };

      const 再現 = () => {
        radarCoordinates = { O: { R: 0, X: 0, Y: 0 }, ...座標群 };
        surfaceGroup.road = [...通路平面群];
        surfaceGroup.top = [...壁頂平面群];
        surfaceGroup.wall = 隔壁平面群.map((平面情報群) => {
          const 平面群 = {};
          Object.keys(平面情報群).forEach((記号) => {
            平面群[記号] = 平面情報群[記号].S;
          });

          return 平面群;
        });
      };

      const 座標計算 = ({ X, Y, R }) => {
        const { X: RY0, Y: LZ0 } = 座標取得(X, 1);
        const { X: LX1, Y: LY1 } = 座標取得(Y + 合成角度R - 軸角度, RY0);
        const { L: RX1, T: TX1 } = 角度取得(LX1, LZ0);
        const { X: LX2, Y: LZ2 } = 座標取得(TX1 - 合成角度L, RX1);
        const { L: RY2, T: TY2 } = (({ L, T }) => ({ L: L / (distanceSwitch ? (焦点距離 - LZ2) * 視角拡大率 : 1), T }))(角度取得(LX2, LY1));
        const { X: LX3, Y: LY3 } = 座標取得(TY2 + 軸角度, RY2);

        return { X: LX3 * R, Y: LY3 * R, Z: LZ2 * R };
      };

      const 方向転換 = () => {
        焦点距離 = distanceSwitch && 1 / Math.sin(画角度);
        軸角度 = (合成角度V - Math.PI / 2);
        一時座標群 = {};
        一時平面群 = [];
        現在座標.forEach(({ 番号, 座標 }) => {
          一時座標群[番号] = 座標計算(座標);
          一時平面群.push([番号, 0, null, 一時座標群[番号].Z]);
        });

        const 基準座標群 = Array(面数).fill(null).map((_, 面) => 座標計算(座標群[`${面}_C`]));

        Object.keys(surfaceGroup).forEach((partType) => {
          surfaceGroup[partType].forEach((平面群, 面) => {
            if (面 === 面数 || 基準座標群[面].Z >= 基準Z) {
              Object.keys(平面群).forEach((surfaceCode) => {
                let zIndex = 0;
                let zIndexMax = 0;

                平面群[surfaceCode].forEach((posCode) => {
                  if (!一時座標群[posCode]) {
if (!radarCoordinates[posCode]) {
// console.log(`${surfaceCode} >> ${posCode}`);
一時座標群[posCode] = { X: 0, Y: 0, Z: 0 };
return;
}
                    一時座標群[posCode] = posCode === 'O' ? { X: 0, Y: 0, Z: 0 } : 座標計算(radarCoordinates[posCode]);
                  }

                  zIndex += 一時座標群[posCode].Z;
                  zIndexMax = Math.max(zIndexMax, 一時座標群[posCode].Z);
                });

                if (partType === 'wall') {
                  const { O, H } = 隔壁平面群[面][surfaceCode];
                  一時座標群[O] = 座標計算(radarCoordinates[O]);
                  一時座標群[H] = 座標計算(radarCoordinates[H]);
                }

                if (zIndexMax >= 0) {
                  一時平面群.push([partType, 面, surfaceCode, zIndex / 平面群[surfaceCode].length]);
                }
              });
            }
          });
        });

        一時平面群.sort(([_1, _2, _3, A], [_4, _5, _6, B]) => A - B);
      };

      const 描画 = () => {
        描画制御.setTransform(1, 0, 0, 1, 0, 0);
        描画制御.clearRect(0, 0, 画面幅, 画面幅);
        一時平面群.forEach(([partType, m, code, zIndex]) => {
          const targetSurface = !['C', 'Z', 'S', 'Y'].includes(partType) && surfaceGroup[partType][m][code];
          const [basePos, meshPos] = (() => {
            if (partType === 'wall') {
              const { O, H } = 隔壁平面群[m][code];

              return [一時座標群[H], 一時座標群[O]];
            }
            if (['C', 'Z', 'S', 'Y'].includes(partType)) {
              return [null, null];
            }
            const 座標総合 = targetSurface.reduce(({ X, Y, Z }, posCode) => ({
              X: X + 一時座標群[posCode].X,
              Y: Y + 一時座標群[posCode].Y,
              Z: Z + 一時座標群[posCode].Z,
            }), { X: 0, Y: 0, Z: 0 });

            return [{ X: 0, Y: 0, Z: 0 }, 座標総合];
          })();
          if (['C', 'Z', 'S', 'Y'].includes(partType)) {
          //   const { X, Y } = 一時座標群.C;
          //   描画制御.beginPath();
          //   描画制御.fillStyle = '#ff000088';
          //   描画制御.arc(中心 + X, 中心 + Y, 10, 0, Math.PI * 2);
          //   描画制御.fill();

            return;
          }
          if (meshPos.Z >= basePos.Z) {
            描画制御.beginPath();
            targetSurface.forEach((posCode, j) => {
              const { X, Y, Z } = 一時座標群[posCode];
              if (j === 0) {
                描画制御.moveTo(中心 + X, 中心 + Y);
              } else {
                描画制御.lineTo(中心 + X, 中心 + Y);
              }
            });
            描画制御.closePath();
            const V = calculateRelativeVector(basePos, meshPos);
            const FC = partType === 'wall'
              ? [100, 128, 156]
              : partType === 'road'
                ? ((値) => {
                  switch (true) {
                    case (値 & 16) === 16:
                      return [0, 0, 255];
                    case 値 > 0:
                      return [255, 32, 192];
                    default:
                      return [224, 224, 236];
                  }
                })(通路平面群[m][code].通過)
                : [255, 255, 255];
// const FC = partType === 'wall' ? [112, 112, 156] : partType === 'road' ? [200, 200, 236] : [
// [255, 100, 200],
// [100, 255, 200],
// [140, 140, 255],
// [255, 150, 150],
// [140, 200, 100],
// [100, 160, 180],
// [220, 100, 150],
// [100, 220, 120],
// [200, 100, 100],
// [170, 170, 170],
// [180, 100, 220],
// [255, 160, 152],
// [255, 224, 128],
// [156, 200, 160],
// [224, 128, 200],
// [112, 240, 128],
// [192, 160, 172],
// [120, 240, 160],
// [184, 160, 128],
// [140, 160, 255],
// ][m];
            描画制御.fillStyle = calculateColor(FC, V / Math.PI);
            描画制御.strokeStyle = calculateColor(FC, V / Math.PI);
            // 描画制御.strokeStyle = '#88f';
            描画制御.fill();
            描画制御.stroke();
          }
        });
        const { X, Y } = 一時座標群.C;
        描画制御.beginPath();
        描画制御.arc(中心 + X, 中心 + Y, 10, 0, Math.PI * 2);
        描画制御.strokeStyle = '#ff22aa88';
        描画制御.lineWidth = 1;
        描画制御.stroke();
      };

      const 再生 = () => {
        if (探索指示[0] || 探索指示[1]) {
          探索();
          進行();
        } else {
          if (転回信号) {
            move();
          }
          slide();
        }
        方向転換();
        描画();
        if (animationSwitch) {
          if (animation) {
            clearTimeout(animation);
          }
          animation = setTimeout(再生, 50);
        }
      };

      const 探索 = () => {
        const { X, Y } = 一時座標群.C;
        const 指示角度 = Math.PI / 4 * (
          探索指示[0] > 0 ?
            探索指示[1] > 0 ? 1 : 探索指示[1] < 0 ? 3 : 2 :
          探索指示[0] < 0 ?
            探索指示[1] > 0 ? -1 : 探索指示[1] < 0 ? -3 : -2 :
          探索指示[1] > 0 ? 0 : 4
        );
        const [操作] = ['Z', 'S', 'Y', 'G'].reduce(([操作, 差分], 番号) => {
          if (一時座標群[番号] || (番号 === 'G' && 一時座標群.Z)) {
            const { X: X1, Y: Y1 } = 一時座標群[番号] || 一時座標群.Z;
            const { T } = 角度取得(X1 - X, Y1 - Y);
            const 差分角度 = ((角) => Math.min(角, Math.PI * 2 - 角))(Math.abs(指示角度 - T + (番号 === 'G' ? Math.PI : 0)) % (Math.PI * 2));

            if (!操作 || 差分角度 < 差分) {
              return [番号, 差分角度];
            }
          }

          return [操作, 差分];
        }, [null, null]);
        const [方面, 前後] = { S: [0, 0], Y: [0, 1], Z: [1, 0], G: [1, 1] }[操作];
        const 探索単位 = 0.002;
        const 内外 = (移動履歴.length - 1) % 2;
        if (方面 === 0) {
          if (内外) {
            const [旧面, 旧列, 旧番号, 旧位置1, 旧位置2] = 移動履歴[移動履歴.length - 1];
            const 旧対照情報 = 進捗平面対照群[旧面][旧列][1][旧番号];
            const { 位置: 旧末端, 平面群: 末端平面群 } = 旧対照情報.末端情報[旧位置2];
            if (旧位置1 === 旧位置2) {
              移動履歴.pop();
              移動履歴[移動履歴.length - 1][4] = 旧末端;
              const 旧通路面 = 旧列 < 通路列数 - 1 || !旧位置2 ? 旧面 : 旧対照情報.接続面;
              const 通過加算値 = [2, 4][旧位置2];
              末端平面群.forEach((記号) => {
                const 通過値 = 通路平面群[旧通路面][記号].通過;
                通路平面群[旧通路面][記号].通過 = 通過値 - (通過値 & 通過加算値);
              });
            } else {
              if (Math.abs(旧位置2 - 旧位置1) !== 1) {
                return;
              }
              const 新面 = (旧列 < 通路列数 - 1 || 旧位置2 === 0) ? 旧面 : 旧対照情報.接続面;
              const 新列 = 旧列 < 通路列数 - 1 ? 旧列 + 旧位置2 : 旧列;
              移動履歴.push([新面, 新列, 旧対照情報.末端情報[旧位置2].番号, 旧末端, 旧末端]);
            }
          }
          const 履歴情報 = 移動履歴[移動履歴.length - 1];
          const [面, 列, 番号, _, 位置] = 履歴情報;
          const 対照情報 = 進捗平面対照群[面][列][0][番号];
          const { 楕円A, 角度Y } = 隔壁臨界位置群[列][0];
          const 探索距離 = 探索単位 * 線分3 / 楕円A * Math.PI / 角度Y;
          履歴情報[4] = 前後
            ? ((値, 末端) => 値 < 末端 ? 値 : (列 > 0 || !中心空間確保 ? 末端 : (値 - 方向数)))(位置 + 探索距離, 対照情報.平面群[対照情報.平面群.length - 1])
            : ((値, 末端) => 値 > 末端 ? 値 : (列 > 0 || !中心空間確保 ? 末端 : (値 + 方向数)))(位置 - 探索距離, 対照情報.平面群[0]);
          const 始端 = Math.min(履歴情報[3], 履歴情報[4]);
          const 終端 = Math.max(履歴情報[3], 履歴情報[4]);
          Array((対照情報.平面群.length - 1) / 2).fill(null).forEach((_, 番号係数) => {
            const 始端限界 = 対照情報.平面群[番号係数 * 2];
            const 終端限界 = 対照情報.平面群[番号係数 * 2 + 2];
            const 記号 = 対照情報.平面群[番号係数 * 2 + 1];
            const 通過値 = 通路平面群[面][記号].通過;
            const 通過判定 = 始端限界 < 終端 && 終端限界 > 始端;
            通路平面群[面][記号].通過 = 通過判定 ? (通過値 | 1) : (通過値 - (通過値 & 1));
          });
        } else {
          if (!内外) {
            const [旧面, 旧列, 旧番号, _, 旧位置] = 移動履歴[移動履歴.length - 1];
            const 旧方向 = (Math.floor(旧位置) + 方向数) % 方向数;
            const 連絡口列 = 旧列 + [-1, 0][前後];
            const [接続面, 接続方向] = 連絡口列 < 通路列数 - 1 ? [旧面] : 面接続情報群[旧面][旧方向];
            const 連絡口面 = 連絡口列 < 通路列数 - 1 ? 旧面 : Math.min(旧面, 接続面);
            const 連絡口末端係数 = 1 - (連絡口面 < 旧面 ? 0 : 前後);
            const 前後係数 = 連絡口面 < 旧面 ? 1 : 0;
            const 隣接対照情報番号 = 連絡口列 < 0 ? -1 : 進捗平面対照群[連絡口面][連絡口列][1].findIndex((情報, B) => {
              const 連絡口 = 連絡口群[連絡口面][連絡口列][情報.番号];
              if (連絡口面 !== 旧面 && 連絡口[0].方向 !== 接続方向) {
                return false;
              }
              const 連絡口始端 = ((値) => 値.方向 + 値.進捗)(連絡口列 < 通路列数 - 1 ? 連絡口[0][1 - 前後] : ((値) => 連絡口面 < 旧面 ? { 方向: 旧方向, 進捗: 1 - 値.進捗 } : 値)(連絡口[前後係数]));
              const 連絡口終端 = ((値) => 値.方向 + 値.進捗)(連絡口列 < 通路列数 - 1 ? 連絡口[1][1 - 前後] : ((値) => 連絡口面 < 旧面 ? { 方向: 旧方向, 進捗: 1 - 値.進捗 } : 値)(連絡口[1 - 前後係数]));

              return [-1, 0, 1].findIndex((係数) => ((位置) => 位置 >= 連絡口始端 && 位置 <= 連絡口終端)(旧位置 + 方向数 * 係数)) >= 0;
            });
            if (隣接対照情報番号 < 0) {
              return;
            }
            const 旧移動履歴 = 移動履歴[移動履歴.length - 2];
            const 履歴一致 = 旧移動履歴 && 旧移動履歴[0] === 連絡口面 && 旧移動履歴[1] === 連絡口列 && 旧移動履歴[2] === 隣接対照情報番号;
            if (履歴一致) {
              移動履歴.pop();
              const 旧対照情報 = 進捗平面対照群[旧面][旧列][0][旧番号];
              Array((旧対照情報.平面群.length - 1) / 2).fill(null).forEach((_, 番号係数) => {
                const 始端限界 = 旧対照情報.平面群[番号係数 * 2];
                const 終端限界 = 旧対照情報.平面群[番号係数 * 2 + 2];
                const 記号 = 旧対照情報.平面群[番号係数 * 2 + 1];
                const 通過値 = 通路平面群[旧面][記号].通過;
                通路平面群[旧面][記号].通過 = 通過値 - (通過値 & 1);
              });
            } else {
              移動履歴.push([連絡口面, 連絡口列, 隣接対照情報番号, 連絡口末端係数, 連絡口末端係数]);
            }
          }
          const 履歴情報 = 移動履歴[移動履歴.length - 1];
          const [面, 列, 番号, _, 位置] = 履歴情報;
          const 対照情報 = 進捗平面対照群[面][列][1][番号];
          const [値1, 値2, 値3, 値4] = 対照情報.範囲;
          const 総距離 = 列 < 通路列数 - 1 ? 値4 - 値1 : ((情報) => (値2 - 値1 + 情報.角度X / 情報.距離倍率) * 2)(対照情報.平面情報);
          const 探索距離 = 探索単位 * Math.PI * 2 / 総距離;
          履歴情報[4] = 前後
            ? Math.min(位置 + 探索距離, 1)
            : Math.max(位置 - 探索距離, 0);
          const 始端 = Math.min(履歴情報[3], 履歴情報[4]);
          const 終端 = Math.max(履歴情報[3], 履歴情報[4]);
          if (列 < 通路列数 - 1) {
            const 範囲始端 = (値2 - 値1) / (値4 - 値1);
            const 範囲終端 = (値3 - 値1) / (値4 - 値1);
            対照情報.平面群.forEach((記号) => {
              通路平面群[面][記号].通過 = 終端 >= 範囲始端 && 始端 <= 範囲終端;
            });
            対照情報.末端情報.forEach(({ 平面群 }, 末端前後) => {
              const 通過加算値 = [2, 4][末端前後];
              const 通過判定 = 末端前後 ? (終端 >= 範囲終端) : (始端 <= 範囲始端);
              平面群.forEach((記号) => {
                const 通過値 = 通路平面群[面][記号].通過;
                通路平面群[面][記号].通過 = 通過判定 ? (通過値 | 通過加算値) : (通過値 - (通過値 & 通過加算値));
              });
            });
          } else {
            const 距離分岐点 = (値2 - 値1) / 総距離;
            const 連絡口通過判定 = 始端 <= 1 - 距離分岐点 && 終端 >= 距離分岐点;
            対照情報.平面群.forEach((記号) => {
              通路平面群[面][記号].通過 = 連絡口通過判定;
            });
            対照情報.末端情報.forEach(({ 平面群 }, 末端前後) => {
              const 通過加算値 = [2, 4][末端前後];
              const 通過判定 = 末端前後 ? (終端 >= 1 - 距離分岐点) : (始端 <= 距離分岐点);
              平面群.forEach((記号) => {
                const 通路面 = 末端前後 ? 対照情報.接続面 : 面;
                const 通過値 = 通路平面群[通路面][記号].通過;
                通路平面群[通路面][記号].通過 = 通過判定 ? (通過値 | 通過加算値) : (通過値 - (通過値 & 通過加算値));
              });
            });
          }
        }
      };

      const 進行 = () => {
        const 通路座標計算 = (面, 列, 位置, 垂直相対位置 = 0) => {
          const 方向 = Math.floor(位置);
          const 進捗 = 位置 - 方向;
          const { 楕円A, 交線B, 角度Y } = 通路臨界位置群[列];
          const 位置座標X = Math.sin(角度Y * (2 * 進捗 - 1)) * 楕円A;
          const 位置距離X = Math.cos(角度Y * (2 * 進捗 - 1)) * 楕円A;
          const 位置座標Y = Math.sin(角度2) * 位置距離X + 交線B;
          const 位置距離Z = Math.pow(位置座標X * 位置座標X + 位置座標Y * 位置座標Y, 1 / 2);
          const 位置角度Y = Math.asin(位置座標X / 位置距離Z) + Math.PI * 2 / 方向数 * 方向;
          const 位置角度X = Math.asin(位置距離Z / 線分3);

          return 面座標変換(面, { X: 位置角度X + 垂直相対位置, Y: 位置角度Y, R: 径 - 隔壁高 / 2 });
        };

        const [面, 列, 番号, 開始位置, 位置] = 移動履歴[移動履歴.length - 1];
        const 内外 = (移動履歴.length - 1) % 2;
        if (内外) {
          const { 角度, 範囲, 末端情報, 方向 } = 進捗平面対照群[面][列][1][番号];
          if (列 < 通路列数 - 1) {
            const 角度X = 範囲[0] + (範囲[3] - 範囲[0]) * 位置;
            現在座標 = [
              { 番号: 'C', 座標: 面座標変換(面, { X: 角度X, Y: 角度, R: 径 - 隔壁高 / 2 }) },
              { 番号: 'Z', 座標: 面座標変換(面, { X: 角度X - 0.01, Y: 角度, R: 径 - 隔壁高 / 2 }) },
            ];
            if ([0, 1].includes(位置)) {
              ['S', 'Y'].forEach((番号, 進捗係数) => {
                現在座標.push({ 番号, 座標: 通路座標計算(面, 列 + 位置, 末端情報[位置].位置 + [-1, 1][進捗係数] * 0.01) });
              });
            }
          } else {
            const { 接続面, 平面情報: { 角度X, 角度Y, 距離X, 距離倍率 } } = 進捗平面対照群[面][列][1][番号];
            const 距離1 = 範囲[1] - 範囲[0];
            const 距離2 = 角度X / 距離倍率;
            const 距離分岐点 = 距離1 / (距離1 + 距離2) / 2;
            if (位置 <= 距離分岐点) {
              const 角度X1 = 範囲[0] + (範囲[1] - 範囲[0]) * 位置 / 距離分岐点;
              現在座標 = [
                { 番号: 'C', 座標: 面座標変換(面, { X: 角度X1, Y: 角度, R: 径 - 隔壁高 / 2 }) },
                { 番号: 'Z', 座標: 面座標変換(面, { X: 角度X1 - 0.01, Y: 角度, R: 径 - 隔壁高 / 2 }) },
              ];
              if (位置 === 0) {
                ['S', 'Y'].forEach((番号, 進捗係数) => {
                  現在座標.push({ 番号, 座標: 通路座標計算(面, 列, 末端情報[0].位置 + [-0.01, 0.01][進捗係数]) });
                });
              }
            } else if (1 - 位置 <= 距離分岐点) {
              const 通路方向 = 面接続情報群[面].findIndex(([接続面候補]) => 接続面候補 === 接続面);
              const [_, 接続方向] = 面接続情報群[面][通路方向];
              const 角度X1 = 範囲[0] + (範囲[1] - 範囲[0]) * (1 - 位置) / 距離分岐点;
              const 角度Y1 = Math.PI * 2 / 方向数 * 接続方向 - (角度 - Math.PI * 2 / 方向数 * 通路方向);
              現在座標 = [
                { 番号: 'C', 座標: 面座標変換(接続面, { X: 角度X1, Y: 角度Y1, R: 径 - 隔壁高 / 2 }) },
                { 番号: 'Z', 座標: 面座標変換(接続面, { X: 角度X1 + 0.01, Y: 角度Y1, R: 径 - 隔壁高 / 2 }) },
              ];
              if (位置 === 1) {
                ['S', 'Y'].forEach((番号, 進捗係数) => {
                  現在座標.push({ 番号, 座標: 通路座標計算(接続面, 列, 末端情報[1].位置 + [-0.01, 0.01][進捗係数]) });
                });
              }
            } else {
              const 臨界位置 = (位置 - 距離分岐点) / (1 - 距離分岐点 * 2);
              const 臨界角度 = 角度X * (臨界位置 * 2 - 1);
              現在座標 = ['C', 'Z'].map((番号, 位置係数) => {
                const { 楕円A } = 隔壁臨界位置群[列][0];
                const { Y: 座標Y, X: 座標Z } = 座標取得(Math.PI / 2 - 臨界角度 - 角度2, 距離X);
                const 座標X = Math.sin(角度Y) * 楕円A;
                const { T: 角度Z, L: 距離Z } = 角度取得(座標X, 座標Y);
                const 角度X1 = Math.asin(距離Z / 線分3) - 位置係数 * 0.01;

                return { 番号, 座標: 面座標変換(面, { X: 角度X1, Y: 角度Z + 方向 * Math.PI * 2 / 方向数, R: 径 - 隔壁高 / 2 }) };
              });
            }
          }
        } else {
          現在座標 = ['S', 'C', 'Y'].map((番号, 進捗係数) => ({ 番号, 座標: 通路座標計算(面, 列, 位置 + [-1, 0, 1][進捗係数] * 0.01) }));
          現在座標.push({ 番号: 'Z', 座標: 通路座標計算(面, 列, 位置, -0.01) });
        }
      };

      const startAnimation = () => {
        animationSwitch = true;
        再生();
      };

      const stopAnimation = () => {
        if (animation) {
          clearTimeout(animation);
        }
        animationSwitch = false;
        animationStartSwitch = false;
      };

      const moveStopCheck = (clientX, clientY) => {
        animationStartSwitch = latestMoveX !== clientX || latestMoveY !== clientY;
      };

      gauzeElem.addEventListener('mousedown', (event) => {
        探索指示 = [0, 0];
        stopAnimation();
        転回信号 = true;
        resetAxis(event.clientX, event.clientY);
        document.body.classList.add('operating');
      });

      gauzeElem.addEventListener('mousemove', (event) => {
        if (転回信号) {
          setAxis(event.clientX, event.clientY);
          animationStartSwitch = true;
          clearTimeout(animationTimeout);
          animationTimeout = setTimeout(() => {
            moveStopCheck(event.clientX, event.clientY);
          }, 100);
          再生();
        }
      });

      const 設定 = () => {
        通路列数 = 通路列数群[面数];
        解像度 = 解像度群[面数];
        方向数 = 方向数群[面数];
        面接続情報群 = 面接続情報群群[面数];
        角度1 = 定数群[面数].角度1;
        角度2 = 定数群[面数].角度2;
        線分1 = 定数群[面数].線分1;
        線分3 = 定数群[面数].線分3;
        隔壁厚 = 隔壁厚群[面数];
        隔壁厚角度 = 隔壁厚 / 径;
        通路厚角度 = 角度2 / 通路列数 / 2 - 隔壁厚角度;
        基準Z = Math.sin(角度1) * (径 - 隔壁高) * -1;
        座標群 = {};
        const 隔壁厚距離群 = 座標取得(隔壁厚角度, 線分3);
        const 通路厚距離群 = 座標取得(通路厚角度, 線分3);
        隔壁厚距離1 = 隔壁厚距離群.X;
        隔壁厚距離2 = 隔壁厚距離群.Y;
        通路厚距離1 = 通路厚距離群.X;
        通路厚距離2 = 通路厚距離群.Y;
        迷路座標群.splice(0);
        隔壁平面群.splice(0);
        通路平面群.splice(0);
        壁頂平面群.splice(0);
        通路群.splice(0);
        連絡口群.splice(0);
        管轄群.splice(0);
        拡張可能通路群.splice(0);
        進捗平面対照群.splice(0);
        Array(面数).fill(null).fill(null).forEach((_, 面) => {
          通路群[面] = Array(通路列数).fill(null).map(() => []);
          連絡口群[面] = Array(通路列数).fill(null).map(() => []);
          進捗平面対照群[面] = Array(通路列数).fill(null).map(() => [[], []]);
        });
        隔壁臨界位置群 = Array(通路列数).fill(null).map((_1, 列) => [0, 1].map((表裏) => 隔壁臨界位置取得(列, 表裏)));
        隔壁臨界位置群[-1] = [null, 隔壁臨界位置取得(-1, 1)];
        通路臨界位置群 = Array(通路列数).fill(null).map((_1, 列) => 隔壁臨界位置取得(列 - 0.5, -1));
        移動履歴 = [[0, 0, 0, 0.5, 0.5]];
        目的面 = 1 + Math.floor(Math.random() * (面数 - 1));
        進行();
      };

      const 構築 = () => {
        re = [];
        iz = [];
        if (!検査) {
          列連結();
          面連結();
        }
        re.push(['']);
        rea();
        if (検査) {
          if (検査 !== 'z') 拡張([通路群[検査[0]][検査[1]][検査[2]], 検査[3]]);
        } else {
          拡張();
        }
        構成();
        再現();
        再生();
      };
      const 面指定器 = document.再生['面指定']
      const 面選択肢 = 面指定器.options;
      Array.from(面選択肢).forEach((候補) => {
        if (parseInt(候補.value) === 面数) {
          候補.selected = true;
        }
      });

      document.addEventListener('keydown', ({ key, repeat }) => {
        switch (key) {
          case 'ArrowLeft':
          case 'ArrowRight':
          case 'ArrowUp':
          case 'ArrowDown':
            if (!repeat) {
              探索制御設定[key].forEach((値, 項) => {
                探索指示[項] += 値;
              });
              animationSwitch = true;
              if (animation) {
                clearTimeout(animation);
              }
              animation = setTimeout(再生, 50);
            }
            break;

          case 'Shift':
            return h();
          default:
            // console.log(key);
        }
      });

      document.addEventListener('keyup', ({ key }) => {
        switch (key) {
          case 'ArrowLeft':
          case 'ArrowRight':
          case 'ArrowUp':
          case 'ArrowDown':
            探索制御設定[key].forEach((値, 項) => {
              探索指示[項] -= 値;
            });
            if (!(探索指示[0] || 探索指示[1])) {
              animationSwitch = false;
              if (animation) {
                clearTimeout(animation);
              }
            }
            break;
        }
      });

      checkElem.addEventListener('change', (event) => {
        distanceSwitch = event.target.checked;
        if (distanceSwitch) {
          meterBoxElem.classList.remove('disable');
        } else {
          meterBoxElem.classList.add('disable');
        }
        if (!animationSwitch) {
          再生();
        }
      });

      meterBoxElem.addEventListener('mousedown', (event) => {
        if (!distanceSwitch) {
          return;
        }
        const elementRect = meterBoxElem.getBoundingClientRect();
        const minPosition = elementRect.x + meterHandlePadding;
        const maxPosition = elementRect.x + meterBoxWidth - meterHandlePadding;
        mousePosition = event.clientX;
        meterPositionCandidate = Math.min(Math.max(minPosition, mousePosition), maxPosition);
        if (Math.abs(meterPosition - meterPositionCandidate) > meterHandlePadding) {
          meterPosition = meterPositionCandidate;
          const percentage = (meterPosition - minPosition) / (maxPosition - minPosition);
          画角度 = (最大画角度 - 最小画角度) * percentage + 最小画角度;
          視角拡大率 = Math.tan(画角度);
          meterHandleElem.style.left = `${meterPosition - minPosition}px`;
        }
        meterChangeSwitch = true;
        document.body.classList.add('operating');
      });

      document.addEventListener('mousemove', (event) => {
        if (!distanceSwitch || !meterChangeSwitch) {
          return;
        }

        const elementRect = meterBoxElem.getBoundingClientRect();
        const minPosition = elementRect.x + meterHandlePadding;
        const maxPosition = elementRect.x + meterBoxWidth - meterHandlePadding;
        const mousePositionOrigin = Math.min(Math.max(minPosition, event.clientX), maxPosition);
        const diffPosition = mousePositionOrigin - mousePosition;
        mousePosition = mousePositionOrigin;
        meterPosition = Math.min(Math.max(minPosition, meterPosition + diffPosition), maxPosition);
        const percentage = (meterPosition - minPosition) / (maxPosition - minPosition);
        画角度 = (最大画角度 - 最小画角度) * percentage + 最小画角度;
        視角拡大率 = Math.tan(画角度);
        meterHandleElem.style.left = `${meterPosition - minPosition}px`;
        if (!animationSwitch) {
          再生();
        }
      });

      document.addEventListener('mouseup', (event) => {
        meterChangeSwitch = false;
        document.body.classList.remove('operating');
        if (転回信号) {
          転回信号 = false;
          setAxis(event.clientX, event.clientY);
        }
        if (animationStartSwitch) {
          startAnimation();
        }
      });

      面指定器.onchange = () => {
        const 選択番号 = 面指定器.selectedIndex;
        面数 = parseInt(面選択肢[選択番号].value);
        設定();
        構築();
      };

      const kk = (M, L, B, NG = null) => {
        const T = 通路群[M]?.[L]?.[B];
        if (T) {
          const NGS = 拡張可能壁群取得(T);
          ['内端', '外端'].forEach((NGH, NGK) => {
            if (NG === null || NG === NGK) {
              NGS[NGH].forEach((ZGS) => {
                ZGS.forEach(({ 方向, 進捗 }, ZG) => {
                  ZGS[ZG] = { 方向, 進捗 };
                });
              });
            }
          });

          return NG === null ? NGS : NGS[['内端', '外端'][NG]];
        }

        return 'N';
      };
      const k = (S, M, I = null, N = '0ff', H = 0.2) => {
        M = M ?? parseInt(S.replace(/_.*/, ''));
        const [平面群名称, 平面群] = [
          ['隔壁平面群', 隔壁平面群[M][S]?.S],
          ['壁頂平面群', 壁頂平面群[M][S]],
          ['通路平面群', 通路平面群[M][S]],
        ].find(([平面群名称, 平面群]) => !!平面群);
        描画制御.beginPath();
        平面群.forEach((C, c) => {
          const { X, Y } = 一時座標群[C];
          c ? 描画制御.lineTo(中心 + X, 中心 + Y) : 描画制御.moveTo(中心 + X, 中心 + Y);
        });
        描画制御.closePath();
        if (I) {
          描画制御.strokeStyle = I ? `#${I}` : '#f00';
          if (H) {
            描画制御.lineWidth = `#${H}`;
          }
          描画制御.stroke();
        }
        if (N) {
          描画制御.fillStyle = `#${N}`;
          描画制御.fill();
        }
        描画制御.lineWidth = 0.2;
        return `${平面群名称}[${M}]['${S}']`;
      };
      const c = (C, I = '#f00') => {
        描画制御.beginPath();
        const { X, Y } = 一時座標群[C] || { X: 0, Y: 0 };
        描画制御.moveTo(中心, 中心);
        描画制御.lineTo(中心 + X, 中心 + Y);
        描画制御.strokeStyle = I || '#f00';
        描画制御.stroke();
        return 座標群[C] || 'N';
      };
      const kc = (S, M, I = null, N = '0ff', H = 0.2) => {
        M = M ?? parseInt(S.replace(/_.*/, ''));
        const [平面群名称, 平面群] = [
          ['隔壁平面群', 隔壁平面群[M][S]?.S],
          ['壁頂平面群', 壁頂平面群[M][S]],
          ['通路平面群', 通路平面群[M][S]],
        ].find(([平面群名称, 平面群]) => !!平面群);
        console.log(k(S, M, I, N, H));
        平面群.forEach((C) => {
          c(C);
          console.log(C);
        });
      };
      const s = (再現番号) => {
        if (re[再現番号]) {
          const 過去状態 = JSON.parse(re[再現番号][1]);
          kt(過去状態);
          Object.keys(座標群).forEach((_, Z) => {
            delete 座標群[Z];
          });
          構成();
          再現();
          再生();
        }
      };
      const d = (再現番号) => {
        if (re[再現番号]) {
          const J = `kt(${re[再現番号][1]});`;
          const K = ((KS) => KS ? `\n検査 = [${KS.replace(/([0-9]+)_([0-9]+)_([0-9]+)_(.*)/, `$1, $2, $3, '$4'`)}];` : '')(re[再現番号 + 1]?.[0] || '');
          console.log(J + K);
        }
      };
      const ce = document.getElementById('test');
      const cc = ce.getContext('2d');
      ce.width = 画面幅;
      ce.height = 画面幅;
      ce.style.width = 'var(--main-width)';
      ce.style.height = 'var(--main-width)';
      描画制御.lineWidth = 0.2;
      const sc = (...指示) => {
        const[再現番号, 面] = [
          指示.length === 2 ? 指示[0] : re[re.length - 1],
          指示[指示.length - 1] || 0,
        ];
        if (!re[再現番号]) {
          return;
        }
        cc.clearRect(0, 0, 画面幅, 画面幅);
        cc.strokeStyle = '#f8a';
        cc.font = '12px';
        Array(通路列数).fill(null).forEach((_1, 列) => {
          [0, 1].forEach((表裏) => {
            const { 楕円A, 楕円B, 交線B, 角度Y } = 隔壁臨界位置群[列][表裏];
            // cc.strokeStyle = '#f8a';
            cc.beginPath();
            Array(方向数).fill(null).forEach((_2, 方向) => {
              const 位置角度 = Math.PI * 2 / 方向数 * 方向;
              const 位置座標X = 中心 + Math.sin(0 - 位置角度) * 交線B * 径;
              const 位置座標Y = 中心 + Math.cos(0 - 位置角度) * 交線B * 径;
              const 最大角度 = (列 < 通路列数 - 1 || !表裏) ? 角度Y : 隔壁臨界位置群[列][0].角度Y;
              cc.ellipse(位置座標X, 位置座標Y, 楕円A * 径, 楕円B * 径, 位置角度, Math.PI / 2 - 最大角度, Math.PI / 2 + 最大角度);
            });
            cc.closePath();
            cc.stroke();
          });
        });
        cc.fillStyle = '#000';
        Array(方向数).fill(null).forEach((_, 方向) => {
          const [接続面, 接続方向] = 面接続情報群[面][方向];
          const 接続案内 = `${接続面}-${接続方向}`;
          const 幅情報 = cc.measureText(接続案内);
          const 位置角度 = Math.PI * 2 / 方向数 * 方向;
          const 位置座標X = 中心 + Math.sin(位置角度) * 径 - 幅情報.width / 2;
          const 位置座標Y = 中心 + Math.cos(位置角度) * 径 + 6;
          cc.fillText(接続案内, 位置座標X, 位置座標Y);
        });
        const [再現通路群, 再現連絡口群] = JSON.parse(re[再現番号][1]);
        再現通路群[面].forEach((列内通路群, 列) => {
          列内通路群.forEach((T) => {
            const 種別 = ['通路', '隔壁'][T[0]];
            const 方向1 = Math.floor(T[3]);
            const 進捗1 = T[3] - 方向1;
            const 方向2 = T[0] || Math.floor(T[4]);
            const 進捗2 = T[0] || T[4] - 方向2;
            const 位置 = T[0]
              ? 隣接隔壁情報取得('隔壁', 列, 方向1, 進捗1, 1, 0)
              : 列
                ? [
                  (([ZH]) => ZH.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(隣接通路情報取得(列, 方向1, 進捗1, 1, 0)),
                  (([ZH]) => ZH.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(隣接通路情報取得(列, 方向2, 進捗2, 0, 0)),
                ]
                : [
                  [{ 方向: 方向1, 進捗: 進捗1 }, { 方向: 方向1, 進捗: 進捗1 }],
                  [{ 方向: 方向2, 進捗: 進捗2 }, { 方向: 方向2, 進捗: 進捗2 }],
                ];
            cc.beginPath();
            [0, 1].forEach((内外) => {
              if (列 || 内外) {
                Array(位置[1][内外].方向 - 位置[0][内外].方向 + 1).fill(null).forEach((_, 方向係数) => {
                  const 方向 = 位置[1 - 内外][内外].方向 + 方向係数 * [-1, 1][内外];
                  const 始端進捗 = 方向係数 ? 1 - 内外 : 位置[1 - 内外][内外].進捗;
                  const 終端進捗 = 方向係数 < 位置[1][内外].方向 - 位置[0][内外].方向 ? 内外 : 位置[内外][内外].進捗;
                  const 位置角度 = Math.PI * 2 / 方向数 * (0 - 方向);
                  const { 楕円A, 楕円B, 交線B, 角度Y } = 隔壁臨界位置群[列 - 1 + 内外][1 - 内外];
                  const 位置座標X = 中心 - Math.sin(位置角度) * 交線B * 径;
                  const 位置座標Y = 中心 + Math.cos(位置角度) * 交線B * 径;
                  const 角度1 = Math.PI / 2 + 角度Y * (1 - 始端進捗 * 2);
                  const 角度2 = Math.PI / 2 + 角度Y * (1 - 終端進捗 * 2);
                  const 描画方向制御 = [false, true][内外];
                  cc.ellipse(位置座標X, 位置座標Y, 楕円A * 径, 楕円B * 径, 位置角度, 角度1, 角度2, 描画方向制御);
                });
              } else {
                cc.moveTo(中心, 中心);
              }
            });
            cc.closePath();
            cc.fillStyle = { 隔壁: '#ff668844', 通路: '#6688ff44' }[種別];
            cc.fill();
          });
        });
        再現連絡口群[面].forEach((列内連絡口群, 列) => {
          列内連絡口群.forEach((L) => {
            const 方向 = Math.floor(L);
            const 進捗 = L - 方向;
            const 位置 = 列 < 通路列数 - 1
              ? 隣接隔壁情報取得('連絡口', 列, 方向, 進捗, 1, 0)
              : ((ZH) => ZH[0])(隣接外端連絡口情報取得(面, 方向, 進捗, 1));
            cc.beginPath();
            [0, 1].forEach((内外) => {
              const { 楕円A, 楕円B, 交線B, 角度Y } = 隔壁臨界位置群[列][内外];
              const 最大角度 = 列 < 通路列数 - 1 || !内外 ? 角度Y : 隔壁臨界位置群[列][0].角度Y;
              const 絶対始端 = 列 < 通路列数 - 1 ? 位置[0][内外] : 位置[0];
              const 絶対終端 = 列 < 通路列数 - 1 ? 位置[1][内外] : 位置[1];
              const 相対始端 = 列 < 通路列数 - 1 ? 位置[内外][内外] : 位置[内外];
              const 相対終端 = 列 < 通路列数 - 1 ? 位置[1 - 内外][内外] : 位置[1 - 内外];
              Array(絶対終端.方向 - 絶対始端.方向 + 1).fill(null).forEach((_, 方向係数) => {
                const 方向 = 相対終端.方向 + 方向係数 * [-1, 1][内外];
                const 始端進捗 = 方向係数 ? 1 - 内外 : 相対終端.進捗;
                const 終端進捗 = 方向係数 < 絶対終端.方向 - 絶対始端.方向 ? 内外 : 相対始端.進捗;
                const 位置角度 = Math.PI * 2 / 方向数 * (0 - 方向);
                const 位置座標X = 中心 - Math.sin(位置角度) * 交線B * 径;
                const 位置座標Y = 中心 + Math.cos(位置角度) * 交線B * 径;
                const 角度1 = Math.PI / 2 + 最大角度 * (1 - 始端進捗 * 2);
                const 角度2 = Math.PI / 2 + 最大角度 * (1 - 終端進捗 * 2);
                const 描画方向制御 = [false, true][内外];
                cc.ellipse(位置座標X, 位置座標Y, 楕円A * 径, 楕円B * 径, 位置角度, 角度1, 角度2, 描画方向制御);
              });
            });
            cc.closePath();
            cc.fillStyle = '#88cc8844';
            cc.fill();
          });
        });
        Array(方向数).fill(null).forEach((_1, 方向) => {
          Array(10).fill(null).forEach((_2, 進捗) => {
            cc.beginPath();
            cc.moveTo(中心, 中心);
            Array(通路列数 * 2 - 1).fill(null).forEach((_3, 列係数) => {
              const 列 = Math.floor((列係数) / 2);
              const 内外 = 列係数 % 2;
              const { 角度Y, 楕円A, 楕円B, 交線B } = 隔壁臨界位置群[列][内外];
              const T = 角度Y * (2 * 進捗 / 10 - 1);
              const X = Math.sin(T) * 楕円A;
              const Y = Math.cos(T) * 楕円B + 交線B;
              const L = Math.pow(X * X + Y * Y, 1 / 2);
              const 角度 = Math.acos(Y / L) * (X >= 0 ? 1 : -1) + Math.PI * 2 / 方向数 * 方向;
              const 座標X = Math.sin(角度) * L * 径;
              const 座標Y = Math.cos(角度) * L * 径;
              cc.lineTo(中心 + 座標X, 中心 + 座標Y);
            });
            cc.strokeStyle = [0, 5].includes(進捗) ? '#ff88aa55' : '#8888ff33';
            cc.stroke();
          });
        });
      };
      const h = () => {
        const { X, Y } = 一時座標群.C;
        ['Z', 'S', 'Y', 'G'].forEach((番号) => {
          const 方角 = { Z: '上', Y: '右', G: '下', S: '左' }[番号];
          if (一時座標群[番号] || (番号 === 'G' && 一時座標群.Z)) {
            const { X: X1, Y: Y1 } = 一時座標群[番号] || 一時座標群.Z;
            const 角度 = (({ T }) => T + (番号 === 'G' ? Math.PI : 0))(角度取得(X1 - X, Y1 - Y));
            const 幅情報 = cc.measureText(方角);
            const 位置座標X = 中心 + X1 + Math.sin(角度) * (径 / 2 + 10) - 幅情報.width / 2;
            const 位置座標Y = 中心 + Y1 + Math.cos(角度) * (径 / 2 + 10) + 6;
            描画制御.beginPath();
            描画制御.moveTo(中心 + X1, 中心 + Y1);
            描画制御.lineTo(中心 + X1 + Math.sin(角度) * 径 / 2, 中心 + Y1 + Math.cos(角度) * 径 / 2);
            描画制御.closePath();
            描画制御.strokeStyle = '#f00';
            描画制御.stroke();
            描画制御.beginPath();
            描画制御.fillStyle = '#f00';
            描画制御.fillText(方角, 位置座標X, 位置座標Y);
          }
        });
      };

      // ▼検査用▼

      // 検査 = 'z';
      // 移動履歴 = [];


      // ▲検査用▲

      描画実体.setAttribute('width', `${画面幅}px`);
      描画実体.setAttribute('height', `${画面幅}px`);
      描画制御.lineWidth = 0.2;

      if (!検査) {
        設定();
      }
      進行();
      構築();
    </script>
  </body>
</html>