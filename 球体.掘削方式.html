<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8 />
    <style>
      html {
        font-size: 10px;
      }
      :root {
        --main-width: 35.1rem;
      }
      body {
        margin: 0;
        padding: 0;
      }
      body.operating * {
        user-select: none;
      }
      #contents_frame {
        display: grid;
        grid-template-columns: auto auto 1fr;
        grid-template-rows: auto auto auto;
        margin: 1rem;
        padding: 0;
      }
      #radar_frame {
        position: relative;
        grid-column: 1;
        grid-row: 1;
        margin: 0 1rem 1rem 0;
        width: var(--main-width);
        height: var(--main-width);
        border: solid 0.1rem #aaa;
        /* opacity: 0.2; */
      }
      #radar {
        position: absolute;
      }
      #test {
        /* opacity: 0.5; */
        grid-column: 1;
        grid-row: 2;
        border: solid 0.1rem #aaa;
      }
      #gauze {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        cursor: default;
        z-index: 1;
      }
      #form_frame {
        grid-column: 2;
        grid-row: 1 / 3;
        margin: 0 0 auto;
        padding: 0.5rem;
        border: solid 0.1rem #aaa;
        font-size: 1.2rem;
        width: 30rem;
      }
      #form_frame form {
        padding: 0;
      }
      .項目 {
        margin: 0 0 0.5rem 0;
        padding: 0.5rem;
        background-color: #eeeeff;
        display: grid;
        grid-template-columns: 25% 1fr;
      }
      .項目:last-child {
        margin: 0;
      }
      #setting_box {
        display: grid;
        grid-template-columns: 25% 1fr;
      }
      #switch_box {
        display: flex;
        align-items: center;
        padding-right: 1rem;
      }
      #meter_box {
        position: relative;
        height: 2.6rem;
        flex-grow: 1;
      }
      #meter_box::after {
        content: "";
        position: absolute;
        top: 1.2rem;
        left: 0;
        width: 100%;
        border-bottom: solid 0.2rem #88a;
        z-index: 1;
      }
      #handle {
        position: absolute;
        width: 1rem;
        height: 2.6rem;
        border: solid 1px #aaaaff;
        background-color: #ffffff;
        box-sizing: border-box;
        z-index: 2;
      }
      #meter_box.disable #handle {
        border: solid 1px #8888aa;
        background-color: #aaaaaa;
      }
    </style>
  </head>
  <body>
    <div id="contents_frame">
      <div id="radar_frame">
        <canvas id="radar"></canvas>
        <div id="gauze"></div>
      </div>
      <div id="form_frame">
        <form name="再生" action="" method="get">
          <div id="setting_box" class="項目">
            <div id="switch_box">
              <input type="checkbox" name="distance" id="distance_switch" checked />
              <label for="distance_switch">ズーム</label>
            </div>
            <div id="meter_box">
              <div id="handle"></div>
            </div>
          </div>
          <div class="項目">
            <span>面数</span>
            <select name="面指定">
              <option value="4">4</option>
              <option value="6">6</option>
              <option value="8">8</option>
              <option value="12">12</option>
              <option value="20">20</option>
            </select>
          </div>
        </form>
      </div>
      <canvas id="test"></canvas>
    </div>
    <script>
      const 隔壁高 = 10;
      const 隔壁厚 = 3;
      const 光源 = { X: 30 / 180 * Math.PI, Y:  45 / 180 * Math.PI };
      const 画面幅 = 351;
      const 中心 = 画面幅 / 2 + 0.5;
      const 径 = 160;
      const 中心空間確保 = true;
      const 軸走査限界半径 = 170;
      const 最小画角度 = (5 / 180) * Math.PI;
      const 最大画角度 = (20 / 180) * Math.PI;
      const frameElem = document.getElementById('radar_frame');
      const canvasElem = document.getElementById('radar');
      const canvasContext = canvasElem.getContext('2d');
      const gauzeElem = document.getElementById('gauze');
      const checkElem = document.再生.distance;
      const selectElem = document.再生.parameter_type;
      const meterBoxElem = document.getElementById('meter_box');
      const meterHandleElem = document.getElementById('handle');
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
      const rect = frameElem.getBoundingClientRect();
      const meterBoxStyle = window.getComputedStyle(meterBoxElem, '');
      const meterBoxWidth = parseInt(meterBoxStyle.width.replace('px', ''));
      const meterHandleStyle = window.getComputedStyle(meterHandleElem, '');
      const meterHandlePadding = parseInt(meterHandleStyle.width.replace('px', '')) / 2;
      const surfaceGroup = {};
      const 面接続情報群群 = {
        4: [
          [[1, 0], [2, 0], [3, 0]],
          [[0, 0], [3, 2], [2, 1]],
          [[0, 1], [1, 2], [3, 1]],
          [[0, 2], [2, 2], [1, 1]],
        ],
        6: [
          [[1, 0], [2, 0], [3, 0], [4, 0]],
          [[0, 0], [4, 3], [5, 2], [2, 1]],
          [[0, 1], [1, 3], [5, 1], [3, 1]],
          [[0, 2], [2, 3], [5, 0], [4, 1]],
          [[0, 3], [3, 3], [5, 3], [1, 1]],
          [[3, 2], [2, 2], [1, 2], [4, 2]],
        ],
        8: [
          [[1, 0], [2, 0], [3, 0]],
          [[0, 0], [5, 1], [6, 2]],
          [[0, 1], [6, 1], [4, 2]],
          [[0, 2], [4, 1], [5, 2]],
          [[7, 0], [3, 1], [2, 2]],
          [[7, 2], [1, 1], [3, 2]],
          [[7, 1], [2, 1], [1, 2]],
          [[4, 0], [6, 0], [5, 0]],
        ],
        12: [
          [[1, 0], [2, 0], [3, 0], [4, 0], [5, 0]],
          [[0, 0], [5, 4], [8, 2], [9, 3], [2, 1]],
          [[0, 1], [1, 4], [9, 2], [10, 3], [3, 1]],
          [[0, 2], [2, 4], [10, 2], [6, 3], [4, 1]],
          [[0, 3], [3, 4], [6, 2], [7, 3], [5, 1]],
          [[0, 4], [4, 4], [7, 2], [8, 3], [1, 1]],
          [[11, 0], [7, 4], [4, 2], [3, 3], [10, 1]],
          [[11, 4], [8, 4], [5, 2], [4, 3], [6, 1]],
          [[11, 3], [9, 4], [1, 2], [5, 3], [7, 1]],
          [[11, 2], [10, 4], [2, 2], [1, 3], [8, 1]],
          [[11, 1], [6, 4], [3, 2], [2, 3], [9, 1]],
          [[6, 0], [10, 0], [9, 0], [8, 0], [7, 0]],
        ],
        20: [
          [[1, 0], [2, 0], [3, 0]],
          [[0, 0], [8, 0], [6, 0]],
          [[0, 1], [9, 0], [4, 0]],
          [[0, 2], [7, 0], [5, 0]],
          [[2, 2], [14, 1], [7, 1]],
          [[3, 2], [15, 1], [8, 1]],
          [[1, 2], [13, 1], [9, 1]],
          [[3, 1], [4, 2], [12, 2]],
          [[1, 1], [5, 2], [10, 2]],
          [[2, 1], [6, 2], [11, 2]],
          [[17, 1], [13, 2], [8, 2]],
          [[18, 1], [14, 2], [9, 2]],
          [[16, 1], [15, 2], [7, 2]],
          [[18, 2], [6, 1], [10, 1]],
          [[16, 2], [4, 1], [11, 1]],
          [[17, 2], [5, 1], [12, 1]],
          [[19, 0], [12, 0], [14, 0]],
          [[19, 2], [10, 0], [15, 0]],
          [[19, 1], [11, 0], [13, 0]],
          [[16, 0], [18, 0], [17, 0]],
        ],
      };
      const 通路列数群 = { 4: 5, 6: 4, 8: 4, 12: 4, 20: 3 };
      const 解像度群 = { 4: 8, 6: 6, 8: 6, 12: 4, 20: 4 };
      const 方向数群 = { 4: 3, 6: 4, 8: 3, 12: 5, 20: 3 };
      const 定数群 = {
        4: (() => {
          const 線分1 = Math.sin(Math.PI / 3);
          const 角度1 = Math.acos(1 / 3);
          const 線分3 = 1 / Math.sin(角度1);
          const 角度2 = Math.acos(線分1 / 3 * 2);

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
        6: (() => {
          const 角度2 = Math.PI / 4;
          const 線分3 = Math.pow(3 / 2, 1 / 2);
          const 線分1 = 1 / Math.pow(2, 1 / 2);
          const 角度1 = Math.asin(1 / 線分3);

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
        8: (() => {
          const 線分1 = Math.sin(Math.PI / 3);
          const 角度1 = Math.acos(線分1 / 3 * 2);
          const 角度2 = Math.PI / 2 - 角度1;
          const 線分3 = Math.sin(角度1) * 3 / 2;

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
        12: (() => {
          const 五芒星比率 = (1 + Math.pow(5, 1 / 2)) / 2;
          const 線分1 = Math.sin(Math.PI / 5);
          const 線分2 = 線分1 * (1 + 五芒星比率);
          const 線分3 = Math.pow(線分1 * 線分1 + 線分2 * 線分2, 1 / 2);
          const 線分4 = Math.pow(線分3 * 線分3 - 1, 1 / 2);
          const 角度1 = Math.asin(1 / 線分3);
          const 角度2 = Math.acos(線分4 / 線分2);

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
        20: (() => {
          const 五芒星比率 = (1 + Math.pow(5, 1 / 2)) / 2;
          const 線分1 = Math.sin(Math.PI / 3);
          const 線分2 = 線分1 * 五芒星比率;
          const 線分3 = Math.pow(線分1 * 線分1 + 線分2 * 線分2, 1 / 2);
          const 角度1 = Math.asin(1 / 線分3);
          const 角度2 = Math.asin(1 / 2 / 線分2);

          return { 角度1, 角度2, 線分1, 線分3 };
        })(),
      }

      let 面数 = 12;
      let 通路列数 = 通路列数群[面数];
      let 解像度 = 解像度群[面数];
      let 方向数 = 方向数群[面数];
      let 面接続情報群 = 面接続情報群群[面数];
      let { 角度1, 角度2, 線分1, 線分3 } = 定数群[面数];
      // let 通路幅 = Math.cos(Math.PI / 方向数) * 径 / 通路列数;
      let 座標群 = {};
      let 隔壁臨界位置群 = [];
      let 隔壁厚距離1 = 0;
      let 隔壁厚距離2 = 0;
      let 通路厚距離1 = 0;
      let 通路厚距離2 = 0;
      let 通路厚角度 = 0;
      const 迷路座標群 = [];
      const 隔壁平面群 = [];
      const 通路平面群 = [];
      const 壁頂平面群 = [];
      const 通路群 = [];
      const 連絡口群 = [];
      const 管轄群 = [];
      const 拡張可能通路群 = [];

      const 座標取得 = (角度, 距離) => ({
        X: Math.sin(角度) * 距離,
        Y: Math.cos(角度) * 距離,
      });

      const 角度取得 = (座標X, 座標Y) => ((距離) => ({
        L: 距離,
        T: 距離 > 0 ? Math.acos(座標Y / 距離) * (座標X >= 0 ? 1 : -1) : 0,
      }))(Math.pow(座標X * 座標X + 座標Y * 座標Y, 1 / 2));

      const 基準Z = Math.sin(角度1) * (径 - 隔壁高) * -1;
      const 隔壁厚角度 = 隔壁厚 / 径;

      const 楕円交線座標取得 = (楕円A, 楕円B, 楕円C, 交線A, 交線B) => {
        const 係数A = 1 / 楕円A / 楕円A + 交線A * 交線A / 楕円B / 楕円B;
        const 係数B = 交線A * (交線B - 楕円C) / 楕円B / 楕円B;
        const 係数C = (交線B - 楕円C) * (交線B - 楕円C) / 楕円B / 楕円B - 1;
        const 交点X = (Math.pow(係数B * 係数B - 係数A * 係数C, 1 / 2) * (交線A >= 0 ? 1 : -1) - 係数B) / 係数A;
        const 交点Y = 交線A * 交点X + 交線B - 楕円C;
        const 交点L = Math.pow(交点X * 交点X + 交点Y * 交点Y, 1 / 2);

        return { X: 交点X, Y: 交点Y + 楕円C, L: 交点L };
      };

      const 隣接通路情報取得 = (列, 方向, 進捗, 前後, 内外) => {
        if (!列 && 中心空間確保) {
          const [_, [終端]] = 隣接隔壁情報取得('連絡口', 0, 方向, 進捗, 前後, 0);

          return [
            [{ 方向, 進捗: 0 }, { 方向, 進捗 }],
            [{ 方向: 終端.方向, 進捗: 0 }, 終端],
          ];
        }

        const 隣接方向座標取得 = ({ 角度Y, 楕円A, 楕円B, 交線B }, 交線A0, 交線B0, 前後係数) => {
          const 隣接軸T = Math.PI / 方向数 * 前後係数 * 2;
          const 隣接軸A = Math.tan(Math.PI / 2 - 隣接軸T);
          const 隣接交線X = 交線B0 / (隣接軸A - 交線A0);
          const 隣接交線Y = 隣接軸A * 隣接交線X;
          const 隣接交線B = Math.pow(隣接交線X * 隣接交線X + 隣接交線Y * 隣接交線Y, 1 / 2) * (交線B0 >= 0 ? -1 : 1);
          const 隣接交線A = Math.tan(Math.atan(交線A0) + 隣接軸T);
          const { X: 隣接交点X, Y: 隣接交点Y } = 楕円交線座標取得(楕円A, 楕円B, 交線B, 隣接交線A, 隣接交線B);
          const { L: 隣接距離Z, T: 隣接角度Z } = 角度取得(隣接交点X, 隣接交点Y);
          const 隣接角度Y = Math.asin(隣接交点X / 楕円A);
          const 隣接進捗 = (角度Y + 隣接角度Y) / 角度Y / 2;

          return [隣接交点X, 隣接交点Y, 隣接距離Z, 隣接角度Z, 方向 + 前後係数, 隣接進捗];
        };

        const 内外臨界位置群 = [隔壁臨界位置群[列 - 1][1], 隔壁臨界位置群[列][0]];
        const 角度Z0 = Math.PI * 2 / 方向数 * 方向;
        const 角度Y1 = 内外臨界位置群[内外].角度Y * (進捗 * 2 - 1);
        const { X: 座標X1, Y: 距離X1 } = 座標取得(角度Y1, 内外臨界位置群[内外].楕円A);
        const 座標Y1 = Math.sin(角度2) * 距離X1 + 内外臨界位置群[内外].交線B;
        const { L: 距離Z1, T: 角度Z1 } = 角度取得(座標X1, 座標Y1);
        const 距離Z2 = Math.pow(距離Z1 * 距離Z1 - 隔壁厚距離1 * 隔壁厚距離1, 1 / 2);
        const 角度Z2 = Math.acos(距離Z2 / 距離Z1) * [1, -1][前後];
        const 交線B0 = 隔壁厚距離1 / Math.sin(角度Z1 + 角度Z2) * [1, -1][前後];
        const 交線A1 = (座標Y1 - 交線B0) / 座標X1;
        const { X: 交点X1, Y: 交点Y1 } = (
          ({ 楕円A, 楕円B, 交線B }) => 楕円交線座標取得(楕円A, 楕円B, 交線B, 交線A1, 交線B0)
        )(内外臨界位置群[1 - 内外]);
        const 角度YK = Math.asin(交点X1 / 内外臨界位置群[1 - 内外].楕円A);
        const [座標X2, 座標Y2, 距離Z3, 角度Z3, 方向2, 進捗2] = Math.abs(角度YK) <= 内外臨界位置群[1 - 内外].角度Y
          ? (({ 楕円A, 角度Y }) => {
            const { L: 距離Z3, T: 角度Z3 } = 内外 ? 角度取得(交点X1, 交点Y1) : { L: 距離Z1, T: 角度Z1 };
            const 角度Y3 = Math.asin(交点X1 / 楕円A);
            const 進捗3 = (角度Y + 角度Y3) / 角度Y / 2;

            return [交点X1, 交点Y1, 距離Z3, 角度Z3, 方向, 進捗3];
          })(内外臨界位置群[1 - 内外])
          : 隣接方向座標取得(内外臨界位置群[1 - 内外], 交線A1, 交線B0, 角度YK > 0 ? 1 : -1, 'S');
        const 基準座標 = ((群) => 内外 ? 群.reverse() : 群)([[座標X1, 座標Y1], [座標X2, 座標Y2]]);
        const 基準情報 = ((群) => 内外 ? 群.reverse() : 群)([{ 方向, 進捗 }, { 方向: 方向2, 進捗: 進捗2 }]);
        const [距離ZS, 角度ZS] = [[距離Z1, 角度Z1], [距離Z3, 角度Z3]][内外];
        const 距離Z4 = Math.pow(距離ZS * 距離ZS - 通路厚距離1 * 通路厚距離1, 1 / 2);
        const 角度Z4 = Math.acos(距離Z4 / 距離ZS) * [-1, 1][前後];
        const 交線B4 = 通路厚距離1 / Math.sin(角度ZS + 角度Z4) * [-1, 1][前後];
        const 交線A4 = (基準座標[0][1] - 交線B4) / 基準座標[0][0];
        const { X: 交点X5, Y: 交点Y5 } = (
          ({ 楕円A, 楕円B, 交線B }) => 楕円交線座標取得(楕円A, 楕円B, 交線B, 交線A4, 交線B4 * -1)
        )(内外臨界位置群[0]);
        const 角度YC = Math.asin(交点X5 / 内外臨界位置群[0].楕円A);
        const [座標X5, 座標Y5, 距離Z5, 角度Z5, 方向5, 進捗5] = Math.abs(角度YC) <= 内外臨界位置群[0].角度Y
          ? (({ 楕円A, 角度Y }) => {
            const { L: 距離Z, T: 角度Z } = 角度取得(交点X5, 交点Y5);
            const 角度Y5 = Math.asin(交点X5 / 楕円A);
            const 進捗5 = (角度Y + 角度Y5) / 角度Y / 2;

            return [交点X5, 交点Y5, 距離Z, 角度Z, 基準情報[0].方向, 進捗5];
          })(内外臨界位置群[0])
          : 隣接方向座標取得(内外臨界位置群[0], 交線A4, 交線B4 * -1, 角度YC > 0 ? 1 : -1, 'E0');
        const 距離Z6 = Math.pow(距離Z5 * 距離Z5 - 隔壁厚距離1 * 隔壁厚距離1, 1 / 2);
        const 角度Z6 = Math.acos(距離Z6 / 距離Z5) * [-1, 1][前後];
        const 交線B6 = 隔壁厚距離1 / Math.sin(角度Z5 + 角度Z6) * [-1, 1][前後];
        const 交線A6 = (座標Y5 - 交線B6) / 座標X5;
        const { X: 交点X6, Y: 交点Y6 } = (
          ({ 楕円A, 楕円B, 交線B }) => 楕円交線座標取得(楕円A, 楕円B, 交線B, 交線A6, 交線B6)
        )(内外臨界位置群[1]);
        const 角度YS = Math.asin(交点X6 / 内外臨界位置群[1].楕円A);
        const [方向6, 進捗6] = Math.abs(角度YS) <= 内外臨界位置群[1].角度Y
          ? (({ 楕円A, 角度Y }) => {
            const { L: 距離Z, T: 角度Z } = 角度取得(交点X6, 交点Y6);
            const 角度Y6 = Math.asin(交点X6 / 楕円A);
            const 進捗6 = (角度Y + 角度Y6) / 角度Y / 2;

            return [方向5, 進捗6];
          })(内外臨界位置群[1])
          : ((情報群) => [情報群[4], 情報群[5]])(隣接方向座標取得(内外臨界位置群[1], 交線A6, 交線B6, 角度YS > 0 ? 1 : -1, 'E1'));

        return [基準情報, [{ 方向: 方向5, 進捗: 進捗5 }, { 方向: 方向6, 進捗: 進捗6 }]];
      };

      const 隣接隔壁情報取得 = (種別, 列, 方向, 進捗, 前後, 内外) => {
        const 線幅 = { 隔壁: 隔壁厚距離1, 連絡口: 通路厚距離1 }[種別];
        const 線角度 = { 隔壁: 隔壁厚角度, 連絡口: 通路厚角度 }[種別];
        const 種別係数 = { 隔壁: 1, 連絡口: 0 }[種別];
        const { 角度Y, 楕円A, 楕円B, 交線B } = 隔壁臨界位置群[列 + (内外 - 種別係数) * 種別係数][(内外 + 種別係数) % 2];
        const 角度Z0 = Math.PI * 2 / 方向数 * 方向;
        const 角度Y1 = 角度Y * (進捗 * 2 - 1);
        const { X: 座標X1, Y: 距離X1 } = 座標取得(角度Y1, 楕円A);
        const 座標Y1 = Math.sin(角度2) * 距離X1 + 交線B;
        const { L: 距離Z1, T: 角度Z1 } = 角度取得(座標X1, 座標Y1);
        const 距離Z2 = Math.pow(距離Z1 * 距離Z1 - 線幅 * 線幅, 1 / 2);
        const 角度Z2 = Math.acos(距離Z2 / 距離Z1) * [-1, 1][前後];
        const 交線B0 = 線幅 / Math.sin(角度Z1 + 角度Z2) * [-1, 1][前後];
        const 交線A1 = (座標Y1 - 交線B0) / 座標X1;

// console.log(`
// 角度Y: ${角度Y / Math.PI * 180}°
// 楕円A: ${楕円A * 100}
// 楕円B: ${楕円B * 100}
// 交線B: ${交線B * 100}
// 角度Z0: ${角度Z0 / Math.PI * 180}°
// 角度Y1: ${角度Y1 / Math.PI * 180}°
// 座標X1: ${座標X1 * 100}
// 座標Y1: ${座標Y1 * 100}
// 距離Z1: ${距離Z1 * 100}
// 距離Z2: ${距離Z2 * 100}
// 角度Z2: ${角度Z2 / Math.PI * 180}°
// 交線B0: ${交線B0 * 100}
// 交線A1: ${交線A1 * 100}
// `);
        return [0, 1].map((前後係数) => {
          const 隔壁情報群 = [0, 1].map((内外係数) => {
            if (列 - 種別係数 * (1 - 内外係数) < 0) {
              return { X: 0, Y: 0, 進捗: 0, 極角度: 0 };
            }
            const { 角度Y: 角度Y0, 楕円A, 楕円B, 交線B: 交線B1 } = 隔壁臨界位置群[列 - 種別係数 * (1 - 内外係数)][Math.abs(内外係数 - 種別係数)];
            const 交線B2 = 交線B0 * [1, -1][前後係数];
            const { X: 交点X3, Y: 交点Y3 } = 楕円交線座標取得(楕円A, 楕円B, 交線B1, 交線A1, 交線B2);
            const { L: 距離Z3, T: 角度Y3 } = 角度取得(交点X3, 交点Y3);
            const 角度X3 = Math.asin(距離Z3 / 線分3);
            const 角度Y4 = Math.asin(交点X3 / 楕円A);
            const 座標X5 = 交点X3 - Math.sin(角度Z2) * 線幅;
            const 座標Y5 = 交点Y3 - Math.cos(角度Z2) * 線幅;
            const 距離Z5 = Math.pow(座標X5 * 座標X5 + 座標Y5 * 座標Y5, 1 / 2);
            const 角度X5 = Math.asin(距離Z5 / 線分3);
            const 進捗1 = (!前後係数 && 内外係数 === 内外) ? 進捗 : ((角度Y0 + 角度Y4) / 角度Y0 / 2);

// console.log(`前後係数: ${前後係数}----------
// 角度Y0: ${角度Y0 / Math.PI * 180}°
// 楕円A: ${楕円A * 100}
// 楕円B: ${楕円B * 100}
// 交線B: ${交線B * 100}
// 交線B1: ${交線B1 * 100}
// 交線B2: ${交線B2 * 100}
// 交点X3: ${交点X3 * 100}
// 交点Y3: ${交点Y3 * 100}
// 距離Z3: ${距離Z3 * 100}
// 角度Y3: ${角度Y3 / Math.PI * 180}°
// 角度X3: ${角度X3 / Math.PI * 180}°
// 角度Y4: ${角度Y4 / Math.PI * 180}°
// 座標X5: ${座標X5 * 100}
// 座標Y5: ${座標Y5 * 100}
// 距離Z5: ${距離Z5 * 100}
// 角度X5: ${角度X5 / Math.PI * 180}°
// 進捗1: ${進捗1}
// `);
            return Math.abs(角度Y4) <= 角度Y0
              ? { X: 角度X3, Y: 角度Y3 + 角度Z0, 方向, 進捗: 進捗1, 極角度: 角度X5 }
              : (() => {
                const 相対係数 = 角度Y4 > 0 ? 1 : -1;
                const 隣接軸T = Math.PI / 方向数 * 相対係数 * 2;
                const 隣接軸A = Math.tan(Math.PI / 2 - 隣接軸T);
                const 隣接交線X0 = 交線B2 / (隣接軸A - 交線A1);
                const 隣接交線Y0 = 隣接軸A * 隣接交線X0;
                const 隣接交線B0 = Math.pow(隣接交線X0 * 隣接交線X0 + 隣接交線Y0 * 隣接交線Y0, 1 / 2) * (交線B2 >= 0 ? -1 : 1);
                const 隣接交線A0 = Math.tan(Math.atan(交線A1) + 隣接軸T);

                const { X: 隣接交点X3, Y: 隣接交点Y3 } = 楕円交線座標取得(楕円A, 楕円B, 交線B1, 隣接交線A0, 隣接交線B0);
                const { L: 隣接距離Z3, T: 隣接角度Y3 } = 角度取得(隣接交点X3, 隣接交点Y3);
                const 隣接角度X3 = Math.asin(隣接距離Z3 / 線分3);
                const 隣接角度Y4 = Math.asin(隣接交点X3 / 楕円A);
                const 隣接進捗1 = (角度Y0 + 隣接角度Y4) / 角度Y0 / 2;

// console.log(`<>: ----------
// 隣接軸T: ${隣接軸T / Math.PI * 180}°
// 隣接軸A: ${隣接軸A * 100}
// 隣接交線X0: ${隣接交線X0 * 100}
// 隣接交線Y0: ${隣接交線Y0 * 100}
// 隣接交線B0: ${隣接交線B0 * 100}
// 隣接交線A0: ${隣接交線A0 * 100}
// 隣接交点X3: ${隣接交点X3 * 100}
// 隣接交点Y3: ${隣接交点Y3 * 100}
// 隣接距離Z3: ${隣接距離Z3 * 100}
// 隣接角度Y3: ${隣接角度Y3 / Math.PI * 180}°
// 隣接角度X3: ${隣接角度X3 / Math.PI * 180}°
// 隣接角度Y4: ${隣接角度Y4 / Math.PI * 180}°
// 隣接進捗1: ${隣接進捗1}
// `);
                return { X: 隣接角度X3, Y: 隣接角度Y3 + 隣接軸T + 角度Z0, 方向: 方向 + 相対係数, 進捗: 隣接進捗1, 極角度: 角度X5 };
              })();
          }, [[], 0]);

          const 中心角度 = 隔壁情報群.reduce((角度, { 極角度 }) => 角度 + 極角度, 0) / 2;
          const 角度Z3 = 角度Z1 + 角度Z2 + Math.PI / [[-2, 2], [2, -2]][前後][前後係数] * [-1, 1][種別係数];
          const { X: 座標X0, Y: 座標Y0 } = 座標取得(角度Z3, 線分3);
          const { X: 距離Z6, Y: 座標Z6 } = 座標取得(中心角度, 線幅);
          const { X: 座標X6, Y: 座標Y6 } = 座標取得(角度Z1 + 角度Z2, 距離Z6);
          const { L: 距離Z7, T: 角度Z7 } = 角度取得(座標X0 - 座標X6, 座標Y0 - 座標Y6);
          const 距離X7 = Math.pow(座標Z6 * 座標Z6 + 距離Z7 * 距離Z7, 1 / 2);
          const 角度X7 = Math.asin(座標Z6 / 距離X7) + Math.PI / 2;
// console.log(`
// 中心角度: ${中心角度 / Math.PI * 180}°
// 角度Z3: ${角度Z3 / Math.PI * 180}°
// 座標X0: ${座標X0 * 100}
// 座標Y0: ${座標Y0 * 100}
// 距離Z6: ${距離Z6 * 100}
// 座標Z6: ${座標Z6 * 100}
// 座標X6: ${座標X6 * 100}
// 座標Y6: ${座標Y6 * 100}
// 距離Z7: ${距離Z7 * 100}
// 角度Z7: ${角度Z7 / Math.PI * 180}°
// 距離X7: ${距離X7 * 100}
// 角度X7: ${角度X7 / Math.PI * 180}°
// `);

          return 隔壁情報群.map(({ X, Y, 方向, 進捗 }) => ({ X, Y, HX: 角度X7, HY: 角度Z7 + 角度Z0, 方向, 進捗 }));
        });
      };

      const 隣接外端連絡口情報取得 = (面, 方向, 進捗, 前後) => {
        const { 角度Y, 交線B } = 隔壁臨界位置群[通路列数 - 1][0];
        const 連絡口比率 = 通路厚角度 / 角度Y;
        const [接続面, 接続方向] = 面接続情報群[面][方向];
        const 角度Z01 = Math.PI * 2 / 方向数 * 方向;
        const 角度Z02 = Math.PI * 2 / 方向数 * 接続方向;
        const 終始進捗群 = [進捗, 進捗 + 連絡口比率 * [-1, 1][前後]];
        const 座標情報群 = 終始進捗群.map((終始進捗, 終始) => {
          const [{ X: 角度X1, Y: 角度Z1 }] = 列壁座標取得(通路列数 - 1, 0, 0, 終始進捗);
          const 角度Y1 = 角度Y * (終始進捗 * 2 - 1);
          const 角度Y2 = 角度Y1 + Math.PI / (前後 === 終始 ? 2 : -2);
          const { X: 座標X1, Y: 距離X1 } = 座標取得(角度Y2, 1);
          const 座標Y1 = Math.sin(角度2) * 距離X1;
          const { L: 距離Z1, T: 角度Z2 } = 角度取得(座標X1, 座標Y1);
          const 角度X2 = ((角度) => 座標Y1 >= 0 ? 角度 : Math.PI - 角度)(Math.asin(距離Z1));

          return { X: 角度X1, Y: 角度Z1, HX: 角度X2, HY: 角度Z2, 進捗: 終始進捗 };
        });

        return [
          座標情報群.map((情報) => ({ ...情報, Y: 角度Z01 + 情報.Y, HY: 角度Z01 + 情報.HY, 方向 })),
          座標情報群.map((情報) => ({ ...情報, Y: 角度Z02 - 情報.Y, HY: 角度Z02 - 情報.HY, 方向: 接続方向, 進捗: 1 - 情報.進捗 })).reverse(),
        ];
      };

      const 面座標変換 = (面, 座標) => {
        if (面 === 0) {
          return { ...座標 };
        }
        if (面 === 面数 - 1 && 面数 !== 4) {
          return { ...座標, X: 座標.X + Math.PI, Y: 座標.Y * -1 };
        }
        if (面数 === 20) {
          const { R, X, Y } = 座標;
          const { X: 距離Z0, Y: 座標Z0 } = 座標取得(X, 1);
          const { X: 座標X0, Y: 座標Y0 } = (({ X, Y }) => ({ X: X * (面 < 面数 / 2 ? 1 : -1), Y }))(座標取得(Y, 距離Z0));
          if ([1, 2, 3, 16, 17, 18].includes(面)) {
            const { L: 距離X0, T: 角度X0 } = 角度取得(座標Y0, 座標Z0);
            const 角度X1 = 角度X0 - 角度2 * 2;
            const { X: 座標Y1, Y: 座標Z1 } = 座標取得(角度X1, 距離X0);
            const { L: 距離Z1, T: 角度Z1 } = 角度取得(座標X0, 座標Y1);
            const 角度Z2 = 角度Z1 + Math.PI * (1 + 2 / 方向数 * ((面 - 1) % 方向数));
            const { L: 距離X2, T: 角度X2 } = 角度取得(距離Z1, 座標Z1);

            return { R, X: 角度X2 + (面 > 面数 / 2 ? Math.PI : 0), Y: 角度Z2 };
          } else {
            const { T: 角度Z0 } = 角度取得(座標X0, 座標Y0);
            const 角度Z1 = 角度Z0 + Math.PI / ([4, 5, 6, 10, 11, 12].includes(面) ? 6 : -6);
            const { X: 座標X1, Y: 座標Y1 } = 座標取得(角度Z1, 距離Z0);
            const { L: 距離Y1, T: 角度Y1 } = 角度取得(座標X1, 座標Z0);
            const 角度Y2 = 角度Y1 + 角度2 * ([4, 5, 6, 10, 11, 12].includes(面) ? 1 : -1);
            const { X: 座標X2, Y: 座標Z2 } = 座標取得(角度Y2, 距離Y1);
            const { L: 距離X2, T: 角度X2 } = 角度取得(座標Y1, 座標Z2);
            const 角度Y0 = Math.asin(線分1 / 線分3)
            const 角度X3 = 角度X2 - 角度1 - 角度Y0;
            const { X: 座標Y3, Y: 座標Z3 } = 座標取得(角度X3, 距離X2);
            const { L: 距離Z3, T: 角度Z3 } = 角度取得(座標X2, 座標Y3);
            const { T: 角度X4 } = 角度取得(距離Z3, 座標Z3);
            const 角度Z4 = 角度Z3 + Math.PI * 2 / 3 * ([4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16].includes(面) ? (面 - 4) : (4 - 面));

            return { R, X: 角度X4 + (面 < 面数 / 2 ? 0 : Math.PI), Y: 角度Z4 };
          }
        }
        const { R, X, Y } = 座標;
        const { X: 距離R0, Y: 座標Z0 } = 座標取得(X, 1);
        const { X: 座標X0, Y: 座標Y0 } = (({ X, Y }) => ({ X: X * (面 > 方向数 ? -1 : 1), Y }))(座標取得(Y, 距離R0));
        const { L: 距離X0, T: 角度X0 } = 角度取得(座標Y0, 座標Z0);
        const 角度X1 = 角度X0 - 角度2 * 2;
        const { X: 座標Y1, Y: 座標Z1 } = 座標取得(角度X1, 距離X0);
        const { L: 距離R1, T: 角度Z1 } = 角度取得(座標X0, 座標Y1);
        const 角度Z2 = 角度Z1 + Math.PI * (1 + 2 / 方向数 * ((面 - 1) % 方向数));
        const { L: 距離X2, T: 角度X2 } = 角度取得(距離R1, 座標Z1);

        return { R, X: 角度X2 + (面 > 方向数 ? Math.PI : 0), Y: 角度Z2 };
      };

      const 列壁座標取得 = (列, 方向, 表裏, 進捗, 法線取得 = 0) => {
        const { 角度X, 角度Y, 楕円A, 交線B } = 隔壁臨界位置群[列][表裏];
        const 角度Z1 = Math.PI * 2 / 方向数 * 方向;
        const 角度Y1 = 角度Y * (進捗 * 2 - 1);
        const { X: 座標X1, Y: 距離X1 } = 座標取得(角度Y1, 楕円A);
        const 座標Y1 = Math.sin(角度2) * 距離X1 + 交線B;
        const { L: 距離Z1, T: 角度Z2 } = 角度取得(座標X1, 座標Y1);
        const 角度X2 = Math.asin(距離Z1 / 線分3);
        const 座標 = { X: 角度X2, Y: 角度Z2 + 角度Z1, R: 径 };
        const 法線座標 = 法線取得 && (() => {
          const 角度Z3 = 角度Y1 + Math.PI * [1, -1][表裏];
          const 距離Z3 = Math.sin(角度2 - 角度X) * 線分3;
          const { X: 座標X3, Y: 座標Y3 } = 座標取得(角度Z3, 距離Z3);
          const { X: 座標Z3, Y: 距離X3 } = 座標取得(角度2 - 角度X, 線分3);
          const { X: 座標Y4, Y: 座標Z4 } = 座標取得(角度2 - Math.PI / 2, 距離X3);
          const 座標Y5 = 座標Y3 * Math.sin(角度2);
          const { L: 距離Z5, T: 角度Z5 } = 角度取得(座標X3, 座標Y4 + 座標Y5);
          const 角度X5 = Math.asin(距離Z5 / 線分3);

          return { X: 角度X5, Y: 角度Z5 + 角度Z1, R: 径 };
        })();

        return [座標, 法線座標];
      };

      const 通路生成 = (面, 列, 通路要素) => ({ 面, 列, 種別: '通路', 末端情報: [true, true], ...通路要素 });

      const 隔壁生成 = (面, 列, 隔壁要素) => ({ 面, 列, 種別: '隔壁', 管轄: null, 末端情報: [false, false], ...隔壁要素 });

      const 末端調整 = (情報) => {
        const 位置 = 情報.位置 || 情報;
        const [[{ 方向: 始端方向, 進捗: 始端進捗 }], [{ 方向: 終端方向, 進捗: 終端進捗 }]] = 位置;
        // const 共通加算方向数 = ((動, 静) => 動 >= 静 ? (静 * -1) : (動 < 0) ? 静 : 0)(始端方向, 方向数);
        // 位置.forEach((前後位置, 前後) => {
        //   前後位置[0].方向 += 共通加算方向数;
        //   前後位置[1].方向 += 共通加算方向数;
        // });
        // const 終端加算方向数 = ((動01, 動02, 動11, 動12, 静) => 動01 + 動02 > 動11 + 動12 ? 静 : 0)(始端方向, 始端進捗, 終端方向, 終端進捗, 方向数);
        // 位置[1][0].方向 += 終端加算方向数;
        // 位置[1][1].方向 += 終端加算方向数;
        const 余剰方向数 = Math.floor(始端方向 / 方向数) * 方向数;
        位置.forEach((前後位置, 前後) => {
          前後位置[0].方向 -= 余剰方向数;
          前後位置[1].方向 -= 余剰方向数;
        });
        const 加算方向数 = 始端方向 + 始端進捗 > 終端方向 + 終端進捗 ? 方向数 : 0;
        位置[1][0].方向 += 加算方向数;
        位置[1][1].方向 += 加算方向数;

        return 情報;
      };

      const 通路合成 = (通路1, 通路2, 方向指示 = null) => {
        const ddd = re.length === 1 && false;
        const ccc = (...B) => ddd && console.log(...B);
        const 始端 = 通路1.位置[0][0].方向 + 通路1.位置[0][0].進捗;
        const 終端 = 通路1.位置[1][0].方向 + 通路1.位置[1][0].進捗;
        const 始端隔壁 = 隣接隔壁情報取得('隔壁', 通路2.列, 通路2.位置[0][0].方向, 通路2.位置[0][0].進捗, 0, 0);
        const 終端隔壁 = 隣接隔壁情報取得('隔壁', 通路2.列, 通路2.位置[1][0].方向, 通路2.位置[1][0].進捗, 1, 0);
        const 隔壁始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(始端隔壁[1][0]);
        const 隔壁終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(終端隔壁[1][0]);

        if (通路1 === 通路2) {
          const 拡張通路位置 = [...通路1.位置];
          if (方向指示 === '始端' && 隔壁終端 >= 始端) {
            拡張通路位置[0] = ((終端) => 終端.map(({ 方向, 進捗 }) => ({ 方向: 方向 - 方向数, 進捗 })))(終端隔壁[1]);
            const 拡張通路 = 末端調整({ ...通路1, 位置: 拡張通路位置, 末端情報: [false, false] });
            ccc('終端隔壁 <><>', JSON.stringify(終端隔壁));

            return [拡張通路, 拡張通路, 末端調整(隔壁生成(通路1.面, 通路1.列, { 位置: 終端隔壁 }))];
          }
          if (方向指示 === '終端' && 隔壁始端 <= 終端) {
            拡張通路位置[1] = ((始端) => 始端.map(({ 方向, 進捗 }) => ({ 方向: 方向 + 方向数, 進捗 })))(始端隔壁[1]);
            const 拡張通路 = 末端調整({ ...通路1, 位置: 拡張通路位置, 末端情報: [false, false] });

            return [拡張通路, 拡張通路, 末端調整(隔壁生成(通路1.面, 通路1.列, { 位置: 始端隔壁.reverse() }))];
          }
        } else {
          try {
            ([-1, 0, 1]).forEach((加算係数) => {
              if (方向指示 === '始端' && 加算係数 * 方向数 + 始端 < 隔壁終端 && 加算係数 * 方向数 + 終端 > 隔壁終端) {
                const 終端位置 = 終端隔壁.map((前後位置) => 前後位置.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })));
                const 合成通路01 = 末端調整({ ...通路2, 位置: [通路2.位置[0], 終端位置[0]] });
                const 合成通路02 = 末端調整({ ...通路1, 位置: [終端位置[1], 通路1.位置[1].map(({ 方向, 進捗 }) => ({ 方向: 方向 + 加算係数 * 方向数, 進捗 }))] });
                throw [合成通路01, 合成通路02, 末端調整(隔壁生成(通路1.面, 通路1.列, { 位置: 終端隔壁 }))];
              }
              if (方向指示 === '終端' && 加算係数 * 方向数 + 終端 > 隔壁始端 && 加算係数 * 方向数 + 始端 < 隔壁始端) {
                const 始端位置 = 始端隔壁.map((前後位置) => 前後位置.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })));
                const 合成通路11 = 末端調整({ ...通路1, 位置: [通路1.位置[0].map(({ 方向, 進捗 }) => ({ 方向: 方向 + 加算係数 * 方向数, 進捗 })), 始端位置[1]] });
                const 合成通路12 = 末端調整({ ...通路2, 位置: [始端位置[0], 通路2.位置[1]] });
                throw [合成通路11, 合成通路12, 末端調整(隔壁生成(通路1.面, 通路1.列, { 位置: 始端隔壁.reverse() }))];
              }
              if (!方向指示 && 加算係数 * 方向数 + 始端 < 隔壁終端 && 加算係数 * 方向数 + 終端 > 隔壁始端) {
                const { 位置: [合成始端, _11], 末端情報: [末端始端, _12] } = 通路2.位置[0][0].方向 + 通路2.位置[0][0].進捗 > 始端 + 加算係数 * 方向数 ? 通路1 : 通路2;
                const { 位置: [_21, 合成終端], 末端情報: [_22, 末端終端] } = 通路2.位置[1][0].方向 + 通路2.位置[1][0].進捗 < 終端 + 加算係数 * 方向数 ? 通路1 : 通路2;
                throw 末端調整({ ...通路1, 位置: [合成始端, 合成終端], 末端情報: [末端始端, 末端終端] });
              }
            });
          } catch (合成結果) {
            return 合成結果;
          }
        }

        return null;
      };

      const 管轄合成 = (管轄1, 管轄2) => {
        const 上位管轄 = Math.min(管轄群[管轄1], 管轄群[管轄2]);
        const 下位管轄 = Math.max(管轄群[管轄1], 管轄群[管轄2]);
        管轄群.forEach((管轄, 番号) => {
          if (管轄 === 下位管轄) {
            管轄群[番号] = 上位管轄;
          }
        });
      };

      const 拡張可能壁群取得 = (拡張通路) => {
        const 位置変換 = (位置, 前後係数) => 位置.map((群) => 群.map((情報) => ({ ...情報, 方向: 情報.方向 + 方向数 * 前後係数 })));

        if (拡張通路.列 === 0) {
          const { 方向, 進捗 } = 連絡口群[拡張通路.面][0][0][1][0];
          拡張通路 = 末端調整({ ...拡張通路, 位置: [
            [{ 方向, 進捗: 0 }, { 方向, 進捗 }],
            [{ 方向: 方向 + 方向数, 進捗: 0 }, { 方向: 方向 + 方向数, 進捗 }],
          ]});
        }

        return ['内端', '外端'].reduce((拡張可能壁群, 内外, 内外係数) => {
          const ddd = !内外係数 && false;
          const ccc = (...B) => ddd && console.log(...B);
          ccc(`面${拡張通路.面} 列${拡張通路.列} ${通路群[拡張通路.面][拡張通路.列].findIndex((通路) => 通路 === 拡張通路)} ${内外}========================`);
          拡張可能壁群[内外] = [];
          if (!内外係数 && !拡張通路.列) {
            return 拡張可能壁群;
          }
          if (内外係数 && 拡張通路.列 === 通路列数 - 1) {
            return { ...拡張可能壁群, 外端: 拡張可能隣接外端壁群取得(拡張通路) };
          }

          const 連絡口列 = 拡張通路.列 - 1 + 内外係数;
          const 拡張末端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張通路.位置[1][内外係数]);
          const 比較通路群 = ((情報群) => [
            ((情報) => ({ ...情報, 位置: 位置変換(情報.位置, -1) }))(情報群[情報群.length - 1]),
            ...情報群,
            ...情報群.map((情報) => ({ ...情報, 位置: 位置変換(情報.位置, 1) })),
          ])(通路群[拡張通路.面][拡張通路.列 + [-1, 1][内外係数]]);
          const 比較連絡口群 = ((情報群) => [
            位置変換(情報群[情報群.length - 1], -1),
            ...情報群,
            ...情報群.map((情報) => 位置変換(情報, 1)),
          ])(連絡口群[拡張通路.面][拡張通路.列 - 1 + 内外係数]);

          const 拡張末端連絡口取得 = (位置, 前後係数, 末端内外係数) => {
            ccc('ITTTTTTTTTTTT:', 位置);
            const 拡張連絡口 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('連絡口', 連絡口列, 方向, 進捗, 1 - 前後係数, 末端内外係数))(位置);
            ccc('LTTTTTTTTTTTT:', 拡張連絡口);
            const 末端隔壁 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('隔壁', 連絡口列, 方向, 進捗, 前後係数, 1))(拡張連絡口[0][0]);
            ccc('KTTTTTTTTTTTT:', 末端隔壁);
            const 末端隔壁位置 = (({ 方向, 進捗 }) => 方向 + 進捗)(末端隔壁[1][1]);
            ccc('KITTTTTTTTTTTT:', 末端隔壁位置);
            const 隣接連絡口 = 比較連絡口群.find(([[値1], [値2]]) => 値1.方向 + 値1.進捗 < 末端隔壁位置 && 値2.方向 + 値2.進捗 > 末端隔壁位置);
            ccc('LLTTTTTTTTTTTT:', 隣接連絡口);
            if (隣接連絡口) {
              const 隣接隔壁 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('隔壁', 連絡口列, 方向, 進捗, 1 - 前後係数, 1))(隣接連絡口[1 - 前後係数][0]);
            ccc('LKTTTTTTTTTTTT:', 隣接隔壁);

              return (({ 方向, 進捗 }) => 隣接隔壁情報取得('連絡口', 連絡口列, 方向, 進捗, 1 - 前後係数, 0))(隣接隔壁[1][1]);
            }

            return 拡張連絡口;
          };

          try {
            const 初期拡張連絡口 = 拡張末端連絡口取得(拡張通路.位置[0][内外係数], 0, 1 - 内外係数);
            const 末期拡張連絡口 = 拡張末端連絡口取得(拡張通路.位置[1][内外係数], 1, 1 - 内外係数);
            const 初期拡張先通路 = (({ 方向, 進捗 }) => 隣接通路情報取得(拡張通路.列 - 1 + 内外係数, 方向, 進捗, 1, 1 - 内外係数))(初期拡張連絡口[0][内外係数]);
            const 末期終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(末期拡張連絡口[0][内外係数]);
            比較通路群.reduce(([拡張連絡口, 拡張先通路, 仮定拡張連絡口, 拡張先管轄], 比較通路) => {
              ccc(`==========${比較通路.位置[0][1 - 内外係数].方向}:${比較通路.位置[0][1 - 内外係数].進捗}`);
              const 拡張連絡口終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張連絡口[1][内外係数]);
              if (拡張連絡口終端 > 拡張末端) {
                ccc(`処理終了(-): ${拡張連絡口終端} > ${拡張末端}`);
                throw '処理終了';
              }
              const 拡張先始端隔壁 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('隔壁', 比較通路.列, 方向, 進捗, 0, 1 - 内外係数))(比較通路.位置[0][1 - 内外係数]);
              const 拡張先終端隔壁 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('隔壁', 比較通路.列, 方向, 進捗, 1, 1 - 内外係数))(比較通路.位置[1][1 - 内外係数]);
              const 管轄一致 = 管轄群[拡張通路.管轄] === 管轄群[比較通路.管轄];
              const 拡張連絡口始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張連絡口[0][内外係数]);
              const 比較始端 = (({ 方向, 進捗 }) => 方向 + 進捗)((管轄一致 ? 拡張先始端隔壁[1] : 比較通路.位置[0])[1 - 内外係数]);
              const 拡張先終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張先通路[1][1 - 内外係数]);
              if (末期終端 <= 比較始端) {
                if (拡張先終端 <= 末期終端) {
                  ccc(`追加(+): ${拡張先終端} <= ${末期終端}`, 末期拡張連絡口);
                  拡張可能壁群[内外].push([拡張連絡口[0][1 - 内外係数], 末期拡張連絡口[1][1 - 内外係数]]);
                }
                ccc(`処理終了(+)`);
                throw '処理終了';
              }
              const 比較終端 = (({ 方向, 進捗 }) => 方向 + 進捗)((管轄一致 ? 拡張先終端隔壁[1] : 比較通路.位置[1])[1 - 内外係数]);
              if (管轄一致 || 比較通路.種別 === '隔壁') {
                ccc(`管轄一致(${比較通路.種別})`);
                if (拡張連絡口始端 >= 比較終端) {
                  拡張先通路 = (({ 方向, 進捗 }) => 隣接通路情報取得(比較通路.列, 方向, 進捗, 1, 0))(拡張先終端隔壁[1][0]);
                  ccc(`拡張先通路(@) >>> ${((値) => `${値.方向}:${値.進捗}`)(拡張先通路[0][1 - 内外係数])}`);
                  ccc(`>>> 拡張先通路(@) ${((値) => `${値.方向}:${値.進捗}`)(拡張先通路[1][1 - 内外係数])}`);
                } else {
                  if (拡張先終端 <= 比較始端) {
                    const 比較終端連絡口 = 拡張末端連絡口取得(拡張先始端隔壁[1][1 - 内外係数], 1, 内外係数);
                    const 比較終端連絡口始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(比較終端連絡口[1][1 - 内外係数]);
                    if (拡張連絡口始端 <= 比較終端連絡口始端) {
                      ccc(`追加(@): ${拡張連絡口始端} <= ${比較終端連絡口始端}`);
                      拡張可能壁群[内外].push([拡張連絡口[0][1 - 内外係数], 比較終端連絡口[1][1 - 内外係数]]);
                    }
                  }
                  拡張連絡口 = 拡張末端連絡口取得(拡張先終端隔壁[1][1 - 内外係数], 0, 内外係数);
                  拡張先通路 = (({ 方向, 進捗 }) => 隣接通路情報取得(比較通路.列, 方向, 進捗, 1, 1 - 内外係数))(拡張連絡口[0][内外係数]);
                  ccc(`拡張連絡口(*) >>> ${((値) => `${値.方向}:${値.進捗}`)(拡張連絡口[0][内外係数])}`);
                  ccc(`>>> 拡張連絡口(*) ${((値) => `${値.方向}:${値.進捗}`)(拡張連絡口[1][内外係数])}`);
                  ccc(`拡張先通路(*) >>> ${((値) => `${値.方向}:${値.進捗}`)(拡張先通路[0][1 - 内外係数])}`);
                  ccc(`>>> 拡張先通路(*) ${((値) => `${値.方向}:${値.進捗}`)(拡張先通路[1][1 - 内外係数])}`);
                }
              } else {
                if (管轄群[比較通路.管轄] === 拡張先管轄 && (拡張通路.列 || 内外係数)) {
                  const 仮定始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(仮定拡張連絡口[0][内外係数]);
                  const 仮定終端 = (({ 方向, 進捗 }) => 方向 + 進捗)(仮定拡張連絡口[1][内外係数]);
                  const 拡張先始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張先始端隔壁[1][1 - 内外係数]);
                  if (仮定終端 > 拡張先始端) {
                    if (拡張先終端 <= 拡張先始端) {
                      const 仮定始端連絡口 = 拡張末端連絡口取得(拡張先始端隔壁[1][1 - 内外係数], 1, 内外係数);
                      // const 拡張連絡口始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(拡張連絡口[0][1 - 内外係数]);
                      // const 仮定始端連絡口始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(仮定始端連絡口[1][1 - 内外係数]);
                      const 仮定始端連絡口始端 = (({ 方向, 進捗 }) => 方向 + 進捗)(仮定始端連絡口[1][内外係数]);
                      if (拡張連絡口始端 <= 仮定始端連絡口始端) {
                        ccc(`追加(*): ${拡張連絡口始端} <= ${仮定始端連絡口始端}`);
                        拡張可能壁群[内外].push([拡張連絡口[0][1 - 内外係数], 仮定始端連絡口[1][1 - 内外係数]]);
                      }
                    }
                    // if (拡張連絡口始端 < 仮定終端) {
                    if (拡張連絡口始端 < 仮定始端) {
                      ccc(`拡張連絡口始端 ??? ${拡張連絡口始端} < ${仮定終端}`);
                      拡張連絡口 = 仮定拡張連絡口;
                      ccc(`拡張連絡口(:) >>> ${((値) => `${値.方向}:${値.進捗}`)(拡張連絡口[0][内外係数])}`);
                      ccc(`>>> 拡張連絡口(:) ${((値) => `${値.方向}:${値.進捗}`)(拡張連絡口[1][内外係数])}`);
                    }
                  }
                }
                拡張先通路 = (({ 方向, 進捗 }) => 隣接通路情報取得(比較通路.列, 方向, 進捗, 1, 0))(比較通路.位置[0][0]);
                仮定拡張連絡口 = (({ 方向, 進捗 }) => 隣接隔壁情報取得('連絡口', 連絡口列, 方向, 進捗, 1, 内外係数))(拡張先終端隔壁[1][1 - 内外係数]);
                ccc(`拡張先通路(#) >>> ${((値) => `${値.方向}:${値.進捗}`)(拡張先通路[0][1 - 内外係数])}`);
                ccc(`>>> 拡張先通路(#) ${((値) => `${値.方向}:${値.進捗}`)(拡張先通路[1][1 - 内外係数])}`);
                ccc(`仮定拡張連絡口(#) >>> ${((値) => `${値.方向}:${値.進捗}`)(仮定拡張連絡口[0][内外係数])}`);
                ccc(`>>> 仮定拡張連絡口(#) ${((値) => `${値.方向}:${値.進捗}`)(仮定拡張連絡口[1][内外係数])}`);
              }

              return [拡張連絡口, 拡張先通路, 仮定拡張連絡口, 管轄群[比較通路.管轄]];
            }, [初期拡張連絡口, 初期拡張先通路, null, null]);
          } catch (_) {
            ccc(_);
          }

          return 拡張可能壁群;
        }, {});
      };

      const 拡張可能隣接外端壁群取得 = (拡張通路) => {
        const DDD = 0;
        const ccc = (...B) => DDD && console.log(...B);
        const 位置変換 = (位置, 前後係数) => 位置.map((群) => 群.map((情報) => ({ ...情報, 方向: 情報.方向 + 方向数 * 前後係数 })));

        const 拡張可能壁群 = [];
        const [[_1, { 方向: 始端方向, 進捗: 始端進捗 }], [_2, { 方向: 終端方向, 進捗: 終端進捗 }]] = 拡張通路.位置;
        const 外端通路比率 = 通路厚角度 / 隔壁臨界位置群[通路列数 - 1][0].角度Y;
        const 通路始端臨界 = ((情報) => 情報[1][1].進捗)(隣接通路情報取得(通路列数 - 1, 0, 1, 0, 1));

        Array(終端方向 - 始端方向 + 1).fill(null).forEach((_, 方向係数) => {
          const 方向 = 始端方向 + 方向係数;
          if (!面接続情報群[拡張通路.面]?.[方向 % 方向数]) console.log(始端方向, 方向係数, 拡張通路);
          const [接続面, 接続方向] = 面接続情報群[拡張通路.面][(方向 + 方向数) % 方向数];
          ccc(`方向${方向}----------(面${接続面} 方向${接続方向})`);
          const 拡張始端進捗 = 方向 > 始端方向 ? 0 : 始端進捗;
          const 拡張終端進捗 = 方向 < 終端方向 ? 1 : 終端進捗;
          const 比較通路群 = [];
          通路群[接続面][通路列数 - 1].forEach((通路) => {
            const [[_1, { 方向: 方向1, 進捗: 進捗1 }], [_2, { 方向: 方向2, 進捗: 進捗2 }]] = 通路.位置;
            Array(方向2 - 方向1 + 1).fill(null).forEach((_, 比較方向係数) => {
              const 比較方向 = 方向1 + 比較方向係数;
              if (比較方向 % 方向数 === 接続方向) {
                const 比較通路始端 = 比較方向 === 方向2 ? 1 - 進捗2 : 0;
                const 比較通路終端 = 比較方向 === 方向1 ? 1 - 進捗1 : 1;
                const [比較始端, 比較終端] = 通路.種別 === '隔壁' || 管轄群[拡張通路.管轄] !== 管轄群[通路.管轄]
                  ? [比較通路始端, 比較通路終端]
                  : [
                      (([_1, [_2, 値]]) => 値.方向 - 比較方向 + 値.進捗)(隣接隔壁情報取得('隔壁', 通路列数 - 1, 比較方向, 比較通路始端, 0, 0)),
                      (([_1, [_2, 値]]) => 値.方向 - 比較方向 + 値.進捗)(隣接隔壁情報取得('隔壁', 通路列数 - 1, 比較方向, 比較通路終端, 1, 0)),
                  ];
                比較通路群.push({ ...通路, 位置: [比較始端, 比較終端] });
              }
            });
          });

          try {
            const 初期拡張先通路 = 隣接通路情報取得(通路列数 - 1, 方向, 拡張始端進捗, 1, 1);
            比較通路群.sort((A, B) => A.位置[0] - B.位置[0]);
            const [拡張連絡口位置, 拡張先通路] = 比較通路群.reduce(([拡張連絡口位置, 拡張先通路, 仮定拡張連絡口位置, 拡張先管轄], 比較通路) => {
              ccc('比較通路', 比較通路);
              if (拡張連絡口位置 + 外端通路比率 > 拡張終端進捗) {
                ccc(`処理終了(${拡張連絡口位置} + ${外端通路比率} > ${拡張終端進捗})`);
                throw '処理終了';
              }
              const 拡張先始端隔壁 = 隣接隔壁情報取得('隔壁', 通路列数 - 1, 方向, 比較通路.位置[0], 0, 1);
              const 拡張先終端隔壁 = 隣接隔壁情報取得('隔壁', 通路列数 - 1, 方向, 比較通路.位置[1], 1, 1);
              const 管轄一致 = 管轄群[拡張通路.管轄] === 管轄群[比較通路.管轄];
              const 拡張先終端 = ((値) => 値.方向 - 方向 + 値.進捗)(拡張先通路[1][1]);
              if (拡張終端進捗 <= 比較通路.位置[0]) {
                if (拡張先通路[1][1].進捗 <= 拡張終端進捗) {
                  拡張可能壁群.push([{ 方向: 方向 % 方向数, 進捗: 拡張連絡口位置 }, { 方向: 方向 % 方向数, 進捗: 拡張終端進捗 - 外端通路比率 }]);
                }
                ccc(`追加(+)${拡張連絡口位置} - ${拡張終端進捗}`);
                throw '処理終了';
              }
              ccc(`管轄一致? ${拡張通路.管轄}(${管轄群[拡張通路.管轄]}) ===? ${比較通路.管轄}(${管轄群[比較通路.管轄]})`);
              if (管轄一致 || 比較通路.種別 === '隔壁') {
                if (拡張連絡口位置 < 比較通路.位置[1]) {
                  ccc(`XA ${拡張連絡口位置} < ${比較通路.位置[1]}`);
                  if (拡張先終端 <= 比較通路.位置[0]) {
                    ccc(`XB ${拡張連絡口位置} <= ${比較通路.位置[0]} - ${外端通路比率}`);
                    if (拡張連絡口位置 <= 比較通路.位置[0] - 外端通路比率) {
                      ccc(`追加(*)${拡張連絡口位置} - ${比較通路.位置[0]}`);
                      拡張可能壁群.push([{ 方向: 方向 % 方向数, 進捗: 拡張連絡口位置 }, { 方向: 方向 % 方向数, 進捗: 比較通路.位置[0] - 外端通路比率 }]);
                    }
                  }
                  拡張連絡口位置 = 比較通路.位置[1];
                }
                拡張先通路 = 隣接通路情報取得(通路列数 - 1, 方向, 比較通路.位置[1], 1, 1);
              } else {
                const 拡張先始端隔壁位置 = ((値) => 値.方向 - 方向 + 値.進捗)(拡張先始端隔壁[1][1]);
                const 拡張先終端隔壁位置 = ((値) => 値.方向 - 方向 + 値.進捗)(拡張先終端隔壁[1][1]);
                if (管轄群[比較通路.管轄] === 拡張先管轄) {
                  if (仮定拡張連絡口位置 + 外端通路比率 > 拡張先始端隔壁位置) {
                    if (拡張先終端 <= 拡張先始端隔壁位置) {
                      ccc(`追加(@)${拡張連絡口位置} - ${拡張先始端隔壁位置}`);
                      拡張可能壁群.push([{ 方向: 方向 % 方向数, 進捗: 拡張連絡口位置 }, { 方向: 方向 % 方向数, 進捗: 拡張先始端隔壁位置 - 外端通路比率 }]);
                    }
                    拡張連絡口位置 = 仮定拡張連絡口位置;
                  }
                }
                拡張先通路位置 = 比較通路.位置[1];
                仮定拡張連絡口位置 = 拡張先終端隔壁位置;
              }

              return [拡張連絡口位置, 拡張先通路, 仮定拡張連絡口位置, 管轄群[比較通路.管轄]];
            }, [拡張始端進捗, 初期拡張先通路, null, null]);
            const 拡張先終端 = ((値) => 値.方向 - 方向 + 値.進捗)(拡張先通路[1][1]);
            const 拡張連絡口終端位置 = 拡張連絡口位置 + 外端通路比率;
            if (終端進捗 >= 拡張連絡口終端位置 && 終端進捗 <= 拡張先終端) {
              ccc(`>>>> ${終端進捗} >= ${拡張連絡口終端位置} && ${終端進捗} <= ${拡張先終端}`);
              ccc(`追加(:)${拡張連絡口位置} - ${終端進捗}`);
              拡張可能壁群.push([{ 方向: 方向 % 方向数, 進捗: 拡張連絡口位置 }, { 方向: 方向 % 方向数, 進捗: 終端進捗 - 外端通路比率 }]);
            }
          } catch (_) {
          }
        });

        return 拡張可能壁群;
      };

      const 列連結 = (面 = 0, 列 = 0) => {
        const 通路 = (() => {
          if (列 === 0 && 中心空間確保) {
            const 通路始端 = [{ 方向: 0, 進捗: 0 }, { 方向: 0, 進捗: 0 }];
            const 通路末端 = [{ 方向: 方向数 - 1, 進捗: 1 }, { 方向: 方向数 - 1, 進捗: 1 }];
            const 通路 = 通路生成(面, 列, { 管轄: 管轄群.length, 位置: [通路始端, 通路末端], 末端情報: [false, false] });
            通路群[面][列].push(通路);
            拡張可能通路群.push(通路);
            管轄群.push(管轄群.length);

            return 通路;
          }
          const 通路情報 = 隣接通路情報取得(列, Math.floor(Math.random() * 方向数), Math.random(), 1, 0);
          const 通路 = 通路生成(面, 列, { 管轄: 管轄群.length, 位置: 通路情報 });
          const 合成通路 = 通路群[面][列][0] && 通路合成(通路群[面][列][0], 通路);
          if (合成通路) {
            通路群[面][列][0].位置 = 合成通路.位置;

            return 通路群[面][列][0];
          }
          通路群[面][列].push(通路);
          拡張可能通路群.push(通路);
          管轄群.push(管轄群.length);

          return 通路;
        })();
        const 連絡口臨界 = 隣接隔壁情報取得('連絡口', 列, 通路.位置[1][1].方向, 通路.位置[1][1].進捗, 0, 0);
        const 連絡口始端1 = 連絡口臨界[1][0].方向 + 連絡口臨界[1][0].進捗;
        const 連絡口始端2 = 通路.位置[0][0].方向 + 通路.位置[0][0].進捗;
        const 連絡口始端 = 連絡口始端1 + (連絡口始端2 - 連絡口始端1) * Math.random();
        const 連絡口 = 隣接隔壁情報取得('連絡口', 列, Math.floor(連絡口始端), 連絡口始端 % 1, 1, 0);
        連絡口群[面][列].push(末端調整(連絡口));
        if (列 === 0 && 中心空間確保) {
          通路.位置[0] = (({ 方向, 進捗 }) => [{ 方向, 進捗 }, { 方向, 進捗 }])(連絡口[0][0]);
          通路.位置[1] = (({ 方向, 進捗 }) => [{ 方向: 方向 + 方向数, 進捗 }, { 方向: 方向 + 方向数, 進捗 }])(連絡口[0][0]);
        }

        const [次列通路始端] = 隣接通路情報取得(列 + 1, 連絡口[0][1].方向, 連絡口[0][1].進捗, 1, 0);
        const [次列通路終端] = 隣接通路情報取得(列 + 1, 連絡口[1][1].方向, 連絡口[1][1].進捗, 0, 0);
        const 次列通路 = 末端調整(通路生成(面, 列 + 1, { 管轄: 管轄群.length - 1, 位置: [次列通路始端, 次列通路終端] }));
        通路群[面][列 + 1].push(次列通路);
        拡張可能通路群.push(次列通路);
        連絡口群[面][列].sort(([[A]], [[B]]) => A.方向 + A.進捗 - B.方向 - B.進捗);
        通路群[面][列].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
        通路群[面][列 + 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);

        if (列 < 通路列数 - 2) {
          列連結(面, 列 + 1);
        } else if (面 < 面数 - 1) {
          列連結(面 + 1, 0);
        }
      };

      const 面連結 = (内部参照情報 = null) => {
        const ddd = 1;
        const ccc = (...B) => ddd && console.log(...B);
        if (!内部参照情報) {
          内部参照情報 = {
            面管轄群: Array(面数).fill(null).map((_, 面) => 面),
            外端通路比率: 通路厚角度 / 隔壁臨界位置群[通路列数 - 1][0].角度Y,
            通路始端臨界: ((情報) => 情報[1][1].進捗)(隣接通路情報取得(通路列数 - 1, 0, 1, 0, 1)),
          };
        }

        const { 面管轄群, 外端通路比率, 通路始端臨界 } = 内部参照情報;
        const [拡張候補面群] = Array(面数).fill(null).reduce(([候補群, 最大接続数], _, 面) => {
          const 接続対象群 = 面接続情報群[面].reduce(
            (情報群, [接続面, 接続方向], 方向) => [...情報群, ...(面管轄群[面] !== 面管轄群[接続面] ? [{ 方向, 接続面, 接続方向 }] : [])],
            []
          );

          return 接続対象群.length > 最大接続数 ? [[{ 面, 接続対象群 }], 接続対象群.length] : 接続対象群.length < 最大接続数 ? [候補群, 最大接続数] : [[...候補群, { 面, 接続対象群 }], 最大接続数];
        }, [[], 1]);
        if (!拡張候補面群.length) {
          return;
        }

        const { 面, 接続対象群 } = 拡張候補面群[Math.floor(Math.random() * 拡張候補面群.length)];
        const { 方向, 接続面, 接続方向 } = 接続対象群[Math.floor(Math.random() * 接続対象群.length)];
        ccc(`SS: ${面} >>> ${接続面}.${接続方向}----`);
        const 新規位置 = 隣接通路情報取得(通路列数 - 1, 方向, Math.random() * 通路始端臨界, 1, 1);
        const 新規通路 = 通路生成(面, 通路列数 - 1, { 管轄: 管轄群.length, 位置: 新規位置 });
        const [当列通路, 新規判定] = 通路群[面][通路列数 - 1].reduce(([新規通路, 新規判定], 既成通路) => {
          const 合成範囲 = 新規判定 && 通路合成(既成通路, 新規通路);
          既成通路.位置 = (合成範囲 || 既成通路).位置;

          // return 合成範囲 ? [既成通路, false] : [新規通路, true];
          return (!新規判定 || 合成範囲) ? [既成通路, false] : [新規通路, true];
        }, [新規通路, true]);
        ccc(`SSSS: (${新規判定 ? 'A' : 'B'}) ${(({ 方向, 進捗 }) => 方向 + 進捗)(当列通路.位置[0][0])}`);
        if (新規判定) {
          通路群[面][通路列数 - 1].push(当列通路);
          拡張可能通路群.push(当列通路);
          管轄群.push(管轄群.length);
        }

        try {
          const 連絡口始端位置 = (([始端, 終端]) => 始端[1].進捗 + (終端[1].進捗 - 始端[1].進捗 - 外端通路比率) * Math.random())(新規位置);
          const [連絡口情報, 接続連絡口情報] = 隣接外端連絡口情報取得(面, 方向, 連絡口始端位置, 1);
          const 接続面通路始端臨界1 = Math.max(((情報) => 情報[1][1].進捗)(隣接通路情報取得(通路列数 - 1, 0, 接続連絡口情報[1].進捗, 0, 1)), 0);
          const 接続面通路始端臨界2 = Math.min(接続連絡口情報[0].進捗, 通路始端臨界);
          const 接続面通路始端 = ((静1, 静2) => 静1 + (静2 - 静1) * Math.random())(接続面通路始端臨界1, 接続面通路始端臨界2);
          const 接続面通路情報 = 隣接通路情報取得(通路列数 - 1, 接続方向, 接続面通路始端, 1, 1);
          const 接続面通路 = 通路生成(接続面, 通路列数 - 1, { 管轄: 当列通路.管轄, 位置: 接続面通路情報 });
          const 既成通路 = 通路群[接続面][通路列数 - 1].reduce((既成通路, 通路, 通路番号) => {
            const 接続面合成範囲 = !既成通路 && 通路合成(接続面通路, 通路);
            if (接続面合成範囲) {
              if (管轄群[接続面通路.管轄] === 管轄群[通路.管轄]) {
                ccc('-- 接続不要');
                throw '接続不要';
              }
              通路.位置 = 接続面合成範囲.位置;
              管轄合成(接続面通路.管轄, 通路.管轄);
              既成通路 = 通路;
            }

            return 既成通路;
          }, null);
          if (!既成通路) {
            ccc('== 新規');
            通路群[接続面][通路列数 - 1].push(接続面通路);
            拡張可能通路群.push(接続面通路);
          }
          連絡口群[面][通路列数 - 1].push(連絡口情報);
          連絡口群[接続面][通路列数 - 1].push(接続連絡口情報);
        } catch (_) {
          if (_ !== '接続不要') ccc('SS??', _);
        }

        連絡口群[面][通路列数 - 1].sort(([A], [B]) => A.方向 + A.進捗 - B.方向 - B.進捗);
        連絡口群[接続面][通路列数 - 1].sort(([A], [B]) => A.方向 + A.進捗 - B.方向 - B.進捗);
        通路群[面][通路列数 - 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
        通路群[接続面][通路列数 - 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);

        const 上位管轄 = Math.min(面管轄群[面], 面管轄群[接続面]);
        const 下位管轄 = Math.max(面管轄群[面], 面管轄群[接続面]);
        面管轄群.forEach((管轄, 番号) => {
          if (管轄 === 下位管轄) {
            面管轄群[番号] = 上位管轄;
          }
        });

        面連結(内部参照情報);
      };

let re = [];
let iz = [];
let 検査 = false;
const rea = () => {
  const TS = 通路群.map((MTS) => MTS.map((LTS) => LTS.map((T) => [
    { 通路: 0, 隔壁: 1 }[T.種別],
    T.管轄 || 0,
    Number(T.末端情報[0]),
    Number(T.末端情報[1]),
    T.位置[0][0].方向,
    T.位置[0][0].進捗,
    T.位置[1][0].方向,
    T.位置[1][0].進捗,
  ])));
  const LS = 連絡口群.map((MLS) => MLS.map((LLS, LT) => LLS.map((L) => [
    LT < 通路列数 - 1 ? L[0][0].方向 : L[0].方向,
    LT < 通路列数 - 1 ? L[0][0].進捗 : L[0].進捗,
  ])));
  拡張可能通路群.forEach((T) => {
    TS[T.面][T.列].find((ATK) => T.位置[0][0].方向 + T.位置[0][0].進捗 === ATK[4] + ATK[5]).push(1);
  });

  re[re.length - 1].push(JSON.stringify([TS, LS, 管轄群]));
};
const kt = (AZH) => {
  const [TS, LS, KS] = AZH;
  面数 = TS.length;
  設定();
  TS.forEach((MTS, 面) => {
    通路群[面] = [];
    連絡口群[面] = [];
    MTS.forEach((LTS, 列) => {
      通路群[面][列] = LTS.map((T) => {
        const 種別 = ['通路', '隔壁'][T[0]];
        const 位置 = T[0]
          ? 隣接隔壁情報取得('隔壁', 列, T[4], T[5], 1, 0)
          : 列
            ? [
              (([ZH]) => ZH.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(隣接通路情報取得(列, T[4], T[5], 1, 0)),
              (([ZH]) => ZH.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(隣接通路情報取得(列, T[6], T[7], 0, 0)),
            ]
            : [
              [{ 方向: T[4], 進捗: T[5] }, { 方向: T[4], 進捗: T[5] }],
              [{ 方向: T[6], 進捗: T[7] }, { 方向: T[6], 進捗: T[7] }],
            ];
        const TT = { 面, 列, 種別, 管轄: T[1], 末端情報: [T[2], T[3]], 位置 };
        if (!T[0] && T[8]) {
          拡張可能通路群.push(TT);          
        }

        return TT;
      });
    });
  });
  LS.forEach((MLS, 面) => {
    MLS.forEach((LLS, 列) => {
      連絡口群[面][列] = LLS.map(
        (L) => 列 < 通路列数 - 1
          ? 隣接隔壁情報取得('連絡口', 列, L[0], L[1], 1, 0)
          : ((ZH) => ZH[0])(隣接外端連絡口情報取得(面, L[0], L[1], 1))
      );
    });
  });
  KS.forEach((K) => {
    管轄群.push(K);
  });
};

      const 拡張 = (拡張情報) => {
        const ddd = re.length === 1 && false;
        const ccc = (...B) => ddd && console.log(...B);
        // console.log(`KK: ${re.length}`);
        const [面, 列, 拡張通路, 拡張通路番号, 通路番号, 拡張可能壁群, 拡張方面] = 拡張情報
          ? (() => {
            const 拡張通路 = 拡張情報[0];
            const 拡張方面 = 拡張情報[1];
            const 拡張通路番号 = 拡張可能通路群.findIndex((通路) => 通路 === 拡張通路);
            const 通路番号 = 通路群[拡張通路.面][拡張通路.列].findIndex((通路) => 通路 === 拡張通路);
            const 拡張可能壁群 = ['内端', '外端'].includes(拡張方面) ? 拡張可能壁群取得(拡張通路) : [];

            return [拡張通路.面, 拡張通路.列, 拡張通路, 拡張通路番号, 通路番号, 拡張可能壁群, 拡張方面];
          })()
          : (() => {
            const 拡張通路番号 = Math.floor(拡張可能通路群.length * Math.random());
            const 拡張通路 = 拡張可能通路群[拡張通路番号];
            const { 面, 列, 末端情報: [始端, 終端] } = 拡張通路;
            const 通路番号 = 通路群[面][列].findIndex((通路) => 通路 === 拡張通路);
            const 拡張可能壁群 = 拡張可能壁群取得(拡張通路);
            const 拡張方面候補群 = [
              ...(始端 ? ['始端'] : []),
              ...(終端 ? ['終端'] : []),
              ...(拡張可能壁群.外端.length ? ['外端'] : []),
              ...(拡張可能壁群.内端.length ? ['内端'] : []),
            ];
            const 拡張方面 = 拡張方面候補群.length && 拡張方面候補群[Math.floor(Math.random() * 拡張方面候補群.length)];

            return [面, 列, 拡張通路, 拡張通路番号, 通路番号, 拡張可能壁群, 拡張方面];
          })();

        re.push([`${面}_${列}_${通路番号}_${拡張方面}`]);
        if (['始端', '終端'].includes(拡張方面)) {
          const 比較通路番号 = ((動, 静) => (通路番号 + 動 + 静) % 静)({ 始端: -1, 終端: 1 }[拡張方面], 通路群[面][列].length);
          const 比較通路 = 通路群[面][列][比較通路番号];
          const 拡張前後 = { 始端: 0, 終端: 1 }[拡張方面];
          const { 楕円A, 角度Y } = 隔壁臨界位置群[列][0];
          const 通路幅 = 角度2 / Math.PI / 2 / 通路列数;
          const 通路長 = 楕円A / 線分3 * 角度Y / Math.PI;
          const 拡張幅 = 通路幅 / 通路長 * (2 + 4 * Math.random()) * [-1, 1][拡張前後];
          ccc(`通路幅 ${通路幅}`);
          ccc(`通路長 ${通路長}`);
          ccc(`拡張幅 ${拡張幅}`);
          const 拡張方向 = (({ 方向, 進捗 }) => 方向 + Math.floor(進捗 + 拡張幅))(拡張通路.位置[拡張前後][0]);
          const 拡張進捗 = (({ 方向, 進捗 }) => ((進捗 + 拡張幅) % 1 + 1) % 1)(拡張通路.位置[拡張前後][0]);
          const 拡張結果 = 隣接通路情報取得(拡張通路.列, 拡張方向, 拡張進捗, 1 - 拡張前後, 0);
          // ccc(`拡張方向 ${拡張方向} 拡張進捗 ${拡張進捗} <<< ${(({ 方向, 進捗 }) => 方向 + 進捗 + 拡張幅)(拡張通路.位置[拡張前後][0])}`);
          拡張通路.位置[拡張前後] = ((位置) => 位置.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(拡張結果[0]);
          const 合成範囲 = 通路合成(末端調整(拡張通路), 比較通路, 拡張方面);
          ccc(`合成範囲`, 合成範囲);
          if (合成範囲) {
            if (管轄群[拡張通路.管轄] === 管轄群[比較通路.管轄]) {
              拡張通路.位置 = 合成範囲[1 - 拡張前後].位置;
              比較通路.位置 = 合成範囲[拡張前後].位置;
              拡張通路.末端情報[拡張前後] = false;
              比較通路.末端情報[1 - 拡張前後] = false;
              通路群[面][列].push(合成範囲[2]);
            } else {
              拡張通路.位置 = [合成範囲[0].位置[0], 合成範囲[1].位置[1]];
              拡張通路.末端情報[0] = 合成範囲[0].末端情報[0];
              拡張通路.末端情報[1] = 合成範囲[1].末端情報[1];
              末端調整(拡張通路);
              拡張可能通路群.splice(拡張可能通路群.findIndex((通路) => 通路 === 比較通路), 1);
              通路群[面][列].splice(比較通路番号, 1);
              管轄合成(拡張通路.管轄, 比較通路.管轄);
            }
          }
          通路群[面][列].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
        } else if (['外端', '内端'].includes(拡張方面)) {
          const 内外係数 = { 内端: 0, 外端: 1 }[拡張方面];
          const 拡張連絡口列 = 列 -1 + 内外係数;
          const 拡張範囲 = 拡張可能壁群[拡張方面][Math.floor(Math.random() * 拡張可能壁群[拡張方面].length)];
          ccc('拡張範囲 -----------', 拡張範囲.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))
          const 拡張先情報 = 列 === 通路列数 - 1 && 内外係数 && 面接続情報群[面][拡張範囲[0].方向];
          const 拡張地点 = (方向数 + (([始端, 終端]) => 始端.方向 + 始端.進捗 + (終端.方向 + 終端.進捗 - 始端.方向 - 始端.進捗) * Math.random())(拡張範囲)) % 方向数;
          const [拡張方向, 拡張進捗] = [Math.floor(拡張地点), 拡張地点 % 1];
          ccc(`拡張地点 ----------- ${拡張地点} >>>> ${拡張方向}:${拡張進捗}`);
          const [隣接通路始端, 隣接通路終端, 拡張通路面, 拡張通路列, 拡張内外係数] = 拡張先情報
            ? (() => {
              const [連絡口情報, 接続連絡口情報] = 隣接外端連絡口情報取得(面, 拡張方向, 拡張進捗, 1);
              連絡口群[面][通路列数 - 1].push(連絡口情報);
              連絡口群[面][通路列数 - 1].sort((A, B) => A[0].方向 + A[0].進捗 - B[0].方向 - B[0].進捗);
              連絡口群[拡張先情報[0]][通路列数 - 1].push(接続連絡口情報);
              連絡口群[拡張先情報[0]][通路列数 - 1].sort((A, B) => A[0].方向 + A[0].進捗 - B[0].方向 - B[0].進捗);
              通路群[面][通路列数 - 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
              通路群[拡張先情報[0]][通路列数 - 1].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
              const 隣接通路始端 = 隣接通路情報取得(通路列数 - 1, 拡張先情報[1], 接続連絡口情報[0].進捗, 1, 1);
              const 隣接通路終端 = 隣接通路情報取得(通路列数 - 1, 拡張先情報[1], 接続連絡口情報[1].進捗, 0, 1);

              return [隣接通路始端, 隣接通路終端, 拡張先情報[0], 通路列数 - 1, 0];
            })()
            : (() => {
              const 拡張面連絡口 = 隣接隔壁情報取得('連絡口', 拡張連絡口列, 拡張方向, 拡張進捗, 1, 1 - 内外係数);
              連絡口群[面][拡張連絡口列].push(末端調整(拡張面連絡口));
              連絡口群[面][拡張連絡口列].sort(([[A]], [[B]]) => A.方向 + A.進捗 - B.方向 - B.進捗);
              const 隣接通路始端 = 隣接通路情報取得(列 + [-1, 1][内外係数], 拡張面連絡口[0][内外係数].方向, 拡張面連絡口[0][内外係数].進捗, 1, 1 - 内外係数);
              const 隣接通路終端 = 隣接通路情報取得(列 + [-1, 1][内外係数], 拡張面連絡口[1][内外係数].方向, 拡張面連絡口[1][内外係数].進捗, 0, 1 - 内外係数);

              return [隣接通路始端, 隣接通路終端, 面, 列 + [-1, 1][内外係数], 内外係数];
            })();

          const 隣接通路情報 = [隣接通路始端[0], 隣接通路終端[0]];
          const 新規通路 = 末端調整(通路生成(拡張通路面, 拡張通路列, { 管轄: 拡張通路.管轄, 位置: 隣接通路情報, 末端情報: [true, true] }));
          try {
            if (!拡張通路列 && 中心空間確保) {
              管轄合成(拡張通路.管轄, 通路群[拡張通路.面][0][0].管轄);
              throw '処理不要';
            }
            通路群[拡張通路面][拡張通路列].filter(({ 種別 }) => 種別 === '通路').forEach((比較通路) => {
              const 合成結果 = 通路合成(新規通路, 比較通路);
              if (合成結果) {
                比較通路.位置 = 合成結果.位置;
                管轄合成(新規通路.管轄, 比較通路.管轄);
                throw '処理終了';
              }
            });
            if (!拡張内外係数) {
              const [地点1, 地点2] = ((値1, 値2) => [値1.方向 + 値1.進捗, 値2.方向 + 値2.進捗])(隣接通路終端[1][0], 隣接通路始端[0][0]);
              const 通路地点 = 地点1 + (地点2 - 地点1) * Math.random();
              ccc(`通路地点: (${地点1} - ${地点2}) >>> ${通路地点}`);
              const [通路方向, 通路進捗] = [Math.floor(通路地点), (通路地点 % 1 + 1) % 1];
              ccc(`通路方向${通路方向} 通路進捗${通路進捗}`);
              const 新規位置 = 隣接通路情報取得(拡張通路列, 通路方向, 通路進捗, 1, 0);
              const 前後係数 = Math.floor(Math.random() * 2);
              Array(通路群[拡張通路面][拡張通路列].length).fill(null).forEach((_, 通路係数) => {
                const 比較通路 = 通路群[拡張通路面][拡張通路列][前後係数 ? 通路係数 : (通路群[拡張通路面][拡張通路列].length - 1 - 通路係数)];
                [0, 1].forEach((前後) => {
                  新規通路.位置[前後] = 新規位置[前後];
                  新規通路.位置[1 - 前後] = 隣接通路情報[1 - 前後];
                  const 合成結果 = 通路合成(新規通路, 比較通路, ['始端', '終端'][前後]);
                  if (合成結果) {
                    if (管轄群[新規通路.管轄] === 管轄群[比較通路.管轄]) {
                      const { 方向, 進捗 } = 合成結果[2].位置[1 - 前後][0];
                      const 新規更新位置 = 隣接通路情報取得(拡張通路列, 方向, 進捗, 1 - 前後, 0);
                      新規通路.位置 = [新規更新位置[前後], 新規更新位置[1 - 前後]];
                      新規通路.末端情報[前後] = false;
                      比較通路.末端情報[1 - 前後] = false;
                      通路群[拡張通路面][拡張通路列].push(末端調整(新規通路));
                      通路群[拡張通路面][拡張通路列].push(合成結果[2]);
                      拡張可能通路群.push(新規通路);
                    } else {
                      比較通路.位置[1 - 前後] = 隣接通路情報[1 - 前後];
                      末端調整(比較通路);
                      管轄合成(新規通路.管轄, 比較通路.管轄);
                    }
                    throw '処理終了';
                  }
                });
              });
              新規通路.位置 = 新規位置;
            }

            通路群[拡張通路面][拡張通路列].push(新規通路);
            拡張可能通路群.push(新規通路);
          } catch (_) {
          }

          通路群[拡張通路面][拡張通路列].sort(({ 位置: [[A]] }, { 位置: [[B]] }) => A.方向 + A.進捗 - B.方向 - B.進捗);
        } else {
          拡張可能通路群.splice(拡張通路番号, 1);
        }
// re[re.length - 1].push(JSON.stringify([通路群,連絡口群,管轄群,拡張可能通路群]));
rea();
const reiz = [];
通路群.forEach((MTS, M) => {
  MTS.forEach((LTS, L) => {
    let ST = 0;
    LTS.forEach(({ 位置 }, B) => {
      const { 方向: H1, 進捗: S1 } = 位置[0];
      const { 方向: H2, 進捗: S2 } = 位置[1];
      if (H1 < 0 || H1 >= 方向数) reiz.push(['T', M, L, B, '方向異常']);
      if (H1 + S1 < ST) reiz.push(['T', M, L, B, '重複']);
      ST = H2 + S2;
    });
  });
});
連絡口群.forEach((MLS, M) => {
  MLS.forEach((LLS, L) => {
    let ST = 0;
    LLS.forEach(([Z, G], B) => {
      const { 方向: H1, 進捗: S1 } = L < 通路列数 - 1 ? Z[0] : Z;
      const { 方向: H2, 進捗: S2 } = L < 通路列数 - 1 ? G[0] : G;
      if (H1 < 0 || H1 >= 方向数) reiz.push(['L', M, L, B, '方向異常']);
      if (H1 + S1 < ST) reiz.push(['L', M, L, B, '重複']);
      ST = H2 + S2;
    });
  });
});
if (reiz.length) {
  iz.push([re.length - 1, reiz]);
  console.log('中断!!!!!!!!!!!!!!!!!', reiz);
}
        if (拡張可能通路群.length && re.length < 1000 && !検査 && !reiz.length) {
          const 継続拡張方面候補群 = ['始端', '終端'].filter((_, 係数) => !!拡張通路.末端情報[係数]);
          const 継続拡張通路 = 継続拡張方面候補群.length && ['外端', '内端'].includes(拡張方面) && 拡張通路;
          const 継続拡張方面 = 継続拡張通路 && 継続拡張方面候補群[Math.floor(Math.random() * 継続拡張方面候補群.length * 2)] || null;
          // 継続拡張方面 ? 拡張(継続拡張通路, 継続拡張方面) : 拡張();
          拡張(継続拡張方面 && [継続拡張通路, 継続拡張方面]);
        } else {
          console.log(`終了(${re.length - 1})`);
        }
      };

      const 構成 = () => {
        const 隔壁構成 = (面, 列, 内外, 座標1, 座標2) => {
          const [法線始点座標, 法線終点座標] = 列壁座標取得(列, 座標1.方向, 内外, (座標1.位置 + (座標2.位置 || 1)) / 2, 1);
          座標群[`${面}_${列}_${座標1.種別}${座標1.番号}_${内外}O`] = 面座標変換(面, 法線終点座標);
          隔壁平面群[面][`${面}_${列}_${座標1.種別}${座標1.番号}_${内外}X`] = {
            [['H', 'O'][内外]]: 'O',
            [['O', 'H'][内外]]: `${面}_${列}_${座標1.種別}${座標1.番号}_${内外}O`,
            S: [
              `${面}_${列}_${座標1.種別}${座標1.番号}_${内外}U`,
              `${面}_${列}_${座標1.種別}${座標1.番号}_${内外}D`,
              `${面}_${列}_${座標2.種別}${座標2.番号}_${内外}D`,
              `${面}_${列}_${座標2.種別}${座標2.番号}_${内外}U`,
            ],
          };
        };

        const 座標記号取得 = (面, 列, 内外, 座標) => {
          const [座標面, 座標基本方向] = (列 < 通路列数 - 1 || !内外) ? [面, 座標.方向] : 面接続情報群[面][座標.方向];
          const 座標方向 = (列 < 通路列数 - 1 || !内外 || 座標.位置) ? 座標基本方向 : ((座標基本方向 + 1) % 方向数);
          const 座標内外 = (列 < 通路列数 - 1 || !内外) ? 内外 : 0;
          const 座標種別 = (列 < 通路列数 - 1 || !内外) ? 座標.種別 : { LS: 'LE', LE: 'LS', KS: 'KE', KE: 'KS' }[座標.種別] || 座標.種別;

          return `${座標面}_${列}_${座標種別}${座標.番号}_${座標内外}`;
        };

        Array(面数).fill(null).forEach((_, 面) => {
          座標群[`${面}_C`] = { ...面座標変換(面, { X: 0, Y: 0 }), R: 径 - 隔壁高 };
          迷路座標群[面] = Array(通路列数).fill(null).map(() => []);
          Array(通路列数).fill(null).forEach((_列, 列) => {
            Array(列 < 通路列数 - 1 ? 2 : 1).fill(null).forEach((_内外, 内外) => {
              迷路座標群[面][列][内外] = [];
              Array(方向数).fill(null).forEach((_方向, 方向) => {
                Array(解像度).fill(null).forEach((_, 進捗) => {
                  const [基本座標, 法線基準座標] = 列壁座標取得(列, 方向, 内外, 進捗 / 解像度);
                  const 変換座標 = 面座標変換(面, 基本座標);
                  座標群[`${面}_${列}_${方向}.${進捗}_${内外}D`] = { ...変換座標, R: 径 - 隔壁高 };
                  座標群[`${面}_${列}_${方向}.${進捗}_${内外}U`] = { ...変換座標, R: 径 };
                  迷路座標群[面][列][内外].push({ 方向, 位置: 進捗 / 解像度, 種別: '', 番号: `${方向}.${進捗}` });
                });
              });
            });
          });
        });
        Array(面数 + 1).fill(null).forEach((_, 面) => {
          隔壁平面群[面] = {};
          通路平面群[面] = {};
          壁頂平面群[面] = {};
        });
        const 基本座標群 = [];
        Array(通路列数).fill(null).forEach((_1, 列) => {
          基本座標群[列] = Array(列 < 通路列数 - 1 ? 2 : 1).fill(null).map((_2, 内外) => {
            const 角度X1 = 角度2 / 通路列数 * (列 + 1) + 隔壁厚角度 * [-1, 1][内外];
            const 座標Y0 = Math.cos(Math.PI / 方向数);
            const 座標Y1 = Math.sin(角度X1) * 線分3;
            const 座標X1 = Math.pow(1 / (1 / 線分3 / 線分3 + 座標Y0 * 座標Y0 / 線分1 / 線分1 / 座標Y1 / 座標Y1), 1 / 2);
            const 角度Y0 = Math.asin(座標X1 / 線分3);

            return { X: 角度X1, Y: 角度Y0 };
          });
        });
        通路群.forEach((面内通路群, 面) => {
          面内通路群.forEach((列内通路群, 列) => {
            列内通路群.filter(({ 種別 }) => 種別 === '隔壁').forEach(({ 位置 }, 番号) => {
              位置.forEach((前後位置, 前後) => {
                前後位置.forEach(({ X, Y, HX, HY, 方向, 進捗: 隔壁進捗 }, 内外) => {
                  const 種別記号 = ['KS', 'KE'][前後];
                  const 座標 = 面座標変換(面, { X, Y });
                  迷路座標群[面][列 - 1 + 内外][1 - 内外].push({ 方向, 位置: 隔壁進捗, 種別: 種別記号, 番号 });
                  座標群[`${面}_${列 - 1 + 内外}_${種別記号}${番号}_${1 - 内外}U`] = { ...座標, R: 径 };
                  座標群[`${面}_${列 - 1 + 内外}_${種別記号}${番号}_${1 - 内外}D`] = { ...座標, R: 径 - 隔壁高 };
                  if (内外) {
                    座標群[`${面}_${列}_${種別記号}${番号}_LH`] = 面座標変換(面, { X: HX, Y: HY, R: 径 });
                    隔壁平面群[面][`${面}_${列}_${種別記号}${番号}K`] = {
                      H: `${面}_${列}_${種別記号}${番号}_LH`,
                      O: 'O',
                      S: [
                        `${面}_${列 - 1}_${種別記号}${番号}_1U`,
                        `${面}_${列 - 1}_${種別記号}${番号}_1D`,
                        `${面}_${列}_${種別記号}${番号}_0D`,
                        `${面}_${列}_${種別記号}${番号}_0U`,
                      ],
                    };
                  }
                });
              });
            });
          });
        });
        連絡口群.forEach((面内連絡口群, 面) => {
          面内連絡口群.forEach((列内連絡口群, 列) => {
            列内連絡口群.forEach((連絡口, 番号) => {
              const [接続面, 接続方向] = 列 < 通路列数 - 1 ? [0] : 面接続情報群[面][連絡口[0].方向];
              const 優先接続 = 接続面 > 面;
              連絡口.forEach((末端, 前後) => {
                if (列 < 通路列数 - 1) {
                  末端.forEach(({ X, Y, HX, HY, 方向, 進捗 }, 内外) => {
                    const 座標 = 面座標変換(面, { X, Y });
                    const 種別記号 = ['LS', 'LE'][前後];
                    迷路座標群[面][列][内外].push({ 方向, 位置: 進捗, 種別: 種別記号, 番号 });
                    座標群[`${面}_${列}_${種別記号}${番号}_${内外}U`] = { ...座標, R: 径 };
                    座標群[`${面}_${列}_${種別記号}${番号}_${内外}D`] = { ...座標, R: 径 - 隔壁高 };
                    if (内外) {
                      座標群[`${面}_${列}_${種別記号}${番号}_LH`] = 面座標変換(面, { X: HX, Y: HY, R: 径 });
                      隔壁平面群[面][`${面}_${列}_${種別記号}${番号}K`] = {
                        H: `${面}_${列}_${種別記号}${番号}_LH`,
                        O: 'O',
                        S: [
                          `${面}_${列}_${種別記号}${番号}_0U`,
                          `${面}_${列}_${種別記号}${番号}_0D`,
                          `${面}_${列}_${種別記号}${番号}_1D`,
                          `${面}_${列}_${種別記号}${番号}_1U`,
                        ],
                      };
                    }
                  });
                } else {
                  const { X, Y, HX, HY, 方向, 進捗 } = 末端;
                  const 座標 = 面座標変換(面, { X, Y });
                  const [種別記号, 接続種別記号] = [['LS', 'LE'], ['LE', 'LS']][前後];
                  迷路座標群[面][列][0].push({ 方向, 位置: 進捗, 種別: 種別記号, 番号 });
                  座標群[`${面}_${列}_${種別記号}${番号}_0U`] = { ...座標, R: 径 };
                  座標群[`${面}_${列}_${種別記号}${番号}_0D`] = { ...座標, R: 径 - 隔壁高 };
                  if (優先接続) {
                    const 接続判別位置 = 1 - (進捗 + 連絡口[1 - 前後].進捗) / 2;
                    const 接続番号 = 連絡口群[接続面][通路列数 - 1].findIndex(([情報1, 情報2]) => 情報1.方向 === 接続方向 && 情報1.進捗 < 接続判別位置 && 情報2.進捗 > 接続判別位置);
                    座標群[`${面}_${列}_${種別記号}${番号}_LH`] = 面座標変換(面, { X: HX, Y: HY, R: 径 });
                    隔壁平面群[面数][`${面}_${列}_${種別記号}${番号}K`] = {
                      H: `${面}_${列}_${種別記号}${番号}_LH`,
                      O: 'O',
                      S: [
                        `${面}_${列}_${種別記号}${番号}_0U`,
                        `${面}_${列}_${種別記号}${番号}_0D`,
                        `${接続面}_${列}_${接続種別記号}${接続番号}_0D`,
                        `${接続面}_${列}_${接続種別記号}${接続番号}_0U`,
                      ],
                    };
                  }
                }
              });
            });
          });
        });

        迷路座標群.forEach((面内迷路座標群, 面) => {
          面内迷路座標群.forEach((列内迷路座標群, 列) => {
            if (列 === 通路列数 - 1) {
              列内迷路座標群[1] = [];
              Array(方向数).fill(null).forEach((_, 方向) => {
                const [接続面, 接続方向] = 面接続情報群[面][方向];
                迷路座標群[接続面][列][0].forEach((座標) => {
                  if (座標.方向 === 接続方向) {
                    列内迷路座標群[1].push({ ...座標, 方向, 位置: 1 - 座標.位置, 種別: { LS: 'LE', LE: 'LS', KS: 'KE', KE: 'KS' }[座標.種別] || 座標.種別 });
                  } else if ((座標.方向 - 1 + 方向数) % 方向数 === 接続方向 && 座標.位置 === 0) {
                    列内迷路座標群[1].push({ ...座標, 方向, 位置: 0, 種別: { LS: 'LE', LE: 'LS', KS: 'KE', KE: 'KS' }[座標.種別] || 座標.種別 });
                  }
                });
              });
              列内迷路座標群[1].sort((A, B) => A.方向 + A.位置 - B.方向 - B.位置);
            }
            列内迷路座標群.forEach((内外座標群, 内外) => {
              const ddd = 面 === 3 && 列 === 0 && 内外 && false;
              const ccc = (...B) => ddd && console.log(...B);
              ccc(`面${面}_列${列}_内外${内外}==========================================`);
              const 対列座標番号取得 = ({ 方向, 番号 }) => {
                if (列 < 通路列数 - 1 || !内外) {
                  return [番号];
                }
                const 進捗番号 = parseInt(番号.replace(/.*\./, ''));

                return 進捗番号
                  ? [`${方向}.${解像度 - 進捗番号}`]
                  : [`${方向}.0`, `${(方向 + 1) % 方向数}.0`];
              };
              const 接続考慮 = 列 === 通路列数 - 1 && 内外;
              const 前列 = 列 - 1 + 内外;
              const 前列座標群 = 面内迷路座標群[前列]?.[1 - 内外] || [];
              const 当列座標群 = 内外座標群.sort((A, B) => A.方向 % 方向数 + A.位置 - B.方向 % 方向数 - B.位置);
              const 前列冒頭番号 = Math.max(0, 前列座標群.findIndex(({ 種別, 番号 }) => 種別 === ['KE', 'LE'][内外] && (接続考慮 || 番号 === 0)));
              const 当列冒頭番号 = Math.max(0, 当列座標群.findIndex(({ 種別, 番号, 方向 }) => 種別 === ['KE', 'LE'][内外] && (接続考慮 ? 方向 === 前列座標群[前列冒頭番号].方向 : 番号 === 0)));
              // ccc('####################', 前列座標群, 当列座標群, `${前列冒頭番号} <> ${当列冒頭番号}`);
              const 推移情報 = {
                当列: { 座標: 当列座標群[当列冒頭番号], 段階: ['D', 'U'][内外] },
                前列: { 座標: 前列座標群[前列冒頭番号], 段階: ['D', 'U'][内外], 進捗: 0 },
              };
              Array(当列座標群.length).fill(null).forEach((_, 進捗係数) => {
                const 進捗 = (当列冒頭番号 + 進捗係数 + 1) % 当列座標群.length;
                const 座標 = 当列座標群[進捗];
                // const 位置 = 座標.方向 % 方向数 + (当列冒頭番号 + 進捗係数 + 1 >= 当列座標群.length && 当列座標群[当列冒頭番号].方向 >= (前列座標群[前列冒頭番号]?.方向 || 0) ? 方向数 : 0) + 座標.位置;
                const 位置 = 座標.方向 % 方向数 + (当列冒頭番号 + 進捗係数 + 1 >= 当列座標群.length && (当列座標群[当列冒頭番号].方向 >= (前列座標群[前列冒頭番号]?.方向 || 0) || (前列座標群[前列冒頭番号]?.方向 || 0) < 方向数) ? 方向数 : 0) + 座標.位置;
                // ccc(`位置 @@:: ${座標.方向} % ${方向数} + (${当列冒頭番号} + ${進捗係数} + 1 >= ${当列座標群.length} && ${当列座標群[当列冒頭番号].方向} >= (${前列座標群[前列冒頭番号]?.方向 || 0}) ? ${方向数} : 0) + ${座標.位置}`);
                const 座標記号 = 座標記号取得(面, 列, 内外, 座標);
                const [接続面, 接続方向] = 接続考慮 ? 面接続情報群[面][座標.方向] : [面, 座標.方向];
                try {
                  if (!列 && !内外) {
                    通路平面群[面][`${座標記号}T0`] = [
                      `${面}_C`,
                      `${面}_${列}_${推移情報.当列.座標.種別}${推移情報.当列.座標.番号}_0D`,
                      `${座標記号}D`,
                    ];
                    throw '中断';
                  }
                  ccc(`${座標記号}(${面}) <<< (${位置})------------------------------`);
                  Array(前列座標群.length - 推移情報.前列.進捗).fill(null).forEach((_, 前列進捗係数) => {
                    const 前列進捗 = (推移情報.前列.進捗 + 前列冒頭番号 + 1) % 前列座標群.length;
                    const 前列座標 = 前列座標群[前列進捗];
                    const 前列位置 = 前列座標.方向 % 方向数 + (推移情報.前列.進捗 + 前列冒頭番号 + 1 >= 前列座標群.length && (前列座標群[前列冒頭番号].方向 >= 当列座標群[当列冒頭番号].方向 || 当列座標群[当列冒頭番号].方向 < 方向数) ? 方向数 : 0) + 前列座標.位置;
                    ccc(`-- ${座標記号取得(面, 前列, 1 - 内外, 前列座標)}----------`);
                    ccc(`${位置} <@@@@@@@@@@@@@@@@> ${前列位置}`);
                    const 対番号群1 = 座標.種別 ? [] : 対列座標番号取得(座標);
                    const 対番号群2 = 推移情報.当列.座標.種別 ? [] : 対列座標番号取得(推移情報.当列.座標);
                    ccc(`S座標記号 ${座標記号} >>> [${対番号群1.join('|')}] <> ${前列座標.番号}`);
                    ccc(`K座標記号 ${座標記号取得(面, 前列, 1 - 内外, 前列座標)} >>> [${対番号群2.join('|')}] <> ${推移情報.前列.座標.番号}`);
                    if (対番号群1.includes(前列座標.番号) && 対番号群2.includes(推移情報.前列.座標.番号)) {
                      if (接続面 >= 面) {
                        ccc(`-------===== ${座標記号}T`);
                        ({ D: 通路平面群, U: 壁頂平面群 })[推移情報.当列.段階][面][`${座標記号}T`] = [
                          `${座標記号取得(面, 列, 内外, 推移情報.当列.座標)}${推移情報.当列.段階}`,
                          `${座標記号取得(面, 前列, 1 - 内外, 推移情報.前列.座標)}${推移情報.当列.段階}`,
                          `${座標記号取得(面, 前列, 1 - 内外, 前列座標)}${推移情報.当列.段階}`,
                          `${座標記号}${推移情報.当列.段階}`,
                        ];
                      }
                      if (内外 && 推移情報.当列.段階 === 'U') {
                        [[推移情報.前列.座標, 前列座標], [推移情報.当列.座標, 座標]].forEach(([座標1, 座標2], 隔壁内外) => {
                          隔壁構成(面, 列, 隔壁内外, 座標1, 座標2);
                        });
                      }
                      ccc(`::${{ D: '通路', U: '壁頂' }[推移情報.当列.段階]}[${面}][${座標記号}T]`);
                      推移情報.前列.座標 = 前列座標;
                      推移情報.前列.段階 = { LS: 'D', LE: 'U' }[前列座標.種別] || 推移情報.前列.段階;
                      推移情報.前列.進捗 ++;
                      throw '中断';
                    }
                    if (推移情報.当列.座標.位置 === 1) {
                      const [面1, 方向1] = 面接続情報群[面][推移情報.当列.座標.方向];
                      const [面2, 方向2] = 面接続情報群[面1][(方向1 + 1) % 方向数];
                      const [面3, 方向3] = 面接続情報群[面][座標.方向];
                      const 方向4 = (方向3 + 1) % 方向数;
                      const 集中面情報群 = [[面3, 方向4], [面, 座標.方向], [面1, 方向1]];
                      if ([8, 20].includes(面数)) {
                        const [面5, 方向5] = 面接続情報群[面3][方向4];
                        const 方向6 = (方向5 + 1) % 方向数;
                        集中面情報群.unshift([面5, 方向6]);
                        if (面数 === 20) {
                          const [面7, 方向7] = 面接続情報群[面5][方向6];
                          const 方向8 = (方向7 + 1) % 方向数;
                          集中面情報群.unshift([面7, 方向8]);
                        }
                      }
                      const 最優先面 = 集中面情報群.reduce((面1, [面2]) => Math.min(面1, 面2), 面数);
                      if (面 === 最優先面) {
                        壁頂平面群[面][`${座標記号}TT`] = 集中面情報群.map(
                          ([面1, 方向1]) => `${面1}_${列}_${方向1}.0_0U`
                        );
                        ccc(`SSSSSSSSSSSSSSSKKKKKKKKKKKKKKKK ::  ${座標記号}TT`);
                      }
                      throw '';
                    }
                    if (!前列進捗係数 && 接続面 >= 面) {
                      ({ D: 通路平面群, U: 壁頂平面群 })[推移情報.当列.段階][面][`${座標記号}T0`] = [
                        `${座標記号取得(面, 列, 内外, 推移情報.当列.座標)}${推移情報.当列.段階}`,
                        `${座標記号取得(面, 前列, 1 - 内外, 推移情報.前列.座標)}${推移情報.当列.段階}`,
                        `${座標記号}${推移情報.当列.段階}`,
                      ];
                      ccc(`::@@${{ D: '通路', U: '壁頂' }[推移情報.当列.段階]}[${面}][${座標記号}T0]`);
                      if (内外 && 推移情報.当列.段階 === 'U') {
                        隔壁構成(面, 列, 1, 推移情報.当列.座標, 座標);
                      }
                    }
                    if (
                      (![['KS', 'KE'], ['LS', 'LE']][内外].includes(座標.種別) && 前列位置 > 位置) ||
                      (推移情報.当列.段階 === 'D' && 推移情報.前列.座標.種別 === 'KS' && !内外) ||
                      (推移情報.当列.段階 === 'U' && 推移情報.前列.座標.種別 === 'KE' && !内外) ||
                      (推移情報.当列.段階 === 'U' && 推移情報.前列.座標.種別 === 'LS' && 内外) ||
                      (推移情報.当列.段階 === 'D' && 推移情報.前列.座標.種別 === 'LE' && 内外)
                    ) {
                      ccc(座標.種別 + ' <@>' + ((前列座標.方向 + 方向数) % 方向数 + 前列座標.位置) + '<*>' + ((座標.方向 + 方向数) % 方向数 + 座標.位置));
                      throw '中断';
                    }
                    if (接続面 >= 面) {
                      ({ D: 通路平面群, U: 壁頂平面群 })[推移情報.当列.段階][面][`${座標記号}T${前列進捗係数 + 1}`] = [
                        `${座標記号取得(面, 前列, 1 - 内外, 推移情報.前列.座標)}${推移情報.当列.段階}`,
                        `${座標記号取得(面, 前列, 1 - 内外, 前列座標)}${推移情報.当列.段階}`,
                        `${座標記号}${推移情報.当列.段階}`,
                      ];
                    }
                    ccc(`::++${{ D: '通路', U: '壁頂' }[推移情報.当列.段階]}[${面}][${座標記号}T${前列進捗係数 + 1}]`);
                    if (内外 && 推移情報.前列.段階 === 'U') {
                      隔壁構成(面, 列, 0, 推移情報.前列.座標, 前列座標);
                    }
                    推移情報.前列.座標 = 前列座標;
                    推移情報.前列.段階 = { LS: 'D', LE: 'U' }[前列座標.種別] || 推移情報.前列.段階;
                    推移情報.前列.進捗 ++;
                    if (
                      (['LS', 'LE'].includes(前列座標.種別) && 内外) ||
                      (['KS', 'KE'].includes(前列座標.種別) && !内外)
                    ) {
                      throw '中断';
                    }
                  });
                } catch (E) {
                  if (E !== '中断') ccc(E);
                }
                推移情報.当列.座標 = 座標;
                推移情報.当列.段階 = [{ KS: 'U', KE: 'D' }, { LS: 'D', LE: 'U' }][内外][座標.種別] || 推移情報.当列.段階;
              });
            });
          });
        });
      };

      let moveType = 'vector';
      let moveSwitch = false;
      let animation = null;
      let animationSwitch = false;
      let animationStartSwitch = false;
      let animationTimeout = null;
      let latestBaseX = 0;
      let latestBaseY = 0;
      let latestMoveX = 0;
      let latestMoveY = 0;
      let 移動角度R = 0;
      let 移動角度V = 0;
      let 移動角度L = 0;
      let 相対角度R = 0;
      let 相対角度L = 0;
      let 基本角度R = 0;
      let 基本角度V = 0;
      let 基本角度L = 0;
      let 合成角度R = 0;
      let 合成角度V = 0;
      let 合成角度L = 0;
      let 軸角度 = 合成角度V - Math.PI / 2;
      let 画角度 = 最小画角度;
      let 視角拡大率 = Math.tan(画角度);
      let momentPoses = {};
      let momentSurfaces = [];
      let radarCoordinates = {};
      let distanceSwitch = true;
      let meterChangeSwitch = false;
      let focalLength = distanceSwitch && 1 / Math.sin(画角度);
      let meterPosition = 0;
      let mousePosition = 0;

      canvasElem.setAttribute('width', `${画面幅}px`);
      canvasElem.setAttribute('height', `${画面幅}px`);

      const calculateRelativeVector = (basePos, meshPos) => {
        const { X: LRZ, Y: LLZ } = 座標取得(光源.X, 1);
        const { X: LLX, Y: LLY } = 座標取得(光源.Y, LRZ);
        const { L: LRX, T: LTX } = 角度取得(LLY, LLZ);
        const { L: LRY, T: LTY } = 角度取得(LLX, LLZ);
        const { L: MRX, T: MTX } = 角度取得(meshPos.Y - basePos.Y, meshPos.Z - basePos.Z);
        const { X: MLY, Y: MLZ } = 座標取得(MTX + LTX, MRX);
        const { L: MRY, T: MTY } = 角度取得(meshPos.X - basePos.X, MLZ);
        const { X: NLX, Y: NLZ } = 座標取得(MTY + LTY, MRY);
        const MRZ = Math.pow(NLX * NLX + MLY * MLY, 1 / 2);
        const { L: MRO2, T: MTO2 } = 角度取得(MRZ, NLZ);

        return Math.abs(MTO2) % (Math.PI * 2);
      };

      const calculateColor = (C, V) => {
        const CD = C.map((C0, i) => {
          const C1 = V < 1 / 2
            ? Math.round(C0 + (255 - C0) * (1 - V * 2))
            : Math.round(C0 * (1 / 2 + 1 - V));

          return (C1 < 16 ? '0' : '') + C1.toString(16);
        });

        return `#${CD.join('')}`;
      };

      const move = () => {
        基本角度R = 合成角度R;
        基本角度V = 合成角度V;
        基本角度L = 合成角度L;

        if (moveType === 'vector') {
          const directionX = (latestMoveX > latestBaseX) ? -1 : 1;
          const directionY = (latestMoveY > latestBaseY) ? 1 : -1;
          const absX = Math.min(Math.abs(latestMoveX - latestBaseX), 30);
          const absY = Math.min(Math.abs(latestMoveY - latestBaseY), 30);
          const thetaDiffX = (absX / 200) * directionX;
          const thetaDiffY = (absY / 200) * directionY;

          移動角度R = 0;
          移動角度V = (({ T }) => T)(角度取得(thetaDiffX * -1, thetaDiffY));
          移動角度L = 0;
          相対角度L = Math.pow(thetaDiffX * thetaDiffX + thetaDiffY * thetaDiffY, 1 / 2);
          相対角度R = 0;
        } else {
          const { T: TD0 } = 角度取得(中心 - latestBaseX, 中心 - latestBaseY);
          const { T: TD1 } = 角度取得(中心 - latestMoveX, 中心 - latestMoveY);
          const directionT = (TD1 > TD0) ? 1 : -1;
          const absT = Math.min(Math.abs(TD1 - TD0), 0.2);

          移動角度R = 0;
          移動角度L = 0;
          相対角度L = 0;
          相対角度R = absT * directionT;
        }

        latestBaseX = latestMoveX;
        latestBaseY = latestMoveY;
      };

      const slide = () => {
        if (相対角度L > 0) {
          移動角度L += 相対角度L;
          const TA0 = 移動角度V - Math.PI / 2;
          const { X: RY0, Y: LZ0 } = 座標取得(基本角度L, 1);
          const { X: LX1, Y: LY1 } = 座標取得(基本角度V - TA0, RY0);
          const { L: RX1, T: TX1 } = 角度取得(LX1 * -1, LZ0);
          const TX2 = 移動角度L + TX1;
          const { X: LX2, Y: LZ2 } = 座標取得(TX2 * -1, RX1);
          const { L: RY2, T: TV2 } = 角度取得(LX2 * -1, LY1 * -1);
          const { T: TL2 } = 角度取得(RY2 * -1, LZ2);

          合成角度R = 基本角度R;
          合成角度V = TV2 + TA0;
          合成角度L = TL2;

          if (LY1 !== 0) {
            const { X: LX3, Y: LZ3 } = 座標取得(TX1 * -1, RX1);
            const { L: RY3, T: TV3 } = 角度取得(LX3 * -1, LY1 * -1);
            const { T: TL3 } = 角度取得(RY3 * -1, LZ3);
            const { X: L0, Y: L1 } = 座標取得(TV3, 1);
            const L2 = Math.cos(TL3) * L1;
            const { T: T0 } = 角度取得(L2 * -1, L0 * -1);
            const { X: L3, Y: L4 } = 座標取得(TV2, 1);
            const L5 = Math.cos(TL2) * L4;
            const { T: T2 } = 角度取得(L5 * -1, L3 * -1);

            合成角度R += T2 - T0 + TV2 - TV3;
          }
        } else if (相対角度R !== 0) {
          移動角度R += 相対角度R;
          合成角度R = 基本角度R + 移動角度R;
          合成角度V = 基本角度V + 移動角度R;
        }
      };

      const resetAxis = (x, y) => {
        latestMoveX = x;
        latestMoveY = y;
        latestBaseX = x;
        latestBaseY = y;

        const 相対座標X = 中心 - latestBaseX;
        const 相対座標Y = 中心 - latestBaseY;
        const 相対座標R = Math.pow(相対座標X * 相対座標X + 相対座標Y * 相対座標Y, 1 / 2);

        moveType = 相対座標R <= 軸走査限界半径 ? 'vector' : 'rotate';
      };

      const setAxis = (x, y) => {
        latestMoveX = x;
        latestMoveY = y;
      };

      // 初期化
      const 再現 = () => {
        radarCoordinates = { O: { R: 0, X: 0, Y: 0 }, ...座標群 };
        surfaceGroup.road = [...通路平面群];
        surfaceGroup.top = [...壁頂平面群];
        surfaceGroup.wall = 隔壁平面群.map((平面情報群) => {
          const 平面群 = {};
          Object.keys(平面情報群).forEach((記号) => {
            平面群[記号] = 平面情報群[記号].S;
          });

          return 平面群;
        });
      };

      const 座標計算 = ({ X, Y, R }) => {
        const { X: RY0, Y: LZ0 } = 座標取得(X, 1);
        const TY1 = Y + 合成角度R - 軸角度;
        const { X: LX1, Y: LY1 } = 座標取得(TY1, RY0);
        const { L: RX1, T: TX1 } = 角度取得(LX1, LZ0);
        const TX2 = TX1 - 合成角度L;
        const { X: LX2, Y: LZ2 } = 座標取得(TX2, RX1);
        const { L: RY2, T: TY2 } = (({ L, T }) => ({ L: L / (distanceSwitch ? (focalLength - LZ2) * 視角拡大率 : 1), T }))(角度取得(LX2, LY1));
        const TY3 = TY2 + 軸角度;
        const { X: LX3, Y: LY3 } = 座標取得(TY3, RY2);

        return { X: LX3 * R, Y: LY3 * R, Z: LZ2 * R };
      };

      // 方向転換
      const setDirection = () => {
        momentSurfaces = [];
        momentPoses = {};

        focalLength = distanceSwitch && 1 / Math.sin(画角度);
        軸角度 = (合成角度V - Math.PI / 2);

        const 基準座標群 = Array(面数).fill(null).map((_, 面) => 座標計算(座標群[`${面}_C`]));

        Object.keys(surfaceGroup).forEach((partType) => {
          surfaceGroup[partType].forEach((平面群, 面) => {
            if (面 === 面数 || 基準座標群[面].Z >= 基準Z) {
              Object.keys(平面群).forEach((surfaceCode) => {
                let zIndex = 0;
                let zIndexMax = 0;

                平面群[surfaceCode].forEach((posCode) => {
                  if (!momentPoses[posCode]) {
if (!radarCoordinates[posCode]) {
// console.log(`${surfaceCode} >> ${posCode}`);
momentPoses[posCode] = { X: 0, Y: 0, Z: 0 };
return;
}
                    momentPoses[posCode] = posCode === 'O'
                      ? { X: 0, Y: 0, Z: 0 }
                      : 座標計算(radarCoordinates[posCode]);
                  }

                  zIndex += momentPoses[posCode].Z;
                  zIndexMax = Math.max(zIndexMax, momentPoses[posCode].Z);
                });

                if (partType === 'wall') {
                  const { O, H } = 隔壁平面群[面][surfaceCode];
                  momentPoses[O] = 座標計算(radarCoordinates[O]);
                  momentPoses[H] = 座標計算(radarCoordinates[H]);
                }

                if (zIndexMax >= 0) {
                  momentSurfaces.push([partType, 面, surfaceCode, zIndex / 平面群[surfaceCode].length]);
                }
              });
            }
          });
        });

        momentSurfaces.sort(([_1, _2, _3, A], [_4, _5, _6, B]) => A - B);
      };

      // 描画
      const output = () => {
        canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        canvasContext.clearRect(0, 0, 画面幅, 画面幅);

        momentSurfaces.forEach(([partType, m, code, zIndex]) => {
          const targetSurface = surfaceGroup[partType][m][code];
          const [basePos, meshPos] = (() => {
            if (partType === 'wall') {
              const { O, H } = 隔壁平面群[m][code];

              return [momentPoses[H], momentPoses[O]];
            }
            const 座標総合 = targetSurface.reduce(({ X, Y, Z }, posCode) => ({
              X: X + momentPoses[posCode].X,
              Y: Y + momentPoses[posCode].Y,
              Z: Z + momentPoses[posCode].Z,
            }), { X: 0, Y: 0, Z: 0 });

            return [{ X: 0, Y: 0, Z: 0 }, 座標総合];
          })();

          if (meshPos.Z >= basePos.Z) {
          // if (meshPos.Z >= basePos.Z || ['0_1_1_1_0', '0_1_1_2_0', '0_1_1_3_0'].includes(code)) {
            canvasContext.beginPath();
            targetSurface.forEach((posCode, j) => {
              const { X, Y, Z } = momentPoses[posCode];
              if (j === 0) {
                canvasContext.moveTo(中心 + X, 中心 + Y);
              } else {
                canvasContext.lineTo(中心 + X, 中心 + Y);
              }
            });
            canvasContext.closePath();
            const V = calculateRelativeVector(basePos, meshPos);
            // const FC = partType === 'wall' ? [112, 112, 156] : partType === 'road' ? [200, 200, 236] : [144, 144, 200];
            // const SC = partType === 'wall' ? [112, 112, 156] : partType === 'road' ? [200, 200, 236] : [144, 144, 200];
            const FC = partType === 'wall' ? [100, 128, 156] : partType === 'road' ? [224, 224, 236] : [255, 255, 255];
            const SC = partType === 'wall' ? [100, 128, 156] : partType === 'road' ? [224, 224, 236] : [255, 255, 255];
// const FC = partType === 'wall' ? [112, 112, 156] : partType === 'road' ? [200, 200, 236] : [
// [255, 100, 200],
// [100, 255, 200],
// [140, 140, 255],
// [255, 150, 150],
// [140, 200, 100],
// [100, 160, 180],
// [220, 100, 150],
// [100, 220, 120],
// [200, 100, 100],
// [170, 170, 170],
// [180, 100, 220],
// [255, 160, 152],
// [255, 224, 128],
// [156, 200, 160],
// [224, 128, 200],
// [112, 240, 128],
// [192, 160, 172],
// [120, 240, 160],
// [184, 160, 128],
// [140, 160, 255],
// ][m];
            canvasContext.fillStyle = calculateColor(FC, V / Math.PI);
            canvasContext.strokeStyle = calculateColor(SC, V / Math.PI);
            // canvasContext.strokeStyle = '#88f';
            canvasContext.fill();
            canvasContext.stroke();
          }
        });
        [
// ['0_1_0_KS2_0U', '#f00'],
// ['0_1_0_KS2_LH', '#f0f'],
        ].forEach(([code, color], i) => {
if (!momentPoses[code]) {
  momentPoses[code] = 座標計算(radarCoordinates[code]);
}
          // if (momentPoses[code] && momentPoses[code].Z >= 0) {
            const R = 3;//i % 2 ? 2 : 5;
            canvasContext.beginPath();
            canvasContext.arc(中心 + momentPoses[code].X, 中心 + momentPoses[code].Y, R, 0, Math.PI * 2);
            canvasContext.fillStyle = color;
            canvasContext.fill();
            canvasContext.beginPath();
            canvasContext.moveTo(中心 + momentPoses[code].X, 中心 + momentPoses[code].Y);
            canvasContext.lineTo(中心, 中心);
            canvasContext.strokeStyle = color;
            canvasContext.stroke();
          // }
        });
      };

      const 再生 = () => {
        if (moveSwitch) {
          move();
        }
        slide();
        setDirection();
        output();

        if (animationSwitch) {
          if (animation) {
            clearTimeout(animation);
          }
          animation = setTimeout(再生, 50);
        }
      };

      const startAnimation = () => {
        animationSwitch = true;
        再生();
      };

      const stopAnimation = () => {
        if (animation) {
          clearTimeout(animation);
        }
        animationSwitch = false;
        animationStartSwitch = false;
      };

      const moveStopCheck = (clientX, clientY) => {
        animationStartSwitch = latestMoveX !== clientX || latestMoveY !== clientY;
      };

      gauzeElem.addEventListener('mousedown', (event) => {
        stopAnimation();
        moveSwitch = true;
        resetAxis(event.clientX, event.clientY);
        document.body.classList.add('operating');
      });

      gauzeElem.addEventListener('mousemove', (event) => {
        if (moveSwitch) {
          setAxis(event.clientX, event.clientY);
          animationStartSwitch = true;
          clearTimeout(animationTimeout);
          animationTimeout = setTimeout(() => {
            moveStopCheck(event.clientX, event.clientY);
          }, 100);
          再生();
        }
      });

      document.addEventListener('keydown', () => {
        animationSwitch = !animationSwitch;
        animationStartSwitch = false;
        if (animationSwitch) {
          setTimeout(() => 再生, 50);
        }
      });

      checkElem.addEventListener('change', (event) => {
        distanceSwitch = event.target.checked;
        if (distanceSwitch) {
          meterBoxElem.classList.remove('disable');
        } else {
          meterBoxElem.classList.add('disable');
        }
        if (!animationSwitch) {
          再生();
        }
      });

      meterBoxElem.addEventListener('mousedown', (event) => {
        if (!distanceSwitch) {
          return;
        }
        const elementRect = meterBoxElem.getBoundingClientRect();
        const minPosition = elementRect.x + meterHandlePadding;
        const maxPosition = elementRect.x + meterBoxWidth - meterHandlePadding;
        mousePosition = event.clientX;
        meterPositionCandidate = Math.min(Math.max(minPosition, mousePosition), maxPosition);
        if (Math.abs(meterPosition - meterPositionCandidate) > meterHandlePadding) {
          meterPosition = meterPositionCandidate;
          const percentage = (meterPosition - minPosition) / (maxPosition - minPosition);
          画角度 = (最大画角度 - 最小画角度) * percentage + 最小画角度;
          視角拡大率 = Math.tan(画角度);
          meterHandleElem.style.left = `${meterPosition - minPosition}px`;
        }
        meterChangeSwitch = true;
        document.body.classList.add('operating');
      });

      document.addEventListener('mousemove', (event) => {
        if (!distanceSwitch || !meterChangeSwitch) {
          return;
        }

        const elementRect = meterBoxElem.getBoundingClientRect();
        const minPosition = elementRect.x + meterHandlePadding;
        const maxPosition = elementRect.x + meterBoxWidth - meterHandlePadding;
        const mousePositionOrigin = Math.min(Math.max(minPosition, event.clientX), maxPosition);
        const diffPosition = mousePositionOrigin - mousePosition;
        mousePosition = mousePositionOrigin;
        meterPosition = Math.min(Math.max(minPosition, meterPosition + diffPosition), maxPosition);
        const percentage = (meterPosition - minPosition) / (maxPosition - minPosition);
        画角度 = (最大画角度 - 最小画角度) * percentage + 最小画角度;
        視角拡大率 = Math.tan(画角度);
        meterHandleElem.style.left = `${meterPosition - minPosition}px`;
        if (!animationSwitch) {
          再生();
        }
      });

      document.addEventListener('mouseup', (event) => {
        meterChangeSwitch = false;
        document.body.classList.remove('operating');
        if (moveSwitch) {
          moveSwitch = false;
          setAxis(event.clientX, event.clientY);
        }
        if (animationStartSwitch) {
          startAnimation();
        }
      });

const kk = (M, L, B, NG = null) => {
  const T = 通路群[M]?.[L]?.[B];
  if (T) {
    const NGS = 拡張可能壁群取得(T);
    ['内端', '外端'].forEach((NGH, NGK) => {
      if (NG === null || NG === NGK) {
        NGS[NGH].forEach((ZGS) => {
          ZGS.forEach(({ 方向, 進捗 }, ZG) => {
            ZGS[ZG] = { 方向, 進捗 };
          });
        });
      }
    });

    return NG === null ? NGS : NGS[['内端', '外端'][NG]];
  }

  return 'N';
};
const k = (S, M, I = null, N = '0ff', H = 0.2) => {
  M = M ?? parseInt(S.replace(/_.*/, ''));
  const [平面群名称, 平面群] = [
    ['隔壁平面群', 隔壁平面群[M][S]?.S],
    ['壁頂平面群', 壁頂平面群[M][S]],
    ['通路平面群', 通路平面群[M][S]],
  ].find(([平面群名称, 平面群]) => !!平面群);
  canvasContext.beginPath();
  平面群.forEach((C, c) => {
    const { X, Y } = momentPoses[C];
    c ? canvasContext.lineTo(中心 + X, 中心 + Y) : canvasContext.moveTo(中心 + X, 中心 + Y);
  });
  canvasContext.closePath();
  if (I) {
    canvasContext.strokeStyle = I ? `#${I}` : '#f00';
    if (H) {
      canvasContext.lineWidth = `#${H}`;
    }
    canvasContext.stroke();
  }
  if (N) {
    canvasContext.fillStyle = `#${N}`;
    canvasContext.fill();
  }
  canvasContext.lineWidth = 0.2;
  return `${平面群名称}[${M}]['${S}']`;
};
const c = (C, I = '#f00') => {
  canvasContext.beginPath();
  const { X, Y } = momentPoses[C] || { X: 0, Y: 0 };
  canvasContext.moveTo(中心, 中心);
  canvasContext.lineTo(中心 + X, 中心 + Y);
  canvasContext.strokeStyle = I || '#f00';
  canvasContext.stroke();
  return 座標群[C] || 'N';
};
const kc = (S, M, I = null, N = '0ff', H = 0.2) => {
  M = M ?? parseInt(S.replace(/_.*/, ''));
  const [平面群名称, 平面群] = [
    ['隔壁平面群', 隔壁平面群[M][S]?.S],
    ['壁頂平面群', 壁頂平面群[M][S]],
    ['通路平面群', 通路平面群[M][S]],
  ].find(([平面群名称, 平面群]) => !!平面群);
  console.log(k(S, M, I, N, H));
  平面群.forEach((C) => {
    c(C);
    console.log(C);
  });
};
const s = (再現番号) => {
  if (re[再現番号]) {
    const 過去状態 = JSON.parse(re[再現番号][1]);
    kt(過去状態);
    Object.keys(座標群).forEach((_, Z) => {
      delete 座標群[Z];
    });
    構成();
    再現();
    再生();
  }
};
const d = (再現番号) => {
  if (re[再現番号]) {
    const J = `kt(${re[再現番号][1]});`;
    const K = ((KS) => KS ? `\n検査 = [${KS.replace(/([0-9]+)_([0-9]+)_([0-9]+)_(.*)/, `$1, $2, $3, '$4'`)}];` : '')(re[再現番号 + 1]?.[0] || '');
    console.log(J + K);
  }
};
const ce = document.getElementById('test');
const cc = ce.getContext('2d');
ce.width = 画面幅;
ce.height = 画面幅;
ce.style.width = 'var(--main-width)';
ce.style.height = 'var(--main-width)';
canvasContext.lineWidth = 0.2;
const sc = (...指示) => {
  const[再現番号, 面] = [
    指示.length === 2 ? 指示[0] : re[re.length - 1],
    指示[指示.length - 1] || 0,
  ];
  if (!re[再現番号]) {
    return;
  }
  cc.clearRect(0, 0, 画面幅, 画面幅);
  cc.strokeStyle = '#f8a';
  cc.font = '12px';
  Array(通路列数).fill(null).forEach((_1, 列) => {
    [0, 1].forEach((表裏) => {
      const { 楕円A, 楕円B, 交線B, 角度Y } = 隔壁臨界位置群[列][表裏];
      // cc.strokeStyle = '#f8a';
      cc.beginPath();
      Array(方向数).fill(null).forEach((_2, 方向) => {
        const 位置角度 = Math.PI * 2 / 方向数 * 方向;
        const 位置座標X = 中心 + Math.sin(0 - 位置角度) * 交線B * 径;
        const 位置座標Y = 中心 + Math.cos(0 - 位置角度) * 交線B * 径;
        const 最大角度 = (列 < 通路列数 - 1 || !表裏) ? 角度Y : 隔壁臨界位置群[列][0].角度Y;
        cc.ellipse(位置座標X, 位置座標Y, 楕円A * 径, 楕円B * 径, 位置角度, Math.PI / 2 - 最大角度, Math.PI / 2 + 最大角度);
      });
      cc.closePath();
      cc.stroke();
    });
  });
  cc.fillStyle = '#000';
  Array(方向数).fill(null).forEach((_, 方向) => {
    const [接続面, 接続方向] = 面接続情報群[面][方向];
    const 接続案内 = `${接続面}-${接続方向}`;
    const 幅情報 = cc.measureText(接続案内);
    const 位置角度 = Math.PI * 2 / 方向数 * 方向;
    const 位置座標X = 中心 + Math.sin(位置角度) * 径 - 幅情報.width / 2;
    const 位置座標Y = 中心 + Math.cos(位置角度) * 径 + 6;
    cc.fillText(接続案内, 位置座標X, 位置座標Y);
  });
  const [再現通路群, 再現連絡口群] = JSON.parse(re[再現番号][1]);
  再現通路群[面].forEach((列内通路群, 列) => {
    列内通路群.forEach((T) => {
      const 種別 = ['通路', '隔壁'][T[0]];
      const 位置 = T[0]
        ? 隣接隔壁情報取得('隔壁', 列, T[4], T[5], 1, 0)
        : 列
          ? [
            (([ZH]) => ZH.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(隣接通路情報取得(列, T[4], T[5], 1, 0)),
            (([ZH]) => ZH.map(({ 方向, 進捗 }) => ({ 方向, 進捗 })))(隣接通路情報取得(列, T[6], T[7], 0, 0)),
          ]
          : [
            [{ 方向: T[4], 進捗: T[5] }, { 方向: T[4], 進捗: T[5] }],
            [{ 方向: T[6], 進捗: T[7] }, { 方向: T[6], 進捗: T[7] }],
          ];
      cc.beginPath();
      [0, 1].forEach((内外) => {
        if (列 || 内外) {
          Array(位置[1][内外].方向 - 位置[0][内外].方向 + 1).fill(null).forEach((_, 方向係数) => {
            const 方向 = 位置[1 - 内外][内外].方向 + 方向係数 * [-1, 1][内外];
            const 始端進捗 = 方向係数 ? 1 - 内外 : 位置[1 - 内外][内外].進捗;
            const 終端進捗 = 方向係数 < 位置[1][内外].方向 - 位置[0][内外].方向 ? 内外 : 位置[内外][内外].進捗;
            const 位置角度 = Math.PI * 2 / 方向数 * (0 - 方向);
            const { 楕円A, 楕円B, 交線B, 角度Y } = 隔壁臨界位置群[列 - 1 + 内外][1 - 内外];
            const 位置座標X = 中心 - Math.sin(位置角度) * 交線B * 径;
            const 位置座標Y = 中心 + Math.cos(位置角度) * 交線B * 径;
            const 角度1 = Math.PI / 2 + 角度Y * (1 - 始端進捗 * 2);
            const 角度2 = Math.PI / 2 + 角度Y * (1 - 終端進捗 * 2);
            const 描画方向制御 = [false, true][内外];
            cc.ellipse(位置座標X, 位置座標Y, 楕円A * 径, 楕円B * 径, 位置角度, 角度1, 角度2, 描画方向制御);
          });
        } else {
          cc.moveTo(中心, 中心);
        }
      });
      cc.closePath();
      cc.fillStyle = { 隔壁: '#ff668844', 通路: '#6688ff44' }[種別];
      cc.fill();
    });
  });
  再現連絡口群[面].forEach((列内連絡口群, 列) => {
    列内連絡口群.forEach((L) => {
      const 位置 = 列 < 通路列数 - 1
        ? 隣接隔壁情報取得('連絡口', 列, L[0], L[1], 1, 0)
        : ((ZH) => ZH[0])(隣接外端連絡口情報取得(面, L[0], L[1], 1));
      cc.beginPath();
      [0, 1].forEach((内外) => {
        const { 楕円A, 楕円B, 交線B, 角度Y } = 隔壁臨界位置群[列][内外];
        const 最大角度 = 列 < 通路列数 - 1 || !内外 ? 角度Y : 隔壁臨界位置群[列][0].角度Y;
        const 絶対始端 = 列 < 通路列数 - 1 ? 位置[0][内外] : 位置[0];
        const 絶対終端 = 列 < 通路列数 - 1 ? 位置[1][内外] : 位置[1];
        const 相対始端 = 列 < 通路列数 - 1 ? 位置[内外][内外] : 位置[内外];
        const 相対終端 = 列 < 通路列数 - 1 ? 位置[1 - 内外][内外] : 位置[1 - 内外];
        Array(絶対終端.方向 - 絶対始端.方向 + 1).fill(null).forEach((_, 方向係数) => {
          const 方向 = 相対終端.方向 + 方向係数 * [-1, 1][内外];
          const 始端進捗 = 方向係数 ? 1 - 内外 : 相対終端.進捗;
          const 終端進捗 = 方向係数 < 絶対終端.方向 - 絶対始端.方向 ? 内外 : 相対始端.進捗;
          const 位置角度 = Math.PI * 2 / 方向数 * (0 - 方向);
          const 位置座標X = 中心 - Math.sin(位置角度) * 交線B * 径;
          const 位置座標Y = 中心 + Math.cos(位置角度) * 交線B * 径;
          const 角度1 = Math.PI / 2 + 最大角度 * (1 - 始端進捗 * 2);
          const 角度2 = Math.PI / 2 + 最大角度 * (1 - 終端進捗 * 2);
          const 描画方向制御 = [false, true][内外];
          cc.ellipse(位置座標X, 位置座標Y, 楕円A * 径, 楕円B * 径, 位置角度, 角度1, 角度2, 描画方向制御);
        });
      });
      cc.closePath();
      cc.fillStyle = '#88cc8844';
      cc.fill();
    });
  });
  Array(方向数).fill(null).forEach((_1, 方向) => {
    Array(10).fill(null).forEach((_2, 進捗) => {
      cc.beginPath();
      cc.moveTo(中心, 中心);
      Array(通路列数 * 2 - 1).fill(null).forEach((_3, 列係数) => {
        const 列 = Math.floor((列係数) / 2);
        const 内外 = 列係数 % 2;
        const { 角度Y, 楕円A, 楕円B, 交線B } = 隔壁臨界位置群[列][内外];
        const T = 角度Y * (2 * 進捗 / 10 - 1);
        const X = Math.sin(T) * 楕円A;
        const Y = Math.cos(T) * 楕円B + 交線B;
        const L = Math.pow(X * X + Y * Y, 1 / 2);
        const 角度 = Math.acos(Y / L) * (X >= 0 ? 1 : -1) + Math.PI * 2 / 方向数 * 方向;
        const 座標X = Math.sin(角度) * L * 径;
        const 座標Y = Math.cos(角度) * L * 径;
        cc.lineTo(中心 + 座標X, 中心 + 座標Y);
      });
      cc.strokeStyle = [0, 5].includes(進捗) ? '#ff88aa55' : '#8888ff33';
      cc.stroke();
    });
  });
};

      const 設定 = () => {
        通路列数 = 通路列数群[面数];
        解像度 = 解像度群[面数];
        方向数 = 方向数群[面数];
        面接続情報群 = 面接続情報群群[面数];
        角度1 = 定数群[面数].角度1;
        角度2 = 定数群[面数].角度2;
        線分1 = 定数群[面数].線分1;
        線分3 = 定数群[面数].線分3;
        通路厚角度 = 角度2 / 通路列数 / 2 - 隔壁厚角度;
        座標群 = {};
        const 隔壁厚距離群 = 座標取得(隔壁厚角度, 線分3);
        const 通路厚距離群 = 座標取得(通路厚角度, 線分3);
        隔壁厚距離1 = 隔壁厚距離群.X;
        隔壁厚距離2 = 隔壁厚距離群.Y;
        通路厚距離1 = 通路厚距離群.X;
        通路厚距離2 = 通路厚距離群.Y;
        迷路座標群.splice(0);
        隔壁平面群.splice(0);
        通路平面群.splice(0);
        壁頂平面群.splice(0);
        通路群.splice(0);
        連絡口群.splice(0);
        管轄群.splice(0);
        拡張可能通路群.splice(0);
        Array(面数).fill(null).fill(null).forEach((_, 面) => {
          通路群[面] = Array(通路列数).fill(null).map(() => []);
          連絡口群[面] = Array(通路列数).fill(null).map(() => []);
        });
        隔壁臨界位置群 = Array(通路列数).fill(null).map((_1, 列) =>
          [0, 1].map((表裏) => {
            const 角度X = 角度2 / 通路列数 * (列 + 1) + 隔壁厚角度 * [-1, 1][表裏];
            const { X: 距離X1, Y: 楕円A } = 座標取得(角度2 - 角度X, 線分3);
            const 座標Y1 = Math.sin(角度X) * 線分3;
            const 交線A = Math.cos(Math.PI / 方向数) / 線分1;
            const 交線B0 = Math.sin(Math.PI / 2 - 角度2) * 距離X1 * -1;
            const 交線B1 = 隔壁厚距離1 / Math.sin(Math.PI / 方向数);
            const 楕円B = 座標Y1 - 交線B0;
            const { X: 交点X0 } = 楕円交線座標取得(楕円A, 楕円B, 交線B0, 交線A, 0);
            const { X: 交点X1 } = 楕円交線座標取得(楕円A, 楕円B, 交線B0, 交線A, 交線B1);
            const 角度Y0 = Math.asin(交点X0 / 楕円A);
            const 角度Y1 = Math.asin(交点X1 / 楕円A);

            return { 角度X, 角度Y: 角度Y0, 楕円A, 楕円B, 交線B: 交線B0 };
          })
        );
        隔壁臨界位置群[-1] = [null, (() => {
          const 角度X = 隔壁厚角度;
          const { X: 距離X1, Y: 楕円A } = 座標取得(角度2 - 角度X, 線分3);
          const 座標Y1 = Math.sin(角度X) * 線分3;
          const 交線A = Math.cos(Math.PI / 方向数) / 線分1;
          const 交線B0 = Math.sin(Math.PI / 2 - 角度2) * 距離X1 * -1;
          const 交線B1 = 隔壁厚距離1 / Math.sin(Math.PI / 方向数);
          const 楕円B = 座標Y1 - 交線B0;
          const { X: 交点X0 } = 楕円交線座標取得(楕円A, 楕円B, 交線B0, 交線A, 0);
          const { X: 交点X1 } = 楕円交線座標取得(楕円A, 楕円B, 交線B0, 交線A, 交線B1);
          const 角度Y0 = Math.asin(交点X0 / 楕円A);
          const 角度Y1 = Math.asin(交点X1 / 楕円A);

          return { 角度X, 角度Y: 角度Y0, 楕円A, 楕円B, 交線B: 交線B0 };
        })()];
      };

      const 構築 = () => {
        re = [];
        iz = [];
        if (!検査) {
          列連結();
          面連結();
        }
        re.push(['']);
        rea();
        if (検査) {
          拡張([通路群[検査[0]][検査[1]][検査[2]], 検査[3]]);
        } else {
          拡張();
        }
        構成();
        再現();
        再生();
      };
      const 面指定器 = document.再生['面指定']
      const 面選択肢 = 面指定器.options;
      Array.from(面選択肢).forEach((候補) => {
        if (parseInt(候補.value) === 面数) {
          候補.selected = true;
        }
      });

      面指定器.onchange = () => {
        const 選択番号 = 面指定器.selectedIndex;
        面数 = parseInt(面選択肢[選択番号].value);
        設定();
        構築();
      };

// ▼検査用▼












// ▲検査用▲

      if (!検査) {
        設定();
      }
      構築();
      sc(1,2)
    </script>
  </body>
</html>