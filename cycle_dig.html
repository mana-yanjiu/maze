<html>
  <head>
    <meta charset="utf-8" />
    <style>
      #画面 {
        position: relative;
      }
      #通路 {
        position: absolute;
        z-index: 1;
      }
      #隔壁 {
        position: absolute;
        z-index: 2;
      }
      #検査 {
        position: absolute;
        z-index: 2;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="画面">
      <canvas id="通路"></canvas>
      <canvas id="隔壁"></canvas>
      <canvas id="検査"></canvas>
    </div>
    <script>
      const 半径 = 200;
      const 中心半径比率 = 1;
      const 中心空間確保 = true;
      const 殻数 = 7;
      const 隔壁厚 = 15;
      const 通路幅 = 半径 / (殻数 - 1 + 中心半径比率);
      const 中心 = 半径 + 隔壁厚;
      const 検査 = false;

      const 通路画面 = document.getElementById('通路');
      const 通路画面制御 = 通路画面.getContext('2d');
      const 隔壁画面 = document.getElementById('隔壁');
      const 隔壁画面制御 = 隔壁画面.getContext('2d');
      const 検査画面 = document.getElementById('検査');
      const 検査画面制御 = 検査画面.getContext('2d');
      通路画面.width = 中心 * 2;
      通路画面.height = 中心 * 2;
      隔壁画面.width = 中心 * 2;
      隔壁画面.height = 中心 * 2;
      検査画面.width = 中心 * 2;
      検査画面.height = 中心 * 2;

      const 通路群 = Array(殻数).fill(null).map(() => []);
      const 拡張可能通路群 = [];
      const 連絡口群 = Array(殻数).fill(null).map(() => []);
      const 隔壁群 = Array(殻数).fill(null).map(() => []);
      const 管轄群 = [0];

      const 殻半径取得 = (殻) => 通路幅 * (殻 + 中心半径比率);

      const 殻円周取得 = (殻) => 殻半径取得(殻) * 2 * Math.PI;

      const 連絡口幅取得 = (殻) => 殻円周取得(殻) * Math.asin(通路幅 / 2 / 殻半径取得(殻)) / Math.PI;

      const 連絡口合成 = (始端1, 終端1, 始端2, 終端2) =>
        Array(3).fill(null).reduce((合成結果, _, 加算係数) => {
          if (!合成結果 && (
            (始端1 < 終端2 + 加算係数 - 1 && 終端1 > 始端2 + 加算係数 - 1) ||
            (始端2 + 加算係数 - 1 < 終端1 && 終端2 + 加算係数 - 1 > 始端1)
          )) {
            合成結果 = {
              始端: Math.min(始端1, 始端2 + 加算係数 - 1),
              終端: Math.max(終端1, 終端2 + 加算係数 - 1),
            };
            if (合成結果.始端 < 0) {
              合成結果.始端 += 1;
              合成結果.終端 += 1;
            } else if (合成結果.始端 >= 1) {
              合成結果.始端 -= 1;
              合成結果.終端 -= 1;
            }
          }

          return 合成結果;
        }, null);

      const 管轄合成 = (管轄1, 管轄2) => {
        const 上位管轄 = Math.min(管轄群[管轄1], 管轄群[管轄2]);
        const 下位管轄 = Math.max(管轄群[管轄1], 管轄群[管轄2]);
        管轄群.forEach((管轄, 番号) => {
          if (管轄 === 下位管轄) {
            管轄群[番号] = 上位管轄;
          }
        });
      };

      const 有効通路範囲分割 = (殻, 方向, 始端, 終端) => {
        if (始端 > 1) {
          始端 = 始端 - 1;
          終端 = 終端 - 1;
        }

        const 範囲群 = [];
        const 隔壁殻 = 殻 + (方向 === '外端' ? 1 : 0);
        const 範囲内隔壁群 = [...((隔壁群[隔壁殻] || []).filter((角度) => 角度 > 始端 && 角度 < 終端)), 終端];
        const 殻円周 = 殻円周取得(殻);
        const 連絡口幅 = 連絡口幅取得(殻);
        範囲内隔壁群.forEach((角度) => {
          if ((角度 - 始端) * 殻円周 >= 連絡口幅) {
            範囲群.push({ 始端, 終端: 角度 });
          }
          始端 = 角度;
        });

        return 範囲群;
      };

      const 拡張可能壁群取得 = (通路) =>
        ['内端', '外端'].reduce((拡張可能壁群, 比較方向, 係数) => {
          拡張可能壁群[比較方向] = [];
          if (
            (比較方向 === '外端' && 通路.殻 === 殻数 - 1) ||
            (比較方向 === '内端' && 通路.殻 === 0)
          ) {
            return 拡張可能壁群;
          }

          const 比較通路群 = [...(通路群[通路.殻 + (係数 ? 1 : -1)] || [])];
          const 終端比較通路 = 比較通路群[比較通路群.length - 1];
          if ((終端比較通路?.終端 || 0) > 1) {
            比較通路群.unshift({ 始端: 終端比較通路.始端 - 1, 終端: 終端比較通路.終端 - 1, 管轄: 終端比較通路.管轄 });
          }
          if (通路.終端 > 1) {
            比較通路群.push(...比較通路群.map((比較通路) => ({ 始端: 比較通路.始端 + 1, 終端: 比較通路.終端 + 1, 管轄: 比較通路.管轄 })));
          }

          let { 始端 } = 通路;

          try {
            比較通路群.forEach((比較通路, j) => {
              if (管轄群[通路.管轄] !== 管轄群[比較通路.管轄] || 通路.終端 <= 比較通路.始端 || 通路.始端 >= 比較通路.終端) {
                return;
              }
              if (始端 < 比較通路.始端) {
                拡張可能壁群[比較方向].push(...有効通路範囲分割(通路.殻 + 係数 - 1, 比較方向, 始端, 比較通路.始端));
              }
              if (通路.終端 <= 比較通路.終端) {
                throw '精査終了';
              }
              始端 = 比較通路.終端;
            });
            if (始端 < 通路.終端) {
              拡張可能壁群[比較方向].push(...有効通路範囲分割(通路.殻 + 係数 - 1, 比較方向, 始端, 通路.終端));
            }
          } catch (_例外) {
          }

          return 拡張可能壁群;
        }, {});

      const 初期化 = async (殻 = 0) => {
        const 殻円周 = 殻円周取得(殻);
        const 連絡口始端位置 = Math.random();
        const 連絡口終端位置 = (殻円周 * 連絡口始端位置 + 連絡口幅取得(殻)) / 殻円周;
        連絡口群[殻].push({ 始端: 連絡口始端位置, 終端: 連絡口終端位置 });

        if (殻 === 0 && 中心空間確保) {
          通路群[殻].push({
            殻,
            管轄: 0,
            始端: 0,
            終端: 1,
            末端情報: { 始端: false, 終端: false },
          });
          await 延長描画(殻, 0, 1);
        } else {
          const 合成結果範囲 = 殻 > 0 && 連絡口合成(連絡口始端位置, 連絡口終端位置, 通路群[殻][0].始端, 通路群[殻][0].終端);
          if (合成結果範囲) {
            通路群[殻][0].始端 = 合成結果範囲.始端;
            通路群[殻][0].終端 = 合成結果範囲.終端;
          } else {
            管轄群.push(管轄群.length);
            const 通路 = {
              殻,
              管轄: 管轄群.length - 1,
              始端: 連絡口始端位置,
              終端: 連絡口終端位置,
              末端情報: { 始端: true, 終端: true },
            };
            通路群[殻].push(通路);
            拡張可能通路群.push(通路);
          }
          await 延長描画(殻, 連絡口始端位置, 連絡口終端位置);
        }
        if (殻 < 殻数 - 1) {
          const 外接通路 = {
            殻: 殻 + 1,
            管轄: 管轄群.length - 1,
            始端: 連絡口始端位置,
            終端: 連絡口終端位置,
            末端情報: { 始端: true, 終端: true },
          };
          通路群[殻 + 1].push(外接通路);
          拡張可能通路群.push(外接通路);
        }

        連絡口群[殻].sort((A, B) => A.始端 - B.始端);
        通路群[殻].sort((A, B) => A.始端 - B.始端);

        await 貫通描画(殻, '外端', 連絡口始端位置, 連絡口終端位置);

        if (殻 < 殻数 - 1) {
          await 初期化(殻 + 1);
        }
      };

      const 拡張 = async () => {
        const 拡張通路 = 拡張可能通路群[Math.floor(拡張可能通路群.length * Math.random())];
        const { 殻, 末端情報: { 始端, 終端 } } = 拡張通路;
        const 通路番号 = 通路群[殻].findIndex((通路) => 通路 === 拡張通路);
        const 拡張通路番号 = 拡張可能通路群.findIndex((通路) => 通路 === 拡張通路);
        const 拡張可能壁群 = 拡張可能壁群取得(拡張通路);
        const 拡張方向候補群 = [
          ...(始端 ? ['始端'] : []),
          ...(終端 ? ['終端'] : []),
          ...(拡張可能壁群.外端.length ? ['外端'] : []),
          ...(拡張可能壁群.内端.length ? ['内端'] : []),
        ];
        const 拡張方向 = 拡張方向候補群.length
          ? 拡張方向候補群[Math.floor(Math.random() * 拡張方向候補群.length)]
          : null;

        if (['始端', '終端'].includes(拡張方向)) {
if (検査) RE.push(`(${TR.length}) ${殻}:${通路番号} >> ${拡張方向}`);
          const 比較通路 = 拡張方向 === '始端'
            ? (通路群[殻][(通路番号 - 1 + 通路群[殻].length) % 通路群[殻].length])
            : (通路群[殻][(通路番号 + 1) % 通路群[殻].length]);
          const 拡張幅 = 連絡口幅取得(殻) * (1 + Math.random() * 2) / 殻円周取得(殻);
          const 拡張位置 = 拡張通路[拡張方向];
          const 比較始端 = 比較通路.始端 + (拡張方向 === '始端' && 拡張通路.始端 < 比較通路.終端 ? -1 : (拡張方向 === '終端' && 拡張通路.終端 > 比較通路.始端 ? 1 : 0));
          const 比較終端 = 比較通路.終端 + (拡張方向 === '始端' && 拡張通路.始端 < 比較通路.終端 ? -1 : (拡張方向 === '終端' && 拡張通路.終端 > 比較通路.始端 ? 1 : 0));
          if (
            (拡張方向 === '始端' && 拡張通路.始端 - 拡張幅 < 比較終端) ||
            (拡張方向 === '終端' && 拡張通路.終端 + 拡張幅 > 比較始端)
          ) {
            if (管轄群[拡張通路.管轄] === 管轄群[比較通路.管轄]) {
              if (拡張方向 === '始端') {
                拡張通路.始端 = 比較通路.終端 % 1;
                拡張通路.終端 += (拡張通路.始端 > 拡張通路.終端 ? 1 : 0);
                拡張通路.末端情報.始端 = false;
                比較通路.末端情報.終端 = false;
                隔壁群[殻].push(拡張通路.始端);
                await 延長描画(殻, 拡張位置, 拡張通路.始端 - (拡張通路.始端 > 拡張位置 ? 1 : 0));
              } else {
                拡張通路.終端 = 比較通路.始端 + (拡張通路.始端 >= 比較通路.始端 ? 1 : 0);
                拡張通路.末端情報.終端 = false;
                比較通路.末端情報.始端 = false;
                隔壁群[殻].push(拡張通路.終端 % 1);
                await 延長描画(殻, 拡張位置, 拡張通路.終端 + (拡張通路.終端 < 拡張位置 ? 1 : 0));
              }
              隔壁群[殻].sort((A, B) => A.始端 - B.始端);
              隔壁描画(殻, 隔壁群[殻][隔壁群[殻].length - 1]);
            } else {
              const 合成始端 = 拡張方向 === '始端' ? Math.min(拡張通路.始端 - 拡張幅, 比較始端) : 拡張通路.始端;
              const 合成終端 = 拡張方向 === '終端' ? Math.max(拡張通路.終端 + 拡張幅, 比較終端) : 拡張通路.終端;
              比較通路.始端 = (合成始端 + 1) % 1;
              比較通路.終端 = (合成終端 % 1) + (合成終端 % 1 < 比較通路.始端 ? 1 : 0);
              通路群[殻].splice(通路番号, 1);
              拡張可能通路群.splice(拡張通路番号, 1);
              管轄合成(拡張通路.管轄, 比較通路.管轄);
              if (拡張方向 === '始端') {
                await 延長描画(殻, 拡張位置, 比較終端);
                if (比較始端 % 1 !== 合成始端 % 1) {
                  await 延長描画(殻, 比較始端, 合成始端 - (比較始端 < 合成始端 ? 1 : 0));
                }
              } else {
                await 延長描画(殻, 拡張位置, 比較始端);
                if (比較終端 % 1 !== 合成終端 % 1) {
                  await 延長描画(殻, 比較終端, 合成終端 + (比較終端 > 合成終端 ? 1 : 0));
                }
              }
            }
          } else {
            const 拡張始端 = 拡張通路.始端 - (拡張方向 === '始端' ? 拡張幅 : 0);
            const 拡張終端 = 拡張通路.終端 + (拡張方向 === '終端' ? 拡張幅 : 0);
            拡張通路.始端 = (拡張始端 + 1) % 1;
            拡張通路.終端 = (拡張終端 % 1) + (拡張終端 % 1 < 拡張通路.始端 ? 1 : 0);
            const 延長位置 = 拡張方向 === '始端'
              ? 拡張通路.始端 - (拡張位置 < 拡張通路.始端 ? 1 : 0)
              : 拡張通路.終端 + (拡張位置 > 拡張通路.終端 ? 1 : 0);
            await 延長描画(殻, 拡張位置, 延長位置);
          }
          通路群[殻].sort((A, B) => A.始端 - B.始端);
        } else if (['外端', '内端'].includes(拡張方向)) {
          const 拡張通路殻 = 殻 + (拡張方向 === '外端' ? 1 : -1);
          const 拡張連絡口殻 = 殻 - (拡張方向 === '内端' ? 1 : 0);
          const 拡張壁 = 拡張可能壁群[拡張方向][Math.floor(Math.random() * 拡張可能壁群[拡張方向].length)];
          const 殻円周 = 殻円周取得(拡張連絡口殻);
          const 連絡口幅 = 連絡口幅取得(拡張連絡口殻);
          const 拡張壁始端周位置 = (拡張壁.始端 * 殻円周 + (拡張壁.終端 * 殻円周 - 連絡口幅 - 拡張壁.始端 * 殻円周) * Math.random()) % 殻円周;
          const 拡張壁終端周位置 = 拡張壁始端周位置 + 連絡口幅;
          const 連絡口 = { 始端: 拡張壁始端周位置 / 殻円周, 終端: 拡張壁終端周位置 / 殻円周 };
if (検査) RE.push(`(${TR.length}) ${殻}:${通路番号} >> ${拡張方向}:${連絡口.始端}`);
          連絡口群[拡張連絡口殻].push(連絡口);
          連絡口群[拡張連絡口殻].sort((A, B) => A.始端 - B.始端);
          let 新規通路 = null;
          通路群[拡張通路殻].forEach((比較通路) => {
            const { 始端: 新規始端, 終端: 新規終端, 管轄: 新規管轄 } = 新規通路 || { ...連絡口, 管轄: 拡張通路.管轄 };
            const 合成結果範囲 = 連絡口合成(新規始端, 新規終端, 比較通路.始端, 比較通路.終端);
            if (合成結果範囲) {
              比較通路.末端情報.始端 = 合成結果範囲.始端 === 比較通路.始端 ? 比較通路.末端情報.始端 : true;
              比較通路.末端情報.終端 = 合成結果範囲.終端 === 比較通路.終端 ? 比較通路.末端情報.終端 : true;
              比較通路.始端 = 合成結果範囲.始端;
              比較通路.終端 = 合成結果範囲.終端;
              if (新規通路) {
                const 新規通路番号 = 通路群.findIndex((通路) => 通路 === 新規通路);
                通路群[殻].splice(新規通路番号, 1);
                通路群[殻].sort((A, B) => A.始端 - B.始端);
              }
              管轄合成(新規管轄, 比較通路.管轄);
              新規通路 = 比較通路;
            }
          });
          if (!新規通路) {
            新規通路 = {
              ...連絡口,
              殻: 拡張通路殻,
              管轄: 拡張通路.管轄,
              末端情報: { 始端: true, 終端: true },
            };
            通路群[拡張通路殻].push(新規通路);
            通路群[拡張通路殻].sort((A, B) => A.始端 - B.始端);
            拡張可能通路群.push(新規通路);
          }
          await 貫通描画(殻, 拡張方向, 連絡口.始端, 連絡口.終端);
        } else {
          拡張可能通路群.splice(拡張通路番号, 1);
if (検査) RE.push(`(${TR.length}) ${殻}:${通路番号} >> × (${拡張通路番号})`);
        }
if (検査) {
TR.push(JSON.stringify(通路群));
KT.push(JSON.stringify(拡張可能通路群));
RK.push(JSON.stringify(連絡口群));
KK.push(JSON.stringify(管轄群));
KH.push(JSON.stringify(隔壁群));
}
        if (拡張可能通路群.length) {
          await 拡張();
        }
      };

      const 貫通描画 = (殻, 方向, 始端, 終端, 内部参照情報 = null) => new Promise((resolve) => {
        if (!内部参照情報) {
          const 出発殻半径 = 殻半径取得(殻 + (方向 === '外端' ? 0 : -1));
          const 到着殻半径 = 殻半径取得(殻 + (方向 === '外端' ? 1 : -2));
          内部参照情報 = {
            進捗: 1,
            出発殻半径,
            到着殻半径,
            出発半径: 出発殻半径 + (隔壁厚 / 2 + 1) * (方向 === '外端' ? -1 : 1),
            到着半径: 到着殻半径 + (隔壁厚 / 2 - 1) * (方向 === '外端' ? -1 : 1),
            通路始端角度: 始端 * Math.PI * 2,
            通路終端角度: 終端 * Math.PI * 2,
            連絡口余剰角度: Math.asin(通路幅 / 2 / 出発殻半径) - Math.asin((通路幅 - 隔壁厚) / 2 / 出発殻半径),
          };

          隔壁画面制御.globalCompositeOperation = 'destination-out';
        }
        const 最終進捗 = 10;
        const { 進捗, 出発殻半径, 到着殻半径, 出発半径, 到着半径, 通路始端角度, 通路終端角度, 連絡口余剰角度 } = 内部参照情報;
        const 進捗半径 = 進捗 < 最終進捗
          ? 出発半径 + (Math.abs(到着殻半径 - 出発半径) - 隔壁厚) * (方向 === '外端' ? 2 : -2) * 進捗 / 最終進捗
          : 到着半径;
        通路画面制御.beginPath();
        通路画面制御.arc(中心, 中心, 出発半径, 通路始端角度, 通路終端角度, false);
        通路画面制御.arc(中心, 中心, 進捗半径, 通路終端角度, 通路始端角度, true);
        通路画面制御.closePath();
        通路画面制御.fill();
        if (
          (方向 === '外端' && 進捗半径 <= 出発殻半径 + 隔壁厚 / 2 + 2) ||
          (方向 === '内端' && 進捗半径 >= 出発殻半径 - 隔壁厚 / 2 - 2)
        ) {
          隔壁画面制御.beginPath();
          隔壁画面制御.arc(中心, 中心, 出発半径, 通路始端角度 + 連絡口余剰角度, 通路終端角度 - 連絡口余剰角度, false);
          隔壁画面制御.arc(中心, 中心, 進捗半径, 通路終端角度 - 連絡口余剰角度, 通路始端角度 + 連絡口余剰角度, true);
          隔壁画面制御.closePath();
          隔壁画面制御.fill();
        }

        if (進捗 < 最終進捗) {
          内部参照情報.進捗 ++;
          setTimeout(async () => {
            await 貫通描画(殻, 方向, 始端, 終端, 内部参照情報);
            resolve();
          }, 10);
        } else {
          resolve();
        }
      });

      const 延長描画 = (殻, 始端, 終端, 内部参照情報 = null) => new Promise((resolve) => {
        if (!内部参照情報) {
          内部参照情報 = {
            進捗: 1,
            最終進捗: Math.max(Math.round(殻円周取得(殻) * Math.abs(終端 - 始端) / 通路幅 * 10), 1),
            殻半径: 殻半径取得(殻) - 通路幅 / 2,
            出発角度: 始端 * Math.PI * 2,
            到着角度: 終端 * Math.PI * 2,
          };
        }
        const { 進捗, 最終進捗, 殻半径, 出発角度, 到着角度 } = 内部参照情報;
        const 進捗角度 = 出発角度 + (到着角度 - 出発角度) * 進捗 / 最終進捗;
        通路画面制御.beginPath();
        通路画面制御.arc(中心, 中心, 殻半径, 出発角度, 進捗角度, 始端 > 終端);
        通路画面制御.stroke();

        if (進捗 < 最終進捗) {
          内部参照情報.進捗 ++;
          setTimeout(async () => {
            await 延長描画(殻, 始端, 終端, 内部参照情報);
            resolve();
          }, 10);
        } else {
          resolve();
        }
      });

      const 隔壁描画 = (殻, 位置) => {
        const 殻内半径 = 殻半径取得(殻 - 1);
        const 殻外半径 = 殻半径取得(殻);
        const 横位置 = Math.cos(位置 * 2 * Math.PI);
        const 縦位置 = Math.sin(位置 * 2 * Math.PI);
        隔壁画面制御.globalCompositeOperation = 'source-over';
        隔壁画面制御.beginPath();
        隔壁画面制御.moveTo(中心 + 横位置 * 殻内半径, 中心 + 縦位置 * 殻内半径);
        隔壁画面制御.lineTo(中心 + 横位置 * 殻外半径, 中心 + 縦位置 * 殻外半径);
        隔壁画面制御.stroke();
      };

      通路画面制御.fillStyle = '#000000';
      通路画面制御.beginPath();
      通路画面制御.arc(中心, 中心, 殻半径取得(殻数 - 1), 0, Math.PI * 2);
      通路画面制御.fill();
      通路画面制御.fillStyle = '#ffffff';
      通路画面制御.strokeStyle = '#ffffff';
      通路画面制御.lineWidth = 通路幅 + 1;

      隔壁画面制御.strokeStyle = '#000000';
      隔壁画面制御.lineWidth = 隔壁厚;
      Array(殻数).fill(null).forEach((_, 殻) => {
        const 殻半径 = 殻半径取得(殻);
        隔壁画面制御.beginPath();
        隔壁画面制御.arc(中心, 中心, 殻半径, 0, Math.PI * 2);
        隔壁画面制御.stroke();
      });

      検査画面制御.lineWidth = 1;
      Array(10).fill(null).forEach((_, i) => {
        検査画面制御.strokeStyle = i % 2 ? '#ffff0088' : '#ffff00';
        const T = Math.PI / 10 * i;
        検査画面制御.beginPath();
        検査画面制御.moveTo(中心 - Math.cos(T) * 半径, 中心 - Math.sin(T) * 半径);
        検査画面制御.lineTo(中心 + Math.cos(T) * 半径, 中心 + Math.sin(T) * 半径);
        検査画面制御.stroke();
      });

      const TR = [JSON.stringify(通路群)];
      const KT = [JSON.stringify(拡張可能通路群)];
      const RK = [JSON.stringify(連絡口群)];
      const KK = [JSON.stringify(管轄群)];
      const KH = [JSON.stringify(隔壁群)];
      const RE = [];

      const 再現 = (数) => {
        通路群.splice(0);
        JSON.parse(TR[数]).forEach((S) => {
          通路群.push(S);
        });
        拡張可能通路群.splice(0);
        JSON.parse(KT[数]).forEach((S) => {
          拡張可能通路群.push(通路群[S.殻].find((T) => S.始端 === T.始端));
        });
        連絡口群.splice(0);
        JSON.parse(RK[数]).forEach((S) => {
          連絡口群.push(S);
        });
        管轄群.splice(0);
        JSON.parse(KK[数]).forEach((S) => {
          管轄群.push(S);
        });
        隔壁群.splice(0);
        JSON.parse(KH[数]).forEach((S) => {
          隔壁群.push(S);
        });

        通路画面制御.clearRect(0, 0, 中心 * 2, 中心 * 2);
        隔壁画面制御.clearRect(0, 0, 中心 * 2, 中心 * 2);
        通路画面制御.fillStyle = '#00ff0088';
        通路群.forEach((殻内通路群, 殻) => {
          殻内通路群.forEach((通路, 番号) => {
            通路画面制御.beginPath();
            if (殻 === 0) {
              通路画面制御.moveTo(中心, 中心);
            } else {
              通路画面制御.arc(中心, 中心, 殻半径取得(殻 - 1), 通路.始端 * 2 * Math.PI, 通路.終端 * 2 * Math.PI, false);
            }
            通路画面制御.arc(中心, 中心, 殻半径取得(殻), 通路.終端 * 2 * Math.PI, 通路.始端 * 2 * Math.PI, true);
            通路画面制御.closePath();
            通路画面制御.fill();
          });
        });
        隔壁画面制御.strokeStyle = '#0000ff';
        隔壁画面制御.lineWidth = 隔壁厚;
        隔壁画面制御.globalCompositeOperation = 'source-over';
        連絡口群.forEach((殻内連絡口群, 殻) => {
          const 殻半径 = 殻半径取得(殻);
          const 連絡口余剰幅 = Math.asin(通路幅 / 2 / 殻半径) - Math.asin((通路幅 - 隔壁厚) / 2 / 殻半径);
          殻内連絡口群.forEach((連絡口, 番号) => {
            const 次連絡口 = 殻内連絡口群[(番号 + 1) % 殻内連絡口群.length];
            隔壁画面制御.beginPath();
            隔壁画面制御.arc(中心, 中心, 殻半径, 連絡口.終端 * 2 * Math.PI - 連絡口余剰幅, 次連絡口.始端 * 2 * Math.PI + 連絡口余剰幅);
            隔壁画面制御.stroke();
          });
        });
        隔壁群.forEach((殻内隔壁群, 殻) => {
          殻内隔壁群.forEach((殻内隔壁, 番号) => {
            const 殻内半径 = 殻半径取得(殻 - 1);
            const 殻外半径 = 殻半径取得(殻);
            隔壁画面制御.beginPath();
            隔壁画面制御.moveTo(中心 + Math.cos(殻内隔壁 * 2 * Math.PI) * 殻内半径, 中心 + Math.sin(殻内隔壁 * 2 * Math.PI) * 殻内半径);
            隔壁画面制御.lineTo(中心 + Math.cos(殻内隔壁 * 2 * Math.PI) * 殻外半径, 中心 + Math.sin(殻内隔壁 * 2 * Math.PI) * 殻外半径);
            隔壁画面制御.stroke();
          });
        });
      };

      (async () => {
        await 初期化();
        await 拡張();
      })();
    </script>
  </body>
</html>
